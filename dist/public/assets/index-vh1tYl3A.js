var uf = e => { throw TypeError(e) }; var Qa = (e, t, n) => t.has(e) || uf("Cannot " + n); var C = (e, t, n) => (Qa(e, t, "read from private field"), n ? n.call(e) : t.get(e)), _ = (e, t, n) => t.has(e) ? uf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), N = (e, t, n, r) => (Qa(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), B = (e, t, n) => (Qa(e, t, "access private method"), n); var Qi = (e, t, n, r) => ({ set _(s) { N(e, t, s, n) }, get _() { return C(e, t, r) } }); function Ow(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const s in r) if (s !== "default" && !(s in e)) { const i = Object.getOwnPropertyDescriptor(r, s); i && Object.defineProperty(e, s, i.get ? i : { enumerable: !0, get: () => r[s] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const i of s) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(s) { const i = {}; return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(s) { if (s.ep) return; s.ep = !0; const i = n(s); fetch(s.href, i) } })(); function mm(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var ym = { exports: {} }, va = {}, gm = { exports: {} }, $ = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Oi = Symbol.for("react.element"), _w = Symbol.for("react.portal"), Iw = Symbol.for("react.fragment"), Fw = Symbol.for("react.strict_mode"), Vw = Symbol.for("react.profiler"), zw = Symbol.for("react.provider"), Uw = Symbol.for("react.context"), Bw = Symbol.for("react.forward_ref"), $w = Symbol.for("react.suspense"), Ww = Symbol.for("react.memo"), Hw = Symbol.for("react.lazy"), cf = Symbol.iterator; function Kw(e) { return e === null || typeof e != "object" ? null : (e = cf && e[cf] || e["@@iterator"], typeof e == "function" ? e : null) } var vm = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, wm = Object.assign, xm = {}; function gs(e, t, n) { this.props = e, this.context = t, this.refs = xm, this.updater = n || vm } gs.prototype.isReactComponent = {}; gs.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; gs.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Sm() { } Sm.prototype = gs.prototype; function pc(e, t, n) { this.props = e, this.context = t, this.refs = xm, this.updater = n || vm } var mc = pc.prototype = new Sm; mc.constructor = pc; wm(mc, gs.prototype); mc.isPureReactComponent = !0; var df = Array.isArray, Cm = Object.prototype.hasOwnProperty, yc = { current: null }, Pm = { key: !0, ref: !0, __self: !0, __source: !0 }; function Em(e, t, n) { var r, s = {}, i = null, o = null; if (t != null) for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (i = "" + t.key), t) Cm.call(t, r) && !Pm.hasOwnProperty(r) && (s[r] = t[r]); var a = arguments.length - 2; if (a === 1) s.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; s.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]); return { $$typeof: Oi, type: e, key: i, ref: o, props: s, _owner: yc.current } } function Qw(e, t) { return { $$typeof: Oi, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function gc(e) { return typeof e == "object" && e !== null && e.$$typeof === Oi } function Gw(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var ff = /\/+/g; function Ga(e, t) { return typeof e == "object" && e !== null && e.key != null ? Gw("" + e.key) : t.toString(36) } function wo(e, t, n, r, s) { var i = typeof e; (i === "undefined" || i === "boolean") && (e = null); var o = !1; if (e === null) o = !0; else switch (i) { case "string": case "number": o = !0; break; case "object": switch (e.$$typeof) { case Oi: case _w: o = !0 } }if (o) return o = e, s = s(o), e = r === "" ? "." + Ga(o, 0) : r, df(s) ? (n = "", e != null && (n = e.replace(ff, "$&/") + "/"), wo(s, t, n, "", function (u) { return u })) : s != null && (gc(s) && (s = Qw(s, n + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(ff, "$&/") + "/") + e)), t.push(s)), 1; if (o = 0, r = r === "" ? "." : r + ":", df(e)) for (var a = 0; a < e.length; a++) { i = e[a]; var l = r + Ga(i, a); o += wo(i, t, n, l, s) } else if (l = Kw(e), typeof l == "function") for (e = l.call(e), a = 0; !(i = e.next()).done;)i = i.value, l = r + Ga(i, a++), o += wo(i, t, n, l, s); else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return o } function Gi(e, t, n) { if (e == null) return e; var r = [], s = 0; return wo(e, r, "", "", function (i) { return t.call(n, i, s++) }), r } function Xw(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var ze = { current: null }, xo = { transition: null }, Yw = { ReactCurrentDispatcher: ze, ReactCurrentBatchConfig: xo, ReactCurrentOwner: yc }; function Tm() { throw Error("act(...) is not supported in production builds of React.") } $.Children = { map: Gi, forEach: function (e, t, n) { Gi(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Gi(e, function () { t++ }), t }, toArray: function (e) { return Gi(e, function (t) { return t }) || [] }, only: function (e) { if (!gc(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; $.Component = gs; $.Fragment = Iw; $.Profiler = Vw; $.PureComponent = pc; $.StrictMode = Fw; $.Suspense = $w; $.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Yw; $.act = Tm; $.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = wm({}, e.props), s = e.key, i = e.ref, o = e._owner; if (t != null) { if (t.ref !== void 0 && (i = t.ref, o = yc.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Cm.call(t, l) && !Pm.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: Oi, type: e.type, key: s, ref: i, props: r, _owner: o } }; $.createContext = function (e) { return e = { $$typeof: Uw, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: zw, _context: e }, e.Consumer = e }; $.createElement = Em; $.createFactory = function (e) { var t = Em.bind(null, e); return t.type = e, t }; $.createRef = function () { return { current: null } }; $.forwardRef = function (e) { return { $$typeof: Bw, render: e } }; $.isValidElement = gc; $.lazy = function (e) { return { $$typeof: Hw, _payload: { _status: -1, _result: e }, _init: Xw } }; $.memo = function (e, t) { return { $$typeof: Ww, type: e, compare: t === void 0 ? null : t } }; $.startTransition = function (e) { var t = xo.transition; xo.transition = {}; try { e() } finally { xo.transition = t } }; $.unstable_act = Tm; $.useCallback = function (e, t) { return ze.current.useCallback(e, t) }; $.useContext = function (e) { return ze.current.useContext(e) }; $.useDebugValue = function () { }; $.useDeferredValue = function (e) { return ze.current.useDeferredValue(e) }; $.useEffect = function (e, t) { return ze.current.useEffect(e, t) }; $.useId = function () { return ze.current.useId() }; $.useImperativeHandle = function (e, t, n) { return ze.current.useImperativeHandle(e, t, n) }; $.useInsertionEffect = function (e, t) { return ze.current.useInsertionEffect(e, t) }; $.useLayoutEffect = function (e, t) { return ze.current.useLayoutEffect(e, t) }; $.useMemo = function (e, t) { return ze.current.useMemo(e, t) }; $.useReducer = function (e, t, n) { return ze.current.useReducer(e, t, n) }; $.useRef = function (e) { return ze.current.useRef(e) }; $.useState = function (e) { return ze.current.useState(e) }; $.useSyncExternalStore = function (e, t, n) { return ze.current.useSyncExternalStore(e, t, n) }; $.useTransition = function () { return ze.current.useTransition() }; $.version = "18.3.1"; gm.exports = $; var y = gm.exports; const cn = mm(y), qw = Ow({ __proto__: null, default: cn }, [y]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Zw = y, Jw = Symbol.for("react.element"), ex = Symbol.for("react.fragment"), tx = Object.prototype.hasOwnProperty, nx = Zw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, rx = { key: !0, ref: !0, __self: !0, __source: !0 }; function km(e, t, n) { var r, s = {}, i = null, o = null; n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (o = t.ref); for (r in t) tx.call(t, r) && !rx.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]); return { $$typeof: Jw, type: e, key: i, ref: o, props: s, _owner: nx.current } } va.Fragment = ex; va.jsx = km; va.jsxs = km; ym.exports = va; var w = ym.exports, Rm = { exports: {} }, rt = {}, bm = { exports: {} }, Am = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(D, O) { var V = D.length; D.push(O); e: for (; 0 < V;) { var H = V - 1 >>> 1, ae = D[H]; if (0 < s(ae, O)) D[H] = O, D[V] = ae, V = H; else break e } } function n(D) { return D.length === 0 ? null : D[0] } function r(D) { if (D.length === 0) return null; var O = D[0], V = D.pop(); if (V !== O) { D[0] = V; e: for (var H = 0, ae = D.length, Ut = ae >>> 1; H < Ut;) { var Rt = 2 * (H + 1) - 1, Ka = D[Rt], Wn = Rt + 1, Ki = D[Wn]; if (0 > s(Ka, V)) Wn < ae && 0 > s(Ki, Ka) ? (D[H] = Ki, D[Wn] = V, H = Wn) : (D[H] = Ka, D[Rt] = V, H = Rt); else if (Wn < ae && 0 > s(Ki, V)) D[H] = Ki, D[Wn] = V, H = Wn; else break e } } return O } function s(D, O) { var V = D.sortIndex - O.sortIndex; return V !== 0 ? V : D.id - O.id } if (typeof performance == "object" && typeof performance.now == "function") { var i = performance; e.unstable_now = function () { return i.now() } } else { var o = Date, a = o.now(); e.unstable_now = function () { return o.now() - a } } var l = [], u = [], c = 1, d = null, f = 3, m = !1, x = !1, v = !1, S = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, h = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function g(D) { for (var O = n(u); O !== null;) { if (O.callback === null) r(u); else if (O.startTime <= D) r(u), O.sortIndex = O.expirationTime, t(l, O); else break; O = n(u) } } function P(D) { if (v = !1, g(D), !x) if (n(l) !== null) x = !0, we(E); else { var O = n(u); O !== null && X(P, O.startTime - D) } } function E(D, O) { x = !1, v && (v = !1, p(T), T = -1), m = !0; var V = f; try { for (g(O), d = n(l); d !== null && (!(d.expirationTime > O) || D && !F());) { var H = d.callback; if (typeof H == "function") { d.callback = null, f = d.priorityLevel; var ae = H(d.expirationTime <= O); O = e.unstable_now(), typeof ae == "function" ? d.callback = ae : d === n(l) && r(l), g(O) } else r(l); d = n(l) } if (d !== null) var Ut = !0; else { var Rt = n(u); Rt !== null && X(P, Rt.startTime - O), Ut = !1 } return Ut } finally { d = null, f = V, m = !1 } } var R = !1, k = null, T = -1, b = 5, M = -1; function F() { return !(e.unstable_now() - M < b) } function j() { if (k !== null) { var D = e.unstable_now(); M = D; var O = !0; try { O = k(!0, D) } finally { O ? Oe() : (R = !1, k = null) } } else R = !1 } var Oe; if (typeof h == "function") Oe = function () { h(j) }; else if (typeof MessageChannel < "u") { var z = new MessageChannel, ve = z.port2; z.port1.onmessage = j, Oe = function () { ve.postMessage(null) } } else Oe = function () { S(j, 0) }; function we(D) { k = D, R || (R = !0, Oe()) } function X(D, O) { T = S(function () { D(e.unstable_now()) }, O) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (D) { D.callback = null }, e.unstable_continueExecution = function () { x || m || (x = !0, we(E)) }, e.unstable_forceFrameRate = function (D) { 0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < D ? Math.floor(1e3 / D) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return f }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (D) { switch (f) { case 1: case 2: case 3: var O = 3; break; default: O = f }var V = f; f = O; try { return D() } finally { f = V } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (D, O) { switch (D) { case 1: case 2: case 3: case 4: case 5: break; default: D = 3 }var V = f; f = D; try { return O() } finally { f = V } }, e.unstable_scheduleCallback = function (D, O, V) { var H = e.unstable_now(); switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? H + V : H) : V = H, D) { case 1: var ae = -1; break; case 2: ae = 250; break; case 5: ae = 1073741823; break; case 4: ae = 1e4; break; default: ae = 5e3 }return ae = V + ae, D = { id: c++, callback: O, priorityLevel: D, startTime: V, expirationTime: ae, sortIndex: -1 }, V > H ? (D.sortIndex = V, t(u, D), n(l) === null && D === n(u) && (v ? (p(T), T = -1) : v = !0, X(P, V - H))) : (D.sortIndex = ae, t(l, D), x || m || (x = !0, we(E))), D }, e.unstable_shouldYield = F, e.unstable_wrapCallback = function (D) { var O = f; return function () { var V = f; f = O; try { return D.apply(this, arguments) } finally { f = V } } } })(Am); bm.exports = Am; var sx = bm.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ix = y, et = sx; function A(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Mm = new Set, ii = {}; function gr(e, t) { is(e, t), is(e + "Capture", t) } function is(e, t) { for (ii[e] = t, e = 0; e < t.length; e++)Mm.add(t[e]) } var en = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Vl = Object.prototype.hasOwnProperty, ox = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, hf = {}, pf = {}; function ax(e) { return Vl.call(pf, e) ? !0 : Vl.call(hf, e) ? !1 : ox.test(e) ? pf[e] = !0 : (hf[e] = !0, !1) } function lx(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function ux(e, t, n, r) { if (t === null || typeof t > "u" || lx(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Ue(e, t, n, r, s, i, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = o } var ke = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { ke[e] = new Ue(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; ke[t] = new Ue(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { ke[e] = new Ue(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { ke[e] = new Ue(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { ke[e] = new Ue(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { ke[e] = new Ue(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { ke[e] = new Ue(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { ke[e] = new Ue(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { ke[e] = new Ue(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var vc = /[\-:]([a-z])/g; function wc(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(vc, wc); ke[t] = new Ue(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(vc, wc); ke[t] = new Ue(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(vc, wc); ke[t] = new Ue(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { ke[e] = new Ue(e, 1, !1, e.toLowerCase(), null, !1, !1) }); ke.xlinkHref = new Ue("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { ke[e] = new Ue(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function xc(e, t, n, r) { var s = ke.hasOwnProperty(t) ? ke[t] : null; (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (ux(t, n, s, r) && (n = null), r || s === null ? ax(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? !1 : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var on = ix.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Xi = Symbol.for("react.element"), Sr = Symbol.for("react.portal"), Cr = Symbol.for("react.fragment"), Sc = Symbol.for("react.strict_mode"), zl = Symbol.for("react.profiler"), Dm = Symbol.for("react.provider"), Nm = Symbol.for("react.context"), Cc = Symbol.for("react.forward_ref"), Ul = Symbol.for("react.suspense"), Bl = Symbol.for("react.suspense_list"), Pc = Symbol.for("react.memo"), hn = Symbol.for("react.lazy"), Lm = Symbol.for("react.offscreen"), mf = Symbol.iterator; function ks(e) { return e === null || typeof e != "object" ? null : (e = mf && e[mf] || e["@@iterator"], typeof e == "function" ? e : null) } var oe = Object.assign, Xa; function Is(e) {
  if (Xa === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Xa = t && t[1] || "" } return `
`+ Xa + e
} var Ya = !1; function qa(e, t) {
  if (!e || Ya) return ""; Ya = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var s = u.stack.split(`
`), i = r.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (s[o] !== i[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || s[o] !== i[a]) {
          var l = `
`+ s[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { Ya = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Is(e) : ""
} function cx(e) { switch (e.tag) { case 5: return Is(e.type); case 16: return Is("Lazy"); case 13: return Is("Suspense"); case 19: return Is("SuspenseList"); case 0: case 2: case 15: return e = qa(e.type, !1), e; case 11: return e = qa(e.type.render, !1), e; case 1: return e = qa(e.type, !0), e; default: return "" } } function $l(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Cr: return "Fragment"; case Sr: return "Portal"; case zl: return "Profiler"; case Sc: return "StrictMode"; case Ul: return "Suspense"; case Bl: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Nm: return (e.displayName || "Context") + ".Consumer"; case Dm: return (e._context.displayName || "Context") + ".Provider"; case Cc: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Pc: return t = e.displayName || null, t !== null ? t : $l(e.type) || "Memo"; case hn: t = e._payload, e = e._init; try { return $l(e(t)) } catch { } }return null } function dx(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return $l(t); case 8: return t === Sc ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function _n(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function jm(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function fx(e) { var t = jm(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var s = n.get, i = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return s.call(this) }, set: function (o) { r = "" + o, i.call(this, o) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Yi(e) { e._valueTracker || (e._valueTracker = fx(e)) } function Om(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = jm(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function Io(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Wl(e, t) { var n = t.checked; return oe({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function yf(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = _n(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function _m(e, t) { t = t.checked, t != null && xc(e, "checked", t, !1) } function Hl(e, t) { _m(e, t); var n = _n(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Kl(e, t.type, n) : t.hasOwnProperty("defaultValue") && Kl(e, t.type, _n(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function gf(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Kl(e, t, n) { (t !== "number" || Io(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Fs = Array.isArray; function Fr(e, t, n, r) { if (e = e.options, t) { t = {}; for (var s = 0; s < n.length; s++)t["$" + n[s]] = !0; for (n = 0; n < e.length; n++)s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = !0) } else { for (n = "" + _n(n), t = null, s = 0; s < e.length; s++) { if (e[s].value === n) { e[s].selected = !0, r && (e[s].defaultSelected = !0); return } t !== null || e[s].disabled || (t = e[s]) } t !== null && (t.selected = !0) } } function Ql(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(A(91)); return oe({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function vf(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(A(92)); if (Fs(n)) { if (1 < n.length) throw Error(A(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: _n(n) } } function Im(e, t) { var n = _n(t.value), r = _n(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function wf(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Fm(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Gl(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Fm(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var qi, Vm = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, s) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, s) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (qi = qi || document.createElement("div"), qi.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = qi.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function oi(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Hs = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, hx = ["Webkit", "ms", "Moz", "O"]; Object.keys(Hs).forEach(function (e) { hx.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Hs[t] = Hs[e] }) }); function zm(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Hs.hasOwnProperty(e) && Hs[e] ? ("" + t).trim() : t + "px" } function Um(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, s = zm(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s } } var px = oe({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Xl(e, t) { if (t) { if (px[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(A(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(A(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(A(61)) } if (t.style != null && typeof t.style != "object") throw Error(A(62)) } } function Yl(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var ql = null; function Ec(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Zl = null, Vr = null, zr = null; function xf(e) { if (e = Fi(e)) { if (typeof Zl != "function") throw Error(A(280)); var t = e.stateNode; t && (t = Pa(t), Zl(e.stateNode, e.type, t)) } } function Bm(e) { Vr ? zr ? zr.push(e) : zr = [e] : Vr = e } function $m() { if (Vr) { var e = Vr, t = zr; if (zr = Vr = null, xf(e), t) for (e = 0; e < t.length; e++)xf(t[e]) } } function Wm(e, t) { return e(t) } function Hm() { } var Za = !1; function Km(e, t, n) { if (Za) return e(t, n); Za = !0; try { return Wm(e, t, n) } finally { Za = !1, (Vr !== null || zr !== null) && (Hm(), $m()) } } function ai(e, t) { var n = e.stateNode; if (n === null) return null; var r = Pa(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(A(231, t, typeof n)); return n } var Jl = !1; if (en) try { var Rs = {}; Object.defineProperty(Rs, "passive", { get: function () { Jl = !0 } }), window.addEventListener("test", Rs, Rs), window.removeEventListener("test", Rs, Rs) } catch { Jl = !1 } function mx(e, t, n, r, s, i, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var Ks = !1, Fo = null, Vo = !1, eu = null, yx = { onError: function (e) { Ks = !0, Fo = e } }; function gx(e, t, n, r, s, i, o, a, l) { Ks = !1, Fo = null, mx.apply(yx, arguments) } function vx(e, t, n, r, s, i, o, a, l) { if (gx.apply(this, arguments), Ks) { if (Ks) { var u = Fo; Ks = !1, Fo = null } else throw Error(A(198)); Vo || (Vo = !0, eu = u) } } function vr(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Qm(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Sf(e) { if (vr(e) !== e) throw Error(A(188)) } function wx(e) { var t = e.alternate; if (!t) { if (t = vr(e), t === null) throw Error(A(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var s = n.return; if (s === null) break; var i = s.alternate; if (i === null) { if (r = s.return, r !== null) { n = r; continue } break } if (s.child === i.child) { for (i = s.child; i;) { if (i === n) return Sf(s), e; if (i === r) return Sf(s), t; i = i.sibling } throw Error(A(188)) } if (n.return !== r.return) n = s, r = i; else { for (var o = !1, a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) { for (a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) throw Error(A(189)) } } if (n.alternate !== r) throw Error(A(190)) } if (n.tag !== 3) throw Error(A(188)); return n.stateNode.current === n ? e : t } function Gm(e) { return e = wx(e), e !== null ? Xm(e) : null } function Xm(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Xm(e); if (t !== null) return t; e = e.sibling } return null } var Ym = et.unstable_scheduleCallback, Cf = et.unstable_cancelCallback, xx = et.unstable_shouldYield, Sx = et.unstable_requestPaint, fe = et.unstable_now, Cx = et.unstable_getCurrentPriorityLevel, Tc = et.unstable_ImmediatePriority, qm = et.unstable_UserBlockingPriority, zo = et.unstable_NormalPriority, Px = et.unstable_LowPriority, Zm = et.unstable_IdlePriority, wa = null, Ot = null; function Ex(e) { if (Ot && typeof Ot.onCommitFiberRoot == "function") try { Ot.onCommitFiberRoot(wa, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Et = Math.clz32 ? Math.clz32 : Rx, Tx = Math.log, kx = Math.LN2; function Rx(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Tx(e) / kx | 0) | 0 } var Zi = 64, Ji = 4194304; function Vs(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Uo(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, s = e.suspendedLanes, i = e.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~s; a !== 0 ? r = Vs(a) : (i &= o, i !== 0 && (r = Vs(i))) } else o = n & ~s, o !== 0 ? r = Vs(o) : i !== 0 && (r = Vs(i)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & s) && (s = r & -r, i = t & -t, s >= i || s === 16 && (i & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - Et(t), s = 1 << n, r |= e[n], t &= ~s; return r } function bx(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Ax(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i;) { var o = 31 - Et(i), a = 1 << o, l = s[o]; l === -1 ? (!(a & n) || a & r) && (s[o] = bx(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a } } function tu(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Jm() { var e = Zi; return Zi <<= 1, !(Zi & 4194240) && (Zi = 64), e } function Ja(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function _i(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Et(t), e[t] = n } function Mx(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var s = 31 - Et(n), i = 1 << s; t[s] = 0, r[s] = -1, e[s] = -1, n &= ~i } } function kc(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - Et(n), s = 1 << r; s & t | e[r] & t && (e[r] |= t), n &= ~s } } var G = 0; function ey(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var ty, Rc, ny, ry, sy, nu = !1, eo = [], bn = null, An = null, Mn = null, li = new Map, ui = new Map, mn = [], Dx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Pf(e, t) { switch (e) { case "focusin": case "focusout": bn = null; break; case "dragenter": case "dragleave": An = null; break; case "mouseover": case "mouseout": Mn = null; break; case "pointerover": case "pointerout": li.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": ui.delete(t.pointerId) } } function bs(e, t, n, r, s, i) { return e === null || e.nativeEvent !== i ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: i, targetContainers: [s] }, t !== null && (t = Fi(t), t !== null && Rc(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e) } function Nx(e, t, n, r, s) { switch (t) { case "focusin": return bn = bs(bn, e, t, n, r, s), !0; case "dragenter": return An = bs(An, e, t, n, r, s), !0; case "mouseover": return Mn = bs(Mn, e, t, n, r, s), !0; case "pointerover": var i = s.pointerId; return li.set(i, bs(li.get(i) || null, e, t, n, r, s)), !0; case "gotpointercapture": return i = s.pointerId, ui.set(i, bs(ui.get(i) || null, e, t, n, r, s)), !0 }return !1 } function iy(e) { var t = Yn(e.target); if (t !== null) { var n = vr(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Qm(n), t !== null) { e.blockedOn = t, sy(e.priority, function () { ny(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function So(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = ru(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); ql = r, n.target.dispatchEvent(r), ql = null } else return t = Fi(n), t !== null && Rc(t), e.blockedOn = n, !1; t.shift() } return !0 } function Ef(e, t, n) { So(e) && n.delete(t) } function Lx() { nu = !1, bn !== null && So(bn) && (bn = null), An !== null && So(An) && (An = null), Mn !== null && So(Mn) && (Mn = null), li.forEach(Ef), ui.forEach(Ef) } function As(e, t) { e.blockedOn === t && (e.blockedOn = null, nu || (nu = !0, et.unstable_scheduleCallback(et.unstable_NormalPriority, Lx))) } function ci(e) { function t(s) { return As(s, e) } if (0 < eo.length) { As(eo[0], e); for (var n = 1; n < eo.length; n++) { var r = eo[n]; r.blockedOn === e && (r.blockedOn = null) } } for (bn !== null && As(bn, e), An !== null && As(An, e), Mn !== null && As(Mn, e), li.forEach(t), ui.forEach(t), n = 0; n < mn.length; n++)r = mn[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < mn.length && (n = mn[0], n.blockedOn === null);)iy(n), n.blockedOn === null && mn.shift() } var Ur = on.ReactCurrentBatchConfig, Bo = !0; function jx(e, t, n, r) { var s = G, i = Ur.transition; Ur.transition = null; try { G = 1, bc(e, t, n, r) } finally { G = s, Ur.transition = i } } function Ox(e, t, n, r) { var s = G, i = Ur.transition; Ur.transition = null; try { G = 4, bc(e, t, n, r) } finally { G = s, Ur.transition = i } } function bc(e, t, n, r) { if (Bo) { var s = ru(e, t, n, r); if (s === null) ul(e, t, r, $o, n), Pf(e, r); else if (Nx(s, e, t, n, r)) r.stopPropagation(); else if (Pf(e, r), t & 4 && -1 < Dx.indexOf(e)) { for (; s !== null;) { var i = Fi(s); if (i !== null && ty(i), i = ru(e, t, n, r), i === null && ul(e, t, r, $o, n), i === s) break; s = i } s !== null && r.stopPropagation() } else ul(e, t, r, null, n) } } var $o = null; function ru(e, t, n, r) { if ($o = null, e = Ec(r), e = Yn(e), e !== null) if (t = vr(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Qm(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return $o = e, null } function oy(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Cx()) { case Tc: return 1; case qm: return 4; case zo: case Px: return 16; case Zm: return 536870912; default: return 16 }default: return 16 } } var kn = null, Ac = null, Co = null; function ay() { if (Co) return Co; var e, t = Ac, n = t.length, r, s = "value" in kn ? kn.value : kn.textContent, i = s.length; for (e = 0; e < n && t[e] === s[e]; e++); var o = n - e; for (r = 1; r <= o && t[n - r] === s[i - r]; r++); return Co = s.slice(e, 1 < r ? 1 - r : void 0) } function Po(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function to() { return !0 } function Tf() { return !1 } function st(e) { function t(n, r, s, i, o) { this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(i) : i[a]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? to : Tf, this.isPropagationStopped = Tf, this } return oe(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = to) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = to) }, persist: function () { }, isPersistent: to }), t } var vs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Mc = st(vs), Ii = oe({}, vs, { view: 0, detail: 0 }), _x = st(Ii), el, tl, Ms, xa = oe({}, Ii, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Dc, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ms && (Ms && e.type === "mousemove" ? (el = e.screenX - Ms.screenX, tl = e.screenY - Ms.screenY) : tl = el = 0, Ms = e), el) }, movementY: function (e) { return "movementY" in e ? e.movementY : tl } }), kf = st(xa), Ix = oe({}, xa, { dataTransfer: 0 }), Fx = st(Ix), Vx = oe({}, Ii, { relatedTarget: 0 }), nl = st(Vx), zx = oe({}, vs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ux = st(zx), Bx = oe({}, vs, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), $x = st(Bx), Wx = oe({}, vs, { data: 0 }), Rf = st(Wx), Hx = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Kx = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Qx = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Gx(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Qx[e]) ? !!t[e] : !1 } function Dc() { return Gx } var Xx = oe({}, Ii, { key: function (e) { if (e.key) { var t = Hx[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Po(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Kx[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Dc, charCode: function (e) { return e.type === "keypress" ? Po(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Po(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Yx = st(Xx), qx = oe({}, xa, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), bf = st(qx), Zx = oe({}, Ii, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Dc }), Jx = st(Zx), eS = oe({}, vs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), tS = st(eS), nS = oe({}, xa, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), rS = st(nS), sS = [9, 13, 27, 32], Nc = en && "CompositionEvent" in window, Qs = null; en && "documentMode" in document && (Qs = document.documentMode); var iS = en && "TextEvent" in window && !Qs, ly = en && (!Nc || Qs && 8 < Qs && 11 >= Qs), Af = " ", Mf = !1; function uy(e, t) { switch (e) { case "keyup": return sS.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function cy(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Pr = !1; function oS(e, t) { switch (e) { case "compositionend": return cy(t); case "keypress": return t.which !== 32 ? null : (Mf = !0, Af); case "textInput": return e = t.data, e === Af && Mf ? null : e; default: return null } } function aS(e, t) { if (Pr) return e === "compositionend" || !Nc && uy(e, t) ? (e = ay(), Co = Ac = kn = null, Pr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return ly && t.locale !== "ko" ? null : t.data; default: return null } } var lS = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Df(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!lS[e.type] : t === "textarea" } function dy(e, t, n, r) { Bm(r), t = Wo(t, "onChange"), 0 < t.length && (n = new Mc("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Gs = null, di = null; function uS(e) { Cy(e, 0) } function Sa(e) { var t = kr(e); if (Om(t)) return e } function cS(e, t) { if (e === "change") return t } var fy = !1; if (en) { var rl; if (en) { var sl = "oninput" in document; if (!sl) { var Nf = document.createElement("div"); Nf.setAttribute("oninput", "return;"), sl = typeof Nf.oninput == "function" } rl = sl } else rl = !1; fy = rl && (!document.documentMode || 9 < document.documentMode) } function Lf() { Gs && (Gs.detachEvent("onpropertychange", hy), di = Gs = null) } function hy(e) { if (e.propertyName === "value" && Sa(di)) { var t = []; dy(t, di, e, Ec(e)), Km(uS, t) } } function dS(e, t, n) { e === "focusin" ? (Lf(), Gs = t, di = n, Gs.attachEvent("onpropertychange", hy)) : e === "focusout" && Lf() } function fS(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Sa(di) } function hS(e, t) { if (e === "click") return Sa(t) } function pS(e, t) { if (e === "input" || e === "change") return Sa(t) } function mS(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var kt = typeof Object.is == "function" ? Object.is : mS; function fi(e, t) { if (kt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var s = n[r]; if (!Vl.call(t, s) || !kt(e[s], t[s])) return !1 } return !0 } function jf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Of(e, t) { var n = jf(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = jf(n) } } function py(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? py(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function my() { for (var e = window, t = Io(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Io(e.document) } return t } function Lc(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function yS(e) { var t = my(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && py(n.ownerDocument.documentElement, n)) { if (r !== null && Lc(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var s = n.textContent.length, i = Math.min(r.start, s); r = r.end === void 0 ? i : Math.min(r.end, s), !e.extend && i > r && (s = r, r = i, i = s), s = Of(n, i); var o = Of(n, r); s && o && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), i > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var gS = en && "documentMode" in document && 11 >= document.documentMode, Er = null, su = null, Xs = null, iu = !1; function _f(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; iu || Er == null || Er !== Io(r) || (r = Er, "selectionStart" in r && Lc(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Xs && fi(Xs, r) || (Xs = r, r = Wo(su, "onSelect"), 0 < r.length && (t = new Mc("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Er))) } function no(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Tr = { animationend: no("Animation", "AnimationEnd"), animationiteration: no("Animation", "AnimationIteration"), animationstart: no("Animation", "AnimationStart"), transitionend: no("Transition", "TransitionEnd") }, il = {}, yy = {}; en && (yy = document.createElement("div").style, "AnimationEvent" in window || (delete Tr.animationend.animation, delete Tr.animationiteration.animation, delete Tr.animationstart.animation), "TransitionEvent" in window || delete Tr.transitionend.transition); function Ca(e) { if (il[e]) return il[e]; if (!Tr[e]) return e; var t = Tr[e], n; for (n in t) if (t.hasOwnProperty(n) && n in yy) return il[e] = t[n]; return e } var gy = Ca("animationend"), vy = Ca("animationiteration"), wy = Ca("animationstart"), xy = Ca("transitionend"), Sy = new Map, If = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function zn(e, t) { Sy.set(e, t), gr(t, [e]) } for (var ol = 0; ol < If.length; ol++) { var al = If[ol], vS = al.toLowerCase(), wS = al[0].toUpperCase() + al.slice(1); zn(vS, "on" + wS) } zn(gy, "onAnimationEnd"); zn(vy, "onAnimationIteration"); zn(wy, "onAnimationStart"); zn("dblclick", "onDoubleClick"); zn("focusin", "onFocus"); zn("focusout", "onBlur"); zn(xy, "onTransitionEnd"); is("onMouseEnter", ["mouseout", "mouseover"]); is("onMouseLeave", ["mouseout", "mouseover"]); is("onPointerEnter", ["pointerout", "pointerover"]); is("onPointerLeave", ["pointerout", "pointerover"]); gr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); gr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); gr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); gr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); gr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); gr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var zs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), xS = new Set("cancel close invalid load scroll toggle".split(" ").concat(zs)); function Ff(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, vx(r, t, void 0, e), e.currentTarget = null } function Cy(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], s = r.event; r = r.listeners; e: { var i = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== i && s.isPropagationStopped()) break e; Ff(s, a, u), i = l } else for (o = 0; o < r.length; o++) { if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== i && s.isPropagationStopped()) break e; Ff(s, a, u), i = l } } } if (Vo) throw e = eu, Vo = !1, eu = null, e } function J(e, t) { var n = t[cu]; n === void 0 && (n = t[cu] = new Set); var r = e + "__bubble"; n.has(r) || (Py(t, e, 2, !1), n.add(r)) } function ll(e, t, n) { var r = 0; t && (r |= 4), Py(n, e, r, t) } var ro = "_reactListening" + Math.random().toString(36).slice(2); function hi(e) { if (!e[ro]) { e[ro] = !0, Mm.forEach(function (n) { n !== "selectionchange" && (xS.has(n) || ll(n, !1, e), ll(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[ro] || (t[ro] = !0, ll("selectionchange", !1, t)) } } function Py(e, t, n, r) { switch (oy(t)) { case 1: var s = jx; break; case 4: s = Ox; break; default: s = bc }n = s.bind(null, t, n, e), s = void 0, !Jl || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0), r ? s !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: s }) : e.addEventListener(t, n, !0) : s !== void 0 ? e.addEventListener(t, n, { passive: s }) : e.addEventListener(t, n, !1) } function ul(e, t, n, r, s) { var i = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === s || a.nodeType === 8 && a.parentNode === s) break; if (o === 4) for (o = r.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return; o = o.return } for (; a !== null;) { if (o = Yn(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { r = i = o; continue e } a = a.parentNode } } r = r.return } Km(function () { var u = i, c = Ec(n), d = []; e: { var f = Sy.get(e); if (f !== void 0) { var m = Mc, x = e; switch (e) { case "keypress": if (Po(n) === 0) break e; case "keydown": case "keyup": m = Yx; break; case "focusin": x = "focus", m = nl; break; case "focusout": x = "blur", m = nl; break; case "beforeblur": case "afterblur": m = nl; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = kf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = Fx; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = Jx; break; case gy: case vy: case wy: m = Ux; break; case xy: m = tS; break; case "scroll": m = _x; break; case "wheel": m = rS; break; case "copy": case "cut": case "paste": m = $x; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = bf }var v = (t & 4) !== 0, S = !v && e === "scroll", p = v ? f !== null ? f + "Capture" : null : f; v = []; for (var h = u, g; h !== null;) { g = h; var P = g.stateNode; if (g.tag === 5 && P !== null && (g = P, p !== null && (P = ai(h, p), P != null && v.push(pi(h, P, g)))), S) break; h = h.return } 0 < v.length && (f = new m(f, x, null, n, c), d.push({ event: f, listeners: v })) } } if (!(t & 7)) { e: { if (f = e === "mouseover" || e === "pointerover", m = e === "mouseout" || e === "pointerout", f && n !== ql && (x = n.relatedTarget || n.fromElement) && (Yn(x) || x[tn])) break e; if ((m || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window, m ? (x = n.relatedTarget || n.toElement, m = u, x = x ? Yn(x) : null, x !== null && (S = vr(x), x !== S || x.tag !== 5 && x.tag !== 6) && (x = null)) : (m = null, x = u), m !== x)) { if (v = kf, P = "onMouseLeave", p = "onMouseEnter", h = "mouse", (e === "pointerout" || e === "pointerover") && (v = bf, P = "onPointerLeave", p = "onPointerEnter", h = "pointer"), S = m == null ? f : kr(m), g = x == null ? f : kr(x), f = new v(P, h + "leave", m, n, c), f.target = S, f.relatedTarget = g, P = null, Yn(c) === u && (v = new v(p, h + "enter", x, n, c), v.target = g, v.relatedTarget = S, P = v), S = P, m && x) t: { for (v = m, p = x, h = 0, g = v; g; g = wr(g))h++; for (g = 0, P = p; P; P = wr(P))g++; for (; 0 < h - g;)v = wr(v), h--; for (; 0 < g - h;)p = wr(p), g--; for (; h--;) { if (v === p || p !== null && v === p.alternate) break t; v = wr(v), p = wr(p) } v = null } else v = null; m !== null && Vf(d, f, m, v, !1), x !== null && S !== null && Vf(d, S, x, v, !0) } } e: { if (f = u ? kr(u) : window, m = f.nodeName && f.nodeName.toLowerCase(), m === "select" || m === "input" && f.type === "file") var E = cS; else if (Df(f)) if (fy) E = pS; else { E = fS; var R = dS } else (m = f.nodeName) && m.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (E = hS); if (E && (E = E(e, u))) { dy(d, E, n, c); break e } R && R(e, f, u), e === "focusout" && (R = f._wrapperState) && R.controlled && f.type === "number" && Kl(f, "number", f.value) } switch (R = u ? kr(u) : window, e) { case "focusin": (Df(R) || R.contentEditable === "true") && (Er = R, su = u, Xs = null); break; case "focusout": Xs = su = Er = null; break; case "mousedown": iu = !0; break; case "contextmenu": case "mouseup": case "dragend": iu = !1, _f(d, n, c); break; case "selectionchange": if (gS) break; case "keydown": case "keyup": _f(d, n, c) }var k; if (Nc) e: { switch (e) { case "compositionstart": var T = "onCompositionStart"; break e; case "compositionend": T = "onCompositionEnd"; break e; case "compositionupdate": T = "onCompositionUpdate"; break e }T = void 0 } else Pr ? uy(e, n) && (T = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (T = "onCompositionStart"); T && (ly && n.locale !== "ko" && (Pr || T !== "onCompositionStart" ? T === "onCompositionEnd" && Pr && (k = ay()) : (kn = c, Ac = "value" in kn ? kn.value : kn.textContent, Pr = !0)), R = Wo(u, T), 0 < R.length && (T = new Rf(T, e, null, n, c), d.push({ event: T, listeners: R }), k ? T.data = k : (k = cy(n), k !== null && (T.data = k)))), (k = iS ? oS(e, n) : aS(e, n)) && (u = Wo(u, "onBeforeInput"), 0 < u.length && (c = new Rf("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = k)) } Cy(d, t) }) } function pi(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Wo(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var s = e, i = s.stateNode; s.tag === 5 && i !== null && (s = i, i = ai(e, n), i != null && r.unshift(pi(e, i, s)), i = ai(e, t), i != null && r.push(pi(e, i, s))), e = e.return } return r } function wr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Vf(e, t, n, r, s) { for (var i = t._reactName, o = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, s ? (l = ai(n, i), l != null && o.unshift(pi(n, l, a))) : s || (l = ai(n, i), l != null && o.push(pi(n, l, a)))), n = n.return } o.length !== 0 && e.push({ event: t, listeners: o }) } var SS = /\r\n?/g, CS = /\u0000|\uFFFD/g; function zf(e) {
  return (typeof e == "string" ? e : "" + e).replace(SS, `
`).replace(CS, "")
} function so(e, t, n) { if (t = zf(t), zf(e) !== t && n) throw Error(A(425)) } function Ho() { } var ou = null, au = null; function lu(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var uu = typeof setTimeout == "function" ? setTimeout : void 0, PS = typeof clearTimeout == "function" ? clearTimeout : void 0, Uf = typeof Promise == "function" ? Promise : void 0, ES = typeof queueMicrotask == "function" ? queueMicrotask : typeof Uf < "u" ? function (e) { return Uf.resolve(null).then(e).catch(TS) } : uu; function TS(e) { setTimeout(function () { throw e }) } function cl(e, t) { var n = t, r = 0; do { var s = n.nextSibling; if (e.removeChild(n), s && s.nodeType === 8) if (n = s.data, n === "/$") { if (r === 0) { e.removeChild(s), ci(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = s } while (n); ci(t) } function Dn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Bf(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var ws = Math.random().toString(36).slice(2), jt = "__reactFiber$" + ws, mi = "__reactProps$" + ws, tn = "__reactContainer$" + ws, cu = "__reactEvents$" + ws, kS = "__reactListeners$" + ws, RS = "__reactHandles$" + ws; function Yn(e) { var t = e[jt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[tn] || n[jt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Bf(e); e !== null;) { if (n = e[jt]) return n; e = Bf(e) } return t } e = n, n = e.parentNode } return null } function Fi(e) { return e = e[jt] || e[tn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function kr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(A(33)) } function Pa(e) { return e[mi] || null } var du = [], Rr = -1; function Un(e) { return { current: e } } function ee(e) { 0 > Rr || (e.current = du[Rr], du[Rr] = null, Rr--) } function q(e, t) { Rr++, du[Rr] = e.current, e.current = t } var In = {}, je = Un(In), Qe = Un(!1), cr = In; function os(e, t) { var n = e.type.contextTypes; if (!n) return In; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var s = {}, i; for (i in n) s[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function Ge(e) { return e = e.childContextTypes, e != null } function Ko() { ee(Qe), ee(je) } function $f(e, t, n) { if (je.current !== In) throw Error(A(168)); q(je, t), q(Qe, n) } function Ey(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var s in r) if (!(s in t)) throw Error(A(108, dx(e) || "Unknown", s)); return oe({}, n, r) } function Qo(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || In, cr = je.current, q(je, e), q(Qe, Qe.current), !0 } function Wf(e, t, n) { var r = e.stateNode; if (!r) throw Error(A(169)); n ? (e = Ey(e, t, cr), r.__reactInternalMemoizedMergedChildContext = e, ee(Qe), ee(je), q(je, e)) : ee(Qe), q(Qe, n) } var Ht = null, Ea = !1, dl = !1; function Ty(e) { Ht === null ? Ht = [e] : Ht.push(e) } function bS(e) { Ea = !0, Ty(e) } function Bn() { if (!dl && Ht !== null) { dl = !0; var e = 0, t = G; try { var n = Ht; for (G = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Ht = null, Ea = !1 } catch (s) { throw Ht !== null && (Ht = Ht.slice(e + 1)), Ym(Tc, Bn), s } finally { G = t, dl = !1 } } return null } var br = [], Ar = 0, Go = null, Xo = 0, ut = [], ct = 0, dr = null, Gt = 1, Xt = ""; function Kn(e, t) { br[Ar++] = Xo, br[Ar++] = Go, Go = e, Xo = t } function ky(e, t, n) { ut[ct++] = Gt, ut[ct++] = Xt, ut[ct++] = dr, dr = e; var r = Gt; e = Xt; var s = 32 - Et(r) - 1; r &= ~(1 << s), n += 1; var i = 32 - Et(t) + s; if (30 < i) { var o = s - s % 5; i = (r & (1 << o) - 1).toString(32), r >>= o, s -= o, Gt = 1 << 32 - Et(t) + s | n << s | r, Xt = i + e } else Gt = 1 << i | n << s | r, Xt = e } function jc(e) { e.return !== null && (Kn(e, 1), ky(e, 1, 0)) } function Oc(e) { for (; e === Go;)Go = br[--Ar], br[Ar] = null, Xo = br[--Ar], br[Ar] = null; for (; e === dr;)dr = ut[--ct], ut[ct] = null, Xt = ut[--ct], ut[ct] = null, Gt = ut[--ct], ut[ct] = null } var Ze = null, qe = null, ne = !1, Ct = null; function Ry(e, t) { var n = dt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Hf(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Ze = e, qe = Dn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Ze = e, qe = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = dr !== null ? { id: Gt, overflow: Xt } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = dt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Ze = e, qe = null, !0) : !1; default: return !1 } } function fu(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function hu(e) { if (ne) { var t = qe; if (t) { var n = t; if (!Hf(e, t)) { if (fu(e)) throw Error(A(418)); t = Dn(n.nextSibling); var r = Ze; t && Hf(e, t) ? Ry(r, n) : (e.flags = e.flags & -4097 | 2, ne = !1, Ze = e) } } else { if (fu(e)) throw Error(A(418)); e.flags = e.flags & -4097 | 2, ne = !1, Ze = e } } } function Kf(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Ze = e } function io(e) { if (e !== Ze) return !1; if (!ne) return Kf(e), ne = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !lu(e.type, e.memoizedProps)), t && (t = qe)) { if (fu(e)) throw by(), Error(A(418)); for (; t;)Ry(e, t), t = Dn(t.nextSibling) } if (Kf(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(A(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { qe = Dn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } qe = null } } else qe = Ze ? Dn(e.stateNode.nextSibling) : null; return !0 } function by() { for (var e = qe; e;)e = Dn(e.nextSibling) } function as() { qe = Ze = null, ne = !1 } function _c(e) { Ct === null ? Ct = [e] : Ct.push(e) } var AS = on.ReactCurrentBatchConfig; function Ds(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(A(309)); var r = n.stateNode } if (!r) throw Error(A(147, e)); var s = r, i = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function (o) { var a = s.refs; o === null ? delete a[i] : a[i] = o }, t._stringRef = i, t) } if (typeof e != "string") throw Error(A(284)); if (!n._owner) throw Error(A(290, e)) } return e } function oo(e, t) { throw e = Object.prototype.toString.call(t), Error(A(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Qf(e) { var t = e._init; return t(e._payload) } function Ay(e) { function t(p, h) { if (e) { var g = p.deletions; g === null ? (p.deletions = [h], p.flags |= 16) : g.push(h) } } function n(p, h) { if (!e) return null; for (; h !== null;)t(p, h), h = h.sibling; return null } function r(p, h) { for (p = new Map; h !== null;)h.key !== null ? p.set(h.key, h) : p.set(h.index, h), h = h.sibling; return p } function s(p, h) { return p = On(p, h), p.index = 0, p.sibling = null, p } function i(p, h, g) { return p.index = g, e ? (g = p.alternate, g !== null ? (g = g.index, g < h ? (p.flags |= 2, h) : g) : (p.flags |= 2, h)) : (p.flags |= 1048576, h) } function o(p) { return e && p.alternate === null && (p.flags |= 2), p } function a(p, h, g, P) { return h === null || h.tag !== 6 ? (h = vl(g, p.mode, P), h.return = p, h) : (h = s(h, g), h.return = p, h) } function l(p, h, g, P) { var E = g.type; return E === Cr ? c(p, h, g.props.children, P, g.key) : h !== null && (h.elementType === E || typeof E == "object" && E !== null && E.$$typeof === hn && Qf(E) === h.type) ? (P = s(h, g.props), P.ref = Ds(p, h, g), P.return = p, P) : (P = Mo(g.type, g.key, g.props, null, p.mode, P), P.ref = Ds(p, h, g), P.return = p, P) } function u(p, h, g, P) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== g.containerInfo || h.stateNode.implementation !== g.implementation ? (h = wl(g, p.mode, P), h.return = p, h) : (h = s(h, g.children || []), h.return = p, h) } function c(p, h, g, P, E) { return h === null || h.tag !== 7 ? (h = lr(g, p.mode, P, E), h.return = p, h) : (h = s(h, g), h.return = p, h) } function d(p, h, g) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = vl("" + h, p.mode, g), h.return = p, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case Xi: return g = Mo(h.type, h.key, h.props, null, p.mode, g), g.ref = Ds(p, null, h), g.return = p, g; case Sr: return h = wl(h, p.mode, g), h.return = p, h; case hn: var P = h._init; return d(p, P(h._payload), g) }if (Fs(h) || ks(h)) return h = lr(h, p.mode, g, null), h.return = p, h; oo(p, h) } return null } function f(p, h, g, P) { var E = h !== null ? h.key : null; if (typeof g == "string" && g !== "" || typeof g == "number") return E !== null ? null : a(p, h, "" + g, P); if (typeof g == "object" && g !== null) { switch (g.$$typeof) { case Xi: return g.key === E ? l(p, h, g, P) : null; case Sr: return g.key === E ? u(p, h, g, P) : null; case hn: return E = g._init, f(p, h, E(g._payload), P) }if (Fs(g) || ks(g)) return E !== null ? null : c(p, h, g, P, null); oo(p, g) } return null } function m(p, h, g, P, E) { if (typeof P == "string" && P !== "" || typeof P == "number") return p = p.get(g) || null, a(h, p, "" + P, E); if (typeof P == "object" && P !== null) { switch (P.$$typeof) { case Xi: return p = p.get(P.key === null ? g : P.key) || null, l(h, p, P, E); case Sr: return p = p.get(P.key === null ? g : P.key) || null, u(h, p, P, E); case hn: var R = P._init; return m(p, h, g, R(P._payload), E) }if (Fs(P) || ks(P)) return p = p.get(g) || null, c(h, p, P, E, null); oo(h, P) } return null } function x(p, h, g, P) { for (var E = null, R = null, k = h, T = h = 0, b = null; k !== null && T < g.length; T++) { k.index > T ? (b = k, k = null) : b = k.sibling; var M = f(p, k, g[T], P); if (M === null) { k === null && (k = b); break } e && k && M.alternate === null && t(p, k), h = i(M, h, T), R === null ? E = M : R.sibling = M, R = M, k = b } if (T === g.length) return n(p, k), ne && Kn(p, T), E; if (k === null) { for (; T < g.length; T++)k = d(p, g[T], P), k !== null && (h = i(k, h, T), R === null ? E = k : R.sibling = k, R = k); return ne && Kn(p, T), E } for (k = r(p, k); T < g.length; T++)b = m(k, p, T, g[T], P), b !== null && (e && b.alternate !== null && k.delete(b.key === null ? T : b.key), h = i(b, h, T), R === null ? E = b : R.sibling = b, R = b); return e && k.forEach(function (F) { return t(p, F) }), ne && Kn(p, T), E } function v(p, h, g, P) { var E = ks(g); if (typeof E != "function") throw Error(A(150)); if (g = E.call(g), g == null) throw Error(A(151)); for (var R = E = null, k = h, T = h = 0, b = null, M = g.next(); k !== null && !M.done; T++, M = g.next()) { k.index > T ? (b = k, k = null) : b = k.sibling; var F = f(p, k, M.value, P); if (F === null) { k === null && (k = b); break } e && k && F.alternate === null && t(p, k), h = i(F, h, T), R === null ? E = F : R.sibling = F, R = F, k = b } if (M.done) return n(p, k), ne && Kn(p, T), E; if (k === null) { for (; !M.done; T++, M = g.next())M = d(p, M.value, P), M !== null && (h = i(M, h, T), R === null ? E = M : R.sibling = M, R = M); return ne && Kn(p, T), E } for (k = r(p, k); !M.done; T++, M = g.next())M = m(k, p, T, M.value, P), M !== null && (e && M.alternate !== null && k.delete(M.key === null ? T : M.key), h = i(M, h, T), R === null ? E = M : R.sibling = M, R = M); return e && k.forEach(function (j) { return t(p, j) }), ne && Kn(p, T), E } function S(p, h, g, P) { if (typeof g == "object" && g !== null && g.type === Cr && g.key === null && (g = g.props.children), typeof g == "object" && g !== null) { switch (g.$$typeof) { case Xi: e: { for (var E = g.key, R = h; R !== null;) { if (R.key === E) { if (E = g.type, E === Cr) { if (R.tag === 7) { n(p, R.sibling), h = s(R, g.props.children), h.return = p, p = h; break e } } else if (R.elementType === E || typeof E == "object" && E !== null && E.$$typeof === hn && Qf(E) === R.type) { n(p, R.sibling), h = s(R, g.props), h.ref = Ds(p, R, g), h.return = p, p = h; break e } n(p, R); break } else t(p, R); R = R.sibling } g.type === Cr ? (h = lr(g.props.children, p.mode, P, g.key), h.return = p, p = h) : (P = Mo(g.type, g.key, g.props, null, p.mode, P), P.ref = Ds(p, h, g), P.return = p, p = P) } return o(p); case Sr: e: { for (R = g.key; h !== null;) { if (h.key === R) if (h.tag === 4 && h.stateNode.containerInfo === g.containerInfo && h.stateNode.implementation === g.implementation) { n(p, h.sibling), h = s(h, g.children || []), h.return = p, p = h; break e } else { n(p, h); break } else t(p, h); h = h.sibling } h = wl(g, p.mode, P), h.return = p, p = h } return o(p); case hn: return R = g._init, S(p, h, R(g._payload), P) }if (Fs(g)) return x(p, h, g, P); if (ks(g)) return v(p, h, g, P); oo(p, g) } return typeof g == "string" && g !== "" || typeof g == "number" ? (g = "" + g, h !== null && h.tag === 6 ? (n(p, h.sibling), h = s(h, g), h.return = p, p = h) : (n(p, h), h = vl(g, p.mode, P), h.return = p, p = h), o(p)) : n(p, h) } return S } var ls = Ay(!0), My = Ay(!1), Yo = Un(null), qo = null, Mr = null, Ic = null; function Fc() { Ic = Mr = qo = null } function Vc(e) { var t = Yo.current; ee(Yo), e._currentValue = t } function pu(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Br(e, t) { qo = e, Ic = Mr = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Ke = !0), e.firstContext = null) } function ht(e) { var t = e._currentValue; if (Ic !== e) if (e = { context: e, memoizedValue: t, next: null }, Mr === null) { if (qo === null) throw Error(A(308)); Mr = e, qo.dependencies = { lanes: 0, firstContext: e } } else Mr = Mr.next = e; return t } var qn = null; function zc(e) { qn === null ? qn = [e] : qn.push(e) } function Dy(e, t, n, r) { var s = t.interleaved; return s === null ? (n.next = n, zc(t)) : (n.next = s.next, s.next = n), t.interleaved = n, nn(e, r) } function nn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var pn = !1; function Uc(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Ny(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Yt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Nn(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, K & 2) { var s = r.pending; return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, nn(e, n) } return s = r.interleaved, s === null ? (t.next = t, zc(r)) : (t.next = s.next, s.next = t), r.interleaved = t, nn(e, n) } function Eo(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, kc(e, n) } } function Gf(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var s = null, i = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; i === null ? s = i = o : i = i.next = o, n = n.next } while (n !== null); i === null ? s = i = t : i = i.next = t } else s = i = t; n = { baseState: r.baseState, firstBaseUpdate: s, lastBaseUpdate: i, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Zo(e, t, n, r) { var s = e.updateQueue; pn = !1; var i = s.firstBaseUpdate, o = s.lastBaseUpdate, a = s.shared.pending; if (a !== null) { s.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? i = u : o.next = u, o = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (i !== null) { var d = s.baseState; o = 0, c = u = l = null, a = i; do { var f = a.lane, m = a.eventTime; if ((r & f) === f) { c !== null && (c = c.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var x = e, v = a; switch (f = t, m = n, v.tag) { case 1: if (x = v.payload, typeof x == "function") { d = x.call(m, d, f); break e } d = x; break e; case 3: x.flags = x.flags & -65537 | 128; case 0: if (x = v.payload, f = typeof x == "function" ? x.call(m, d, f) : x, f == null) break e; d = oe({}, d, f); break e; case 2: pn = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, f = s.effects, f === null ? s.effects = [a] : f.push(a)) } else m = { eventTime: m, lane: f, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = m, l = d) : c = c.next = m, o |= f; if (a = a.next, a === null) { if (a = s.shared.pending, a === null) break; f = a, a = f.next, f.next = null, s.lastBaseUpdate = f, s.shared.pending = null } } while (!0); if (c === null && (l = d), s.baseState = l, s.firstBaseUpdate = u, s.lastBaseUpdate = c, t = s.shared.interleaved, t !== null) { s = t; do o |= s.lane, s = s.next; while (s !== t) } else i === null && (s.shared.lanes = 0); hr |= o, e.lanes = o, e.memoizedState = d } } function Xf(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], s = r.callback; if (s !== null) { if (r.callback = null, r = n, typeof s != "function") throw Error(A(191, s)); s.call(r) } } } var Vi = {}, _t = Un(Vi), yi = Un(Vi), gi = Un(Vi); function Zn(e) { if (e === Vi) throw Error(A(174)); return e } function Bc(e, t) { switch (q(gi, t), q(yi, e), q(_t, Vi), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Gl(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Gl(t, e) }ee(_t), q(_t, t) } function us() { ee(_t), ee(yi), ee(gi) } function Ly(e) { Zn(gi.current); var t = Zn(_t.current), n = Gl(t, e.type); t !== n && (q(yi, e), q(_t, n)) } function $c(e) { yi.current === e && (ee(_t), ee(yi)) } var re = Un(0); function Jo(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var fl = []; function Wc() { for (var e = 0; e < fl.length; e++)fl[e]._workInProgressVersionPrimary = null; fl.length = 0 } var To = on.ReactCurrentDispatcher, hl = on.ReactCurrentBatchConfig, fr = 0, ie = null, me = null, xe = null, ea = !1, Ys = !1, vi = 0, MS = 0; function Re() { throw Error(A(321)) } function Hc(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!kt(e[n], t[n])) return !1; return !0 } function Kc(e, t, n, r, s, i) { if (fr = i, ie = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, To.current = e === null || e.memoizedState === null ? jS : OS, e = n(r, s), Ys) { i = 0; do { if (Ys = !1, vi = 0, 25 <= i) throw Error(A(301)); i += 1, xe = me = null, t.updateQueue = null, To.current = _S, e = n(r, s) } while (Ys) } if (To.current = ta, t = me !== null && me.next !== null, fr = 0, xe = me = ie = null, ea = !1, t) throw Error(A(300)); return e } function Qc() { var e = vi !== 0; return vi = 0, e } function At() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return xe === null ? ie.memoizedState = xe = e : xe = xe.next = e, xe } function pt() { if (me === null) { var e = ie.alternate; e = e !== null ? e.memoizedState : null } else e = me.next; var t = xe === null ? ie.memoizedState : xe.next; if (t !== null) xe = t, me = e; else { if (e === null) throw Error(A(310)); me = e, e = { memoizedState: me.memoizedState, baseState: me.baseState, baseQueue: me.baseQueue, queue: me.queue, next: null }, xe === null ? ie.memoizedState = xe = e : xe = xe.next = e } return xe } function wi(e, t) { return typeof t == "function" ? t(e) : t } function pl(e) { var t = pt(), n = t.queue; if (n === null) throw Error(A(311)); n.lastRenderedReducer = e; var r = me, s = r.baseQueue, i = n.pending; if (i !== null) { if (s !== null) { var o = s.next; s.next = i.next, i.next = o } r.baseQueue = s = i, n.pending = null } if (s !== null) { i = s.next, r = r.baseState; var a = o = null, l = null, u = i; do { var c = u.lane; if ((fr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = r) : l = l.next = d, ie.lanes |= c, hr |= c } u = u.next } while (u !== null && u !== i); l === null ? o = r : l.next = a, kt(r, t.memoizedState) || (Ke = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { s = e; do i = s.lane, ie.lanes |= i, hr |= i, s = s.next; while (s !== e) } else s === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function ml(e) { var t = pt(), n = t.queue; if (n === null) throw Error(A(311)); n.lastRenderedReducer = e; var r = n.dispatch, s = n.pending, i = t.memoizedState; if (s !== null) { n.pending = null; var o = s = s.next; do i = e(i, o.action), o = o.next; while (o !== s); kt(i, t.memoizedState) || (Ke = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i } return [i, r] } function jy() { } function Oy(e, t) { var n = ie, r = pt(), s = t(), i = !kt(r.memoizedState, s); if (i && (r.memoizedState = s, Ke = !0), r = r.queue, Gc(Fy.bind(null, n, r, e), [e]), r.getSnapshot !== t || i || xe !== null && xe.memoizedState.tag & 1) { if (n.flags |= 2048, xi(9, Iy.bind(null, n, r, s, t), void 0, null), Ce === null) throw Error(A(349)); fr & 30 || _y(n, t, s) } return s } function _y(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ie.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ie.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Iy(e, t, n, r) { t.value = n, t.getSnapshot = r, Vy(t) && zy(e) } function Fy(e, t, n) { return n(function () { Vy(t) && zy(e) }) } function Vy(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !kt(e, n) } catch { return !0 } } function zy(e) { var t = nn(e, 1); t !== null && Tt(t, e, 1, -1) } function Yf(e) { var t = At(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: wi, lastRenderedState: e }, t.queue = e, e = e.dispatch = LS.bind(null, ie, e), [t.memoizedState, e] } function xi(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ie.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ie.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Uy() { return pt().memoizedState } function ko(e, t, n, r) { var s = At(); ie.flags |= e, s.memoizedState = xi(1 | t, n, void 0, r === void 0 ? null : r) } function Ta(e, t, n, r) { var s = pt(); r = r === void 0 ? null : r; var i = void 0; if (me !== null) { var o = me.memoizedState; if (i = o.destroy, r !== null && Hc(r, o.deps)) { s.memoizedState = xi(t, n, i, r); return } } ie.flags |= e, s.memoizedState = xi(1 | t, n, i, r) } function qf(e, t) { return ko(8390656, 8, e, t) } function Gc(e, t) { return Ta(2048, 8, e, t) } function By(e, t) { return Ta(4, 2, e, t) } function $y(e, t) { return Ta(4, 4, e, t) } function Wy(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Hy(e, t, n) { return n = n != null ? n.concat([e]) : null, Ta(4, 4, Wy.bind(null, t, e), n) } function Xc() { } function Ky(e, t) { var n = pt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Hc(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Qy(e, t) { var n = pt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Hc(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Gy(e, t, n) { return fr & 21 ? (kt(n, t) || (n = Jm(), ie.lanes |= n, hr |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Ke = !0), e.memoizedState = n) } function DS(e, t) { var n = G; G = n !== 0 && 4 > n ? n : 4, e(!0); var r = hl.transition; hl.transition = {}; try { e(!1), t() } finally { G = n, hl.transition = r } } function Xy() { return pt().memoizedState } function NS(e, t, n) { var r = jn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Yy(e)) qy(t, n); else if (n = Dy(e, t, n, r), n !== null) { var s = Ve(); Tt(n, e, r, s), Zy(n, t, r) } } function LS(e, t, n) { var r = jn(e), s = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Yy(e)) qy(t, s); else { var i = e.alternate; if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try { var o = t.lastRenderedState, a = i(o, n); if (s.hasEagerState = !0, s.eagerState = a, kt(a, o)) { var l = t.interleaved; l === null ? (s.next = s, zc(t)) : (s.next = l.next, l.next = s), t.interleaved = s; return } } catch { } finally { } n = Dy(e, t, s, r), n !== null && (s = Ve(), Tt(n, e, r, s), Zy(n, t, r)) } } function Yy(e) { var t = e.alternate; return e === ie || t !== null && t === ie } function qy(e, t) { Ys = ea = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Zy(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, kc(e, n) } } var ta = { readContext: ht, useCallback: Re, useContext: Re, useEffect: Re, useImperativeHandle: Re, useInsertionEffect: Re, useLayoutEffect: Re, useMemo: Re, useReducer: Re, useRef: Re, useState: Re, useDebugValue: Re, useDeferredValue: Re, useTransition: Re, useMutableSource: Re, useSyncExternalStore: Re, useId: Re, unstable_isNewReconciler: !1 }, jS = { readContext: ht, useCallback: function (e, t) { return At().memoizedState = [e, t === void 0 ? null : t], e }, useContext: ht, useEffect: qf, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, ko(4194308, 4, Wy.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return ko(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return ko(4, 2, e, t) }, useMemo: function (e, t) { var n = At(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = At(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = NS.bind(null, ie, e), [r.memoizedState, e] }, useRef: function (e) { var t = At(); return e = { current: e }, t.memoizedState = e }, useState: Yf, useDebugValue: Xc, useDeferredValue: function (e) { return At().memoizedState = e }, useTransition: function () { var e = Yf(!1), t = e[0]; return e = DS.bind(null, e[1]), At().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ie, s = At(); if (ne) { if (n === void 0) throw Error(A(407)); n = n() } else { if (n = t(), Ce === null) throw Error(A(349)); fr & 30 || _y(r, t, n) } s.memoizedState = n; var i = { value: n, getSnapshot: t }; return s.queue = i, qf(Fy.bind(null, r, i, e), [e]), r.flags |= 2048, xi(9, Iy.bind(null, r, i, n, t), void 0, null), n }, useId: function () { var e = At(), t = Ce.identifierPrefix; if (ne) { var n = Xt, r = Gt; n = (r & ~(1 << 32 - Et(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = vi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = MS++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, OS = { readContext: ht, useCallback: Ky, useContext: ht, useEffect: Gc, useImperativeHandle: Hy, useInsertionEffect: By, useLayoutEffect: $y, useMemo: Qy, useReducer: pl, useRef: Uy, useState: function () { return pl(wi) }, useDebugValue: Xc, useDeferredValue: function (e) { var t = pt(); return Gy(t, me.memoizedState, e) }, useTransition: function () { var e = pl(wi)[0], t = pt().memoizedState; return [e, t] }, useMutableSource: jy, useSyncExternalStore: Oy, useId: Xy, unstable_isNewReconciler: !1 }, _S = { readContext: ht, useCallback: Ky, useContext: ht, useEffect: Gc, useImperativeHandle: Hy, useInsertionEffect: By, useLayoutEffect: $y, useMemo: Qy, useReducer: ml, useRef: Uy, useState: function () { return ml(wi) }, useDebugValue: Xc, useDeferredValue: function (e) { var t = pt(); return me === null ? t.memoizedState = e : Gy(t, me.memoizedState, e) }, useTransition: function () { var e = ml(wi)[0], t = pt().memoizedState; return [e, t] }, useMutableSource: jy, useSyncExternalStore: Oy, useId: Xy, unstable_isNewReconciler: !1 }; function vt(e, t) { if (e && e.defaultProps) { t = oe({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function mu(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : oe({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var ka = { isMounted: function (e) { return (e = e._reactInternals) ? vr(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Ve(), s = jn(e), i = Yt(r, s); i.payload = t, n != null && (i.callback = n), t = Nn(e, i, s), t !== null && (Tt(t, e, s, r), Eo(t, e, s)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Ve(), s = jn(e), i = Yt(r, s); i.tag = 1, i.payload = t, n != null && (i.callback = n), t = Nn(e, i, s), t !== null && (Tt(t, e, s, r), Eo(t, e, s)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Ve(), r = jn(e), s = Yt(n, r); s.tag = 2, t != null && (s.callback = t), t = Nn(e, s, r), t !== null && (Tt(t, e, r, n), Eo(t, e, r)) } }; function Zf(e, t, n, r, s, i, o) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !fi(n, r) || !fi(s, i) : !0 } function Jy(e, t, n) { var r = !1, s = In, i = t.contextType; return typeof i == "object" && i !== null ? i = ht(i) : (s = Ge(t) ? cr : je.current, r = t.contextTypes, i = (r = r != null) ? os(e, s) : In), t = new t(n, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = ka, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = i), t } function Jf(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && ka.enqueueReplaceState(t, t.state, null) } function yu(e, t, n, r) { var s = e.stateNode; s.props = n, s.state = e.memoizedState, s.refs = {}, Uc(e); var i = t.contextType; typeof i == "object" && i !== null ? s.context = ht(i) : (i = Ge(t) ? cr : je.current, s.context = os(e, i)), s.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (mu(e, t, i, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && ka.enqueueReplaceState(s, s.state, null), Zo(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308) } function cs(e, t) {
  try { var n = "", r = t; do n += cx(r), r = r.return; while (r); var s = n } catch (i) {
    s = `
Error generating stack: `+ i.message + `
`+ i.stack
  } return { value: e, source: t, stack: s, digest: null }
} function yl(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function gu(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var IS = typeof WeakMap == "function" ? WeakMap : Map; function eg(e, t, n) { n = Yt(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { ra || (ra = !0, Ru = r), gu(e, t) }, n } function tg(e, t, n) { n = Yt(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var s = t.value; n.payload = function () { return r(s) }, n.callback = function () { gu(e, t) } } var i = e.stateNode; return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function () { gu(e, t), typeof r != "function" && (Ln === null ? Ln = new Set([this]) : Ln.add(this)); var o = t.stack; this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" }) }), n } function eh(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new IS; var s = new Set; r.set(t, s) } else s = r.get(t), s === void 0 && (s = new Set, r.set(t, s)); s.has(n) || (s.add(n), e = qS.bind(null, e, t, n), t.then(e, e)) } function th(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function nh(e, t, n, r, s) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Yt(-1, 1), t.tag = 2, Nn(n, t, 1))), n.lanes |= 1), e) } var FS = on.ReactCurrentOwner, Ke = !1; function Fe(e, t, n, r) { t.child = e === null ? My(t, null, n, r) : ls(t, e.child, n, r) } function rh(e, t, n, r, s) { n = n.render; var i = t.ref; return Br(t, s), r = Kc(e, t, n, r, i, s), n = Qc(), e !== null && !Ke ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, rn(e, t, s)) : (ne && n && jc(t), t.flags |= 1, Fe(e, t, r, s), t.child) } function sh(e, t, n, r, s) { if (e === null) { var i = n.type; return typeof i == "function" && !rd(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = i, ng(e, t, i, r, s)) : (e = Mo(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e) } if (i = e.child, !(e.lanes & s)) { var o = i.memoizedProps; if (n = n.compare, n = n !== null ? n : fi, n(o, r) && e.ref === t.ref) return rn(e, t, s) } return t.flags |= 1, e = On(i, r), e.ref = t.ref, e.return = t, t.child = e } function ng(e, t, n, r, s) { if (e !== null) { var i = e.memoizedProps; if (fi(i, r) && e.ref === t.ref) if (Ke = !1, t.pendingProps = r = i, (e.lanes & s) !== 0) e.flags & 131072 && (Ke = !0); else return t.lanes = e.lanes, rn(e, t, s) } return vu(e, t, n, r, s) } function rg(e, t, n) { var r = t.pendingProps, s = r.children, i = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, q(Nr, Ye), Ye |= n; else { if (!(n & 1073741824)) return e = i !== null ? i.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, q(Nr, Ye), Ye |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = i !== null ? i.baseLanes : n, q(Nr, Ye), Ye |= r } else i !== null ? (r = i.baseLanes | n, t.memoizedState = null) : r = n, q(Nr, Ye), Ye |= r; return Fe(e, t, s, n), t.child } function sg(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function vu(e, t, n, r, s) { var i = Ge(n) ? cr : je.current; return i = os(t, i), Br(t, s), n = Kc(e, t, n, r, i, s), r = Qc(), e !== null && !Ke ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, rn(e, t, s)) : (ne && r && jc(t), t.flags |= 1, Fe(e, t, n, s), t.child) } function ih(e, t, n, r, s) { if (Ge(n)) { var i = !0; Qo(t) } else i = !1; if (Br(t, s), t.stateNode === null) Ro(e, t), Jy(t, n, r), yu(t, n, r, s), r = !0; else if (e === null) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, u = n.contextType; typeof u == "object" && u !== null ? u = ht(u) : (u = Ge(n) ? cr : je.current, u = os(t, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && Jf(t, o, r, u), pn = !1; var f = t.memoizedState; o.state = f, Zo(t, r, o, s), l = t.memoizedState, a !== r || f !== l || Qe.current || pn ? (typeof c == "function" && (mu(t, n, c, r), l = t.memoizedState), (a = pn || Zf(t, n, a, r, f, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, Ny(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : vt(t.type, a), o.props = u, d = t.pendingProps, f = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = ht(l) : (l = Ge(n) ? cr : je.current, l = os(t, l)); var m = n.getDerivedStateFromProps; (c = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || f !== l) && Jf(t, o, r, l), pn = !1, f = t.memoizedState, o.state = f, Zo(t, r, o, s); var x = t.memoizedState; a !== d || f !== x || Qe.current || pn ? (typeof m == "function" && (mu(t, n, m, r), x = t.memoizedState), (u = pn || Zf(t, n, u, r, f, x, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, x, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, x, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = x), o.props = r, o.state = x, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = !1) } return wu(e, t, n, r, i, s) } function wu(e, t, n, r, s, i) { sg(e, t); var o = (t.flags & 128) !== 0; if (!r && !o) return s && Wf(t, n, !1), rn(e, t, i); r = t.stateNode, FS.current = t; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && o ? (t.child = ls(t, e.child, null, i), t.child = ls(t, null, a, i)) : Fe(e, t, a, i), t.memoizedState = r.state, s && Wf(t, n, !0), t.child } function ig(e) { var t = e.stateNode; t.pendingContext ? $f(e, t.pendingContext, t.pendingContext !== t.context) : t.context && $f(e, t.context, !1), Bc(e, t.containerInfo) } function oh(e, t, n, r, s) { return as(), _c(s), t.flags |= 256, Fe(e, t, n, r), t.child } var xu = { dehydrated: null, treeContext: null, retryLane: 0 }; function Su(e) { return { baseLanes: e, cachePool: null, transitions: null } } function og(e, t, n) { var r = t.pendingProps, s = re.current, i = !1, o = (t.flags & 128) !== 0, a; if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0), a ? (i = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), q(re, s & 1), e === null) return hu(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, i ? (r = t.mode, i = t.child, o = { mode: "hidden", children: o }, !(r & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = o) : i = Aa(o, r, 0, null), e = lr(e, r, n, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = Su(n), t.memoizedState = xu, e) : Yc(t, o)); if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return VS(e, t, o, r, a, s, n); if (i) { i = r.fallback, o = t.mode, s = e.child, a = s.sibling; var l = { mode: "hidden", children: r.children }; return !(o & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = On(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? i = On(a, i) : (i = lr(i, o, n, null), i.flags |= 2), i.return = t, r.return = t, r.sibling = i, t.child = r, r = i, i = t.child, o = e.child.memoizedState, o = o === null ? Su(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, i.memoizedState = o, i.childLanes = e.childLanes & ~n, t.memoizedState = xu, r } return i = e.child, e = i.sibling, r = On(i, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Yc(e, t) { return t = Aa({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function ao(e, t, n, r) { return r !== null && _c(r), ls(t, e.child, null, n), e = Yc(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function VS(e, t, n, r, s, i, o) { if (n) return t.flags & 256 ? (t.flags &= -257, r = yl(Error(A(422))), ao(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = r.fallback, s = t.mode, r = Aa({ mode: "visible", children: r.children }, s, 0, null), i = lr(i, s, o, null), i.flags |= 2, r.return = t, i.return = t, r.sibling = i, t.child = r, t.mode & 1 && ls(t, e.child, null, o), t.child.memoizedState = Su(o), t.memoizedState = xu, i); if (!(t.mode & 1)) return ao(e, t, o, null); if (s.data === "$!") { if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst; return r = a, i = Error(A(419)), r = yl(i, r, void 0), ao(e, t, o, r) } if (a = (o & e.childLanes) !== 0, Ke || a) { if (r = Ce, r !== null) { switch (o & -o) { case 4: s = 2; break; case 16: s = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: s = 32; break; case 536870912: s = 268435456; break; default: s = 0 }s = s & (r.suspendedLanes | o) ? 0 : s, s !== 0 && s !== i.retryLane && (i.retryLane = s, nn(e, s), Tt(r, e, s, -1)) } return nd(), r = yl(Error(A(421))), ao(e, t, o, r) } return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = ZS.bind(null, e), s._reactRetry = t, null) : (e = i.treeContext, qe = Dn(s.nextSibling), Ze = t, ne = !0, Ct = null, e !== null && (ut[ct++] = Gt, ut[ct++] = Xt, ut[ct++] = dr, Gt = e.id, Xt = e.overflow, dr = t), t = Yc(t, r.children), t.flags |= 4096, t) } function ah(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), pu(e.return, t, n) } function gl(e, t, n, r, s) { var i = e.memoizedState; i === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: s } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = n, i.tailMode = s) } function ag(e, t, n) { var r = t.pendingProps, s = r.revealOrder, i = r.tail; if (Fe(e, t, r.children, n), r = re.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && ah(e, n, t); else if (e.tag === 19) ah(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (q(re, r), !(t.mode & 1)) t.memoizedState = null; else switch (s) { case "forwards": for (n = t.child, s = null; n !== null;)e = n.alternate, e !== null && Jo(e) === null && (s = n), n = n.sibling; n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), gl(t, !1, s, n, i); break; case "backwards": for (n = null, s = t.child, t.child = null; s !== null;) { if (e = s.alternate, e !== null && Jo(e) === null) { t.child = s; break } e = s.sibling, s.sibling = n, n = s, s = e } gl(t, !0, n, null, i); break; case "together": gl(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Ro(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function rn(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), hr |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(A(153)); if (t.child !== null) { for (e = t.child, n = On(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = On(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function zS(e, t, n) { switch (t.tag) { case 3: ig(t), as(); break; case 5: Ly(t); break; case 1: Ge(t.type) && Qo(t); break; case 4: Bc(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, s = t.memoizedProps.value; q(Yo, r._currentValue), r._currentValue = s; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (q(re, re.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? og(e, t, n) : (q(re, re.current & 1), e = rn(e, t, n), e !== null ? e.sibling : null); q(re, re.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return ag(e, t, n); t.flags |= 128 } if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), q(re, re.current), r) break; return null; case 22: case 23: return t.lanes = 0, rg(e, t, n) }return rn(e, t, n) } var lg, Cu, ug, cg; lg = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Cu = function () { }; ug = function (e, t, n, r) { var s = e.memoizedProps; if (s !== r) { e = t.stateNode, Zn(_t.current); var i = null; switch (n) { case "input": s = Wl(e, s), r = Wl(e, r), i = []; break; case "select": s = oe({}, s, { value: void 0 }), r = oe({}, r, { value: void 0 }), i = []; break; case "textarea": s = Ql(e, s), r = Ql(e, r), i = []; break; default: typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Ho) }Xl(n, r); var o; n = null; for (u in s) if (!r.hasOwnProperty(u) && s.hasOwnProperty(u) && s[u] != null) if (u === "style") { var a = s[u]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (ii.hasOwnProperty(u) ? i || (i = []) : (i = i || []).push(u, null)); for (u in r) { var l = r[u]; if (a = s != null ? s[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (i || (i = []), i.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (ii.hasOwnProperty(u) ? (l != null && u === "onScroll" && J("scroll", e), i || a === l || (i = [])) : (i = i || []).push(u, l)) } n && (i = i || []).push("style", n); var u = i; (t.updateQueue = u) && (t.flags |= 4) } }; cg = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Ns(e, t) { if (!ne) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function be(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling; else for (s = e.child; s !== null;)n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function US(e, t, n) { var r = t.pendingProps; switch (Oc(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return be(t), null; case 1: return Ge(t.type) && Ko(), be(t), null; case 3: return r = t.stateNode, us(), ee(Qe), ee(je), Wc(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (io(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ct !== null && (Mu(Ct), Ct = null))), Cu(e, t), be(t), null; case 5: $c(t); var s = Zn(gi.current); if (n = t.type, e !== null && t.stateNode != null) ug(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(A(166)); return be(t), null } if (e = Zn(_t.current), io(t)) { r = t.stateNode, n = t.type; var i = t.memoizedProps; switch (r[jt] = t, r[mi] = i, e = (t.mode & 1) !== 0, n) { case "dialog": J("cancel", r), J("close", r); break; case "iframe": case "object": case "embed": J("load", r); break; case "video": case "audio": for (s = 0; s < zs.length; s++)J(zs[s], r); break; case "source": J("error", r); break; case "img": case "image": case "link": J("error", r), J("load", r); break; case "details": J("toggle", r); break; case "input": yf(r, i), J("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!i.multiple }, J("invalid", r); break; case "textarea": vf(r, i), J("invalid", r) }Xl(n, i), s = null; for (var o in i) if (i.hasOwnProperty(o)) { var a = i[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (i.suppressHydrationWarning !== !0 && so(r.textContent, a, e), s = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && so(r.textContent, a, e), s = ["children", "" + a]) : ii.hasOwnProperty(o) && a != null && o === "onScroll" && J("scroll", r) } switch (n) { case "input": Yi(r), gf(r, i, !0); break; case "textarea": Yi(r), wf(r); break; case "select": case "option": break; default: typeof i.onClick == "function" && (r.onclick = Ho) }r = s, t.updateQueue = r, r !== null && (t.flags |= 4) } else { o = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Fm(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, { is: r.is }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[jt] = t, e[mi] = r, lg(e, t, !1, !1), t.stateNode = e; e: { switch (o = Yl(n, r), n) { case "dialog": J("cancel", e), J("close", e), s = r; break; case "iframe": case "object": case "embed": J("load", e), s = r; break; case "video": case "audio": for (s = 0; s < zs.length; s++)J(zs[s], e); s = r; break; case "source": J("error", e), s = r; break; case "img": case "image": case "link": J("error", e), J("load", e), s = r; break; case "details": J("toggle", e), s = r; break; case "input": yf(e, r), s = Wl(e, r), J("invalid", e); break; case "option": s = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, s = oe({}, r, { value: void 0 }), J("invalid", e); break; case "textarea": vf(e, r), s = Ql(e, r), J("invalid", e); break; default: s = r }Xl(n, s), a = s; for (i in a) if (a.hasOwnProperty(i)) { var l = a[i]; i === "style" ? Um(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Vm(e, l)) : i === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && oi(e, l) : typeof l == "number" && oi(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (ii.hasOwnProperty(i) ? l != null && i === "onScroll" && J("scroll", e) : l != null && xc(e, i, l, o)) } switch (n) { case "input": Yi(e), gf(e, r, !1); break; case "textarea": Yi(e), wf(e); break; case "option": r.value != null && e.setAttribute("value", "" + _n(r.value)); break; case "select": e.multiple = !!r.multiple, i = r.value, i != null ? Fr(e, !!r.multiple, i, !1) : r.defaultValue != null && Fr(e, !!r.multiple, r.defaultValue, !0); break; default: typeof s.onClick == "function" && (e.onclick = Ho) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return be(t), null; case 6: if (e && t.stateNode != null) cg(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(A(166)); if (n = Zn(gi.current), Zn(_t.current), io(t)) { if (r = t.stateNode, n = t.memoizedProps, r[jt] = t, (i = r.nodeValue !== n) && (e = Ze, e !== null)) switch (e.tag) { case 3: so(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && so(r.nodeValue, n, (e.mode & 1) !== 0) }i && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[jt] = t, t.stateNode = r } return be(t), null; case 13: if (ee(re), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (ne && qe !== null && t.mode & 1 && !(t.flags & 128)) by(), as(), t.flags |= 98560, i = !1; else if (i = io(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!i) throw Error(A(318)); if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(A(317)); i[jt] = t } else as(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; be(t), i = !1 } else Ct !== null && (Mu(Ct), Ct = null), i = !0; if (!i) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || re.current & 1 ? ge === 0 && (ge = 3) : nd())), t.updateQueue !== null && (t.flags |= 4), be(t), null); case 4: return us(), Cu(e, t), e === null && hi(t.stateNode.containerInfo), be(t), null; case 10: return Vc(t.type._context), be(t), null; case 17: return Ge(t.type) && Ko(), be(t), null; case 19: if (ee(re), i = t.memoizedState, i === null) return be(t), null; if (r = (t.flags & 128) !== 0, o = i.rendering, o === null) if (r) Ns(i, !1); else { if (ge !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (o = Jo(e), o !== null) { for (t.flags |= 128, Ns(i, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)i = n, e = r, i.flags &= 14680066, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return q(re, re.current & 1 | 2), t.child } e = e.sibling } i.tail !== null && fe() > ds && (t.flags |= 128, r = !0, Ns(i, !1), t.lanes = 4194304) } else { if (!r) if (e = Jo(o), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Ns(i, !0), i.tail === null && i.tailMode === "hidden" && !o.alternate && !ne) return be(t), null } else 2 * fe() - i.renderingStartTime > ds && n !== 1073741824 && (t.flags |= 128, r = !0, Ns(i, !1), t.lanes = 4194304); i.isBackwards ? (o.sibling = t.child, t.child = o) : (n = i.last, n !== null ? n.sibling = o : t.child = o, i.last = o) } return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = fe(), t.sibling = null, n = re.current, q(re, r ? n & 1 | 2 : n & 1), t) : (be(t), null); case 22: case 23: return td(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Ye & 1073741824 && (be(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : be(t), null; case 24: return null; case 25: return null }throw Error(A(156, t.tag)) } function BS(e, t) { switch (Oc(t), t.tag) { case 1: return Ge(t.type) && Ko(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return us(), ee(Qe), ee(je), Wc(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return $c(t), null; case 13: if (ee(re), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(A(340)); as() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ee(re), null; case 4: return us(), null; case 10: return Vc(t.type._context), null; case 22: case 23: return td(), null; case 24: return null; default: return null } } var lo = !1, De = !1, $S = typeof WeakSet == "function" ? WeakSet : Set, L = null; function Dr(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { ce(e, t, r) } else n.current = null } function Pu(e, t, n) { try { n() } catch (r) { ce(e, t, r) } } var lh = !1; function WS(e, t) { if (ou = Bo, e = my(), Lc(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var s = r.anchorOffset, i = r.focusNode; r = r.focusOffset; try { n.nodeType, i.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, u = 0, c = 0, d = e, f = null; t: for (; ;) { for (var m; d !== n || s !== 0 && d.nodeType !== 3 || (a = o + s), d !== i || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (m = d.firstChild) !== null;)f = d, d = m; for (; ;) { if (d === e) break t; if (f === n && ++u === s && (a = o), f === i && ++c === r && (l = o), (m = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = m } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (au = { focusedElem: e, selectionRange: n }, Bo = !1, L = t; L !== null;)if (t = L, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, L = e; else for (; L !== null;) { t = L; try { var x = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (x !== null) { var v = x.memoizedProps, S = x.memoizedState, p = t.stateNode, h = p.getSnapshotBeforeUpdate(t.elementType === t.type ? v : vt(t.type, v), S); p.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var g = t.stateNode.containerInfo; g.nodeType === 1 ? g.textContent = "" : g.nodeType === 9 && g.documentElement && g.removeChild(g.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(A(163)) } } catch (P) { ce(t, t.return, P) } if (e = t.sibling, e !== null) { e.return = t.return, L = e; break } L = t.return } return x = lh, lh = !1, x } function qs(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var s = r = r.next; do { if ((s.tag & e) === e) { var i = s.destroy; s.destroy = void 0, i !== void 0 && Pu(t, n, i) } s = s.next } while (s !== r) } } function Ra(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function Eu(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function dg(e) { var t = e.alternate; t !== null && (e.alternate = null, dg(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[jt], delete t[mi], delete t[cu], delete t[kS], delete t[RS])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function fg(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function uh(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || fg(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Tu(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Ho)); else if (r !== 4 && (e = e.child, e !== null)) for (Tu(e, t, n), e = e.sibling; e !== null;)Tu(e, t, n), e = e.sibling } function ku(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (ku(e, t, n), e = e.sibling; e !== null;)ku(e, t, n), e = e.sibling } var Pe = null, St = !1; function an(e, t, n) { for (n = n.child; n !== null;)hg(e, t, n), n = n.sibling } function hg(e, t, n) { if (Ot && typeof Ot.onCommitFiberUnmount == "function") try { Ot.onCommitFiberUnmount(wa, n) } catch { } switch (n.tag) { case 5: De || Dr(n, t); case 6: var r = Pe, s = St; Pe = null, an(e, t, n), Pe = r, St = s, Pe !== null && (St ? (e = Pe, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Pe.removeChild(n.stateNode)); break; case 18: Pe !== null && (St ? (e = Pe, n = n.stateNode, e.nodeType === 8 ? cl(e.parentNode, n) : e.nodeType === 1 && cl(e, n), ci(e)) : cl(Pe, n.stateNode)); break; case 4: r = Pe, s = St, Pe = n.stateNode.containerInfo, St = !0, an(e, t, n), Pe = r, St = s; break; case 0: case 11: case 14: case 15: if (!De && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { s = r = r.next; do { var i = s, o = i.destroy; i = i.tag, o !== void 0 && (i & 2 || i & 4) && Pu(n, t, o), s = s.next } while (s !== r) } an(e, t, n); break; case 1: if (!De && (Dr(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { ce(n, t, a) } an(e, t, n); break; case 21: an(e, t, n); break; case 22: n.mode & 1 ? (De = (r = De) || n.memoizedState !== null, an(e, t, n), De = r) : an(e, t, n); break; default: an(e, t, n) } } function ch(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new $S), t.forEach(function (r) { var s = JS.bind(null, e, r); n.has(r) || (n.add(r), r.then(s, s)) }) } } function yt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var s = n[r]; try { var i = e, o = t, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Pe = a.stateNode, St = !1; break e; case 3: Pe = a.stateNode.containerInfo, St = !0; break e; case 4: Pe = a.stateNode.containerInfo, St = !0; break e }a = a.return } if (Pe === null) throw Error(A(160)); hg(i, o, s), Pe = null, St = !1; var l = s.alternate; l !== null && (l.return = null), s.return = null } catch (u) { ce(s, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)pg(t, e), t = t.sibling } function pg(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (yt(t, e), bt(e), r & 4) { try { qs(3, e, e.return), Ra(3, e) } catch (v) { ce(e, e.return, v) } try { qs(5, e, e.return) } catch (v) { ce(e, e.return, v) } } break; case 1: yt(t, e), bt(e), r & 512 && n !== null && Dr(n, n.return); break; case 5: if (yt(t, e), bt(e), r & 512 && n !== null && Dr(n, n.return), e.flags & 32) { var s = e.stateNode; try { oi(s, "") } catch (v) { ce(e, e.return, v) } } if (r & 4 && (s = e.stateNode, s != null)) { var i = e.memoizedProps, o = n !== null ? n.memoizedProps : i, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && i.type === "radio" && i.name != null && _m(s, i), Yl(a, o); var u = Yl(a, i); for (o = 0; o < l.length; o += 2) { var c = l[o], d = l[o + 1]; c === "style" ? Um(s, d) : c === "dangerouslySetInnerHTML" ? Vm(s, d) : c === "children" ? oi(s, d) : xc(s, c, d, u) } switch (a) { case "input": Hl(s, i); break; case "textarea": Im(s, i); break; case "select": var f = s._wrapperState.wasMultiple; s._wrapperState.wasMultiple = !!i.multiple; var m = i.value; m != null ? Fr(s, !!i.multiple, m, !1) : f !== !!i.multiple && (i.defaultValue != null ? Fr(s, !!i.multiple, i.defaultValue, !0) : Fr(s, !!i.multiple, i.multiple ? [] : "", !1)) }s[mi] = i } catch (v) { ce(e, e.return, v) } } break; case 6: if (yt(t, e), bt(e), r & 4) { if (e.stateNode === null) throw Error(A(162)); s = e.stateNode, i = e.memoizedProps; try { s.nodeValue = i } catch (v) { ce(e, e.return, v) } } break; case 3: if (yt(t, e), bt(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { ci(t.containerInfo) } catch (v) { ce(e, e.return, v) } break; case 4: yt(t, e), bt(e); break; case 13: yt(t, e), bt(e), s = e.child, s.flags & 8192 && (i = s.memoizedState !== null, s.stateNode.isHidden = i, !i || s.alternate !== null && s.alternate.memoizedState !== null || (Jc = fe())), r & 4 && ch(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (De = (u = De) || c, yt(t, e), De = u) : yt(t, e), bt(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (L = e, c = e.child; c !== null;) { for (d = L = c; L !== null;) { switch (f = L, m = f.child, f.tag) { case 0: case 11: case 14: case 15: qs(4, f, f.return); break; case 1: Dr(f, f.return); var x = f.stateNode; if (typeof x.componentWillUnmount == "function") { r = f, n = f.return; try { t = r, x.props = t.memoizedProps, x.state = t.memoizedState, x.componentWillUnmount() } catch (v) { ce(r, n, v) } } break; case 5: Dr(f, f.return); break; case 22: if (f.memoizedState !== null) { fh(d); continue } }m !== null ? (m.return = f, L = m) : fh(d) } c = c.sibling } e: for (c = null, d = e; ;) { if (d.tag === 5) { if (c === null) { c = d; try { s = d.stateNode, u ? (i = s.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = zm("display", o)) } catch (v) { ce(e, e.return, v) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (v) { ce(e, e.return, v) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; d.sibling === null;) { if (d.return === null || d.return === e) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: yt(t, e), bt(e), r & 4 && ch(e); break; case 21: break; default: yt(t, e), bt(e) } } function bt(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (fg(n)) { var r = n; break e } n = n.return } throw Error(A(160)) } switch (r.tag) { case 5: var s = r.stateNode; r.flags & 32 && (oi(s, ""), r.flags &= -33); var i = uh(e); ku(e, i, s); break; case 3: case 4: var o = r.stateNode.containerInfo, a = uh(e); Tu(e, a, o); break; default: throw Error(A(161)) } } catch (l) { ce(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function HS(e, t, n) { L = e, mg(e) } function mg(e, t, n) { for (var r = (e.mode & 1) !== 0; L !== null;) { var s = L, i = s.child; if (s.tag === 22 && r) { var o = s.memoizedState !== null || lo; if (!o) { var a = s.alternate, l = a !== null && a.memoizedState !== null || De; a = lo; var u = De; if (lo = o, (De = l) && !u) for (L = s; L !== null;)o = L, l = o.child, o.tag === 22 && o.memoizedState !== null ? hh(s) : l !== null ? (l.return = o, L = l) : hh(s); for (; i !== null;)L = i, mg(i), i = i.sibling; L = s, lo = a, De = u } dh(e) } else s.subtreeFlags & 8772 && i !== null ? (i.return = s, L = i) : dh(e) } } function dh(e) { for (; L !== null;) { var t = L; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: De || Ra(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !De) if (n === null) r.componentDidMount(); else { var s = t.elementType === t.type ? n.memoizedProps : vt(t.type, n.memoizedProps); r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var i = t.updateQueue; i !== null && Xf(t, i, r); break; case 3: var o = t.updateQueue; if (o !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }Xf(t, o, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && ci(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(A(163)) }De || t.flags & 512 && Eu(t) } catch (f) { ce(t, t.return, f) } } if (t === e) { L = null; break } if (n = t.sibling, n !== null) { n.return = t.return, L = n; break } L = t.return } } function fh(e) { for (; L !== null;) { var t = L; if (t === e) { L = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, L = n; break } L = t.return } } function hh(e) { for (; L !== null;) { var t = L; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Ra(4, t) } catch (l) { ce(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var s = t.return; try { r.componentDidMount() } catch (l) { ce(t, s, l) } } var i = t.return; try { Eu(t) } catch (l) { ce(t, i, l) } break; case 5: var o = t.return; try { Eu(t) } catch (l) { ce(t, o, l) } } } catch (l) { ce(t, t.return, l) } if (t === e) { L = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, L = a; break } L = t.return } } var KS = Math.ceil, na = on.ReactCurrentDispatcher, qc = on.ReactCurrentOwner, ft = on.ReactCurrentBatchConfig, K = 0, Ce = null, he = null, Te = 0, Ye = 0, Nr = Un(0), ge = 0, Si = null, hr = 0, ba = 0, Zc = 0, Zs = null, He = null, Jc = 0, ds = 1 / 0, Wt = null, ra = !1, Ru = null, Ln = null, uo = !1, Rn = null, sa = 0, Js = 0, bu = null, bo = -1, Ao = 0; function Ve() { return K & 6 ? fe() : bo !== -1 ? bo : bo = fe() } function jn(e) { return e.mode & 1 ? K & 2 && Te !== 0 ? Te & -Te : AS.transition !== null ? (Ao === 0 && (Ao = Jm()), Ao) : (e = G, e !== 0 || (e = window.event, e = e === void 0 ? 16 : oy(e.type)), e) : 1 } function Tt(e, t, n, r) { if (50 < Js) throw Js = 0, bu = null, Error(A(185)); _i(e, n, r), (!(K & 2) || e !== Ce) && (e === Ce && (!(K & 2) && (ba |= n), ge === 4 && yn(e, Te)), Xe(e, r), n === 1 && K === 0 && !(t.mode & 1) && (ds = fe() + 500, Ea && Bn())) } function Xe(e, t) { var n = e.callbackNode; Ax(e, t); var r = Uo(e, e === Ce ? Te : 0); if (r === 0) n !== null && Cf(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Cf(n), t === 1) e.tag === 0 ? bS(ph.bind(null, e)) : Ty(ph.bind(null, e)), ES(function () { !(K & 6) && Bn() }), n = null; else { switch (ey(r)) { case 1: n = Tc; break; case 4: n = qm; break; case 16: n = zo; break; case 536870912: n = Zm; break; default: n = zo }n = Pg(n, yg.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function yg(e, t) { if (bo = -1, Ao = 0, K & 6) throw Error(A(327)); var n = e.callbackNode; if ($r() && e.callbackNode !== n) return null; var r = Uo(e, e === Ce ? Te : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = ia(e, r); else { t = r; var s = K; K |= 2; var i = vg(); (Ce !== e || Te !== t) && (Wt = null, ds = fe() + 500, ar(e, t)); do try { XS(); break } catch (a) { gg(e, a) } while (!0); Fc(), na.current = i, K = s, he !== null ? t = 0 : (Ce = null, Te = 0, t = ge) } if (t !== 0) { if (t === 2 && (s = tu(e), s !== 0 && (r = s, t = Au(e, s))), t === 1) throw n = Si, ar(e, 0), yn(e, r), Xe(e, fe()), n; if (t === 6) yn(e, r); else { if (s = e.current.alternate, !(r & 30) && !QS(s) && (t = ia(e, r), t === 2 && (i = tu(e), i !== 0 && (r = i, t = Au(e, i))), t === 1)) throw n = Si, ar(e, 0), yn(e, r), Xe(e, fe()), n; switch (e.finishedWork = s, e.finishedLanes = r, t) { case 0: case 1: throw Error(A(345)); case 2: Qn(e, He, Wt); break; case 3: if (yn(e, r), (r & 130023424) === r && (t = Jc + 500 - fe(), 10 < t)) { if (Uo(e, 0) !== 0) break; if (s = e.suspendedLanes, (s & r) !== r) { Ve(), e.pingedLanes |= e.suspendedLanes & s; break } e.timeoutHandle = uu(Qn.bind(null, e, He, Wt), t); break } Qn(e, He, Wt); break; case 4: if (yn(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, s = -1; 0 < r;) { var o = 31 - Et(r); i = 1 << o, o = t[o], o > s && (s = o), r &= ~i } if (r = s, r = fe() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * KS(r / 1960)) - r, 10 < r) { e.timeoutHandle = uu(Qn.bind(null, e, He, Wt), r); break } Qn(e, He, Wt); break; case 5: Qn(e, He, Wt); break; default: throw Error(A(329)) } } } return Xe(e, fe()), e.callbackNode === n ? yg.bind(null, e) : null } function Au(e, t) { var n = Zs; return e.current.memoizedState.isDehydrated && (ar(e, t).flags |= 256), e = ia(e, t), e !== 2 && (t = He, He = n, t !== null && Mu(t)), e } function Mu(e) { He === null ? He = e : He.push.apply(He, e) } function QS(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var s = n[r], i = s.getSnapshot; s = s.value; try { if (!kt(i(), s)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function yn(e, t) { for (t &= ~Zc, t &= ~ba, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - Et(t), r = 1 << n; e[n] = -1, t &= ~r } } function ph(e) { if (K & 6) throw Error(A(327)); $r(); var t = Uo(e, 0); if (!(t & 1)) return Xe(e, fe()), null; var n = ia(e, t); if (e.tag !== 0 && n === 2) { var r = tu(e); r !== 0 && (t = r, n = Au(e, r)) } if (n === 1) throw n = Si, ar(e, 0), yn(e, t), Xe(e, fe()), n; if (n === 6) throw Error(A(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Qn(e, He, Wt), Xe(e, fe()), null } function ed(e, t) { var n = K; K |= 1; try { return e(t) } finally { K = n, K === 0 && (ds = fe() + 500, Ea && Bn()) } } function pr(e) { Rn !== null && Rn.tag === 0 && !(K & 6) && $r(); var t = K; K |= 1; var n = ft.transition, r = G; try { if (ft.transition = null, G = 1, e) return e() } finally { G = r, ft.transition = n, K = t, !(K & 6) && Bn() } } function td() { Ye = Nr.current, ee(Nr) } function ar(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, PS(n)), he !== null) for (n = he.return; n !== null;) { var r = n; switch (Oc(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Ko(); break; case 3: us(), ee(Qe), ee(je), Wc(); break; case 5: $c(r); break; case 4: us(); break; case 13: ee(re); break; case 19: ee(re); break; case 10: Vc(r.type._context); break; case 22: case 23: td() }n = n.return } if (Ce = e, he = e = On(e.current, null), Te = Ye = t, ge = 0, Si = null, Zc = ba = hr = 0, He = Zs = null, qn !== null) { for (t = 0; t < qn.length; t++)if (n = qn[t], r = n.interleaved, r !== null) { n.interleaved = null; var s = r.next, i = n.pending; if (i !== null) { var o = i.next; i.next = s, r.next = o } n.pending = r } qn = null } return e } function gg(e, t) { do { var n = he; try { if (Fc(), To.current = ta, ea) { for (var r = ie.memoizedState; r !== null;) { var s = r.queue; s !== null && (s.pending = null), r = r.next } ea = !1 } if (fr = 0, xe = me = ie = null, Ys = !1, vi = 0, qc.current = null, n === null || n.return === null) { ge = 1, Si = t, he = null; break } e: { var i = e, o = n.return, a = n, l = t; if (t = Te, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = c.alternate; f ? (c.updateQueue = f.updateQueue, c.memoizedState = f.memoizedState, c.lanes = f.lanes) : (c.updateQueue = null, c.memoizedState = null) } var m = th(o); if (m !== null) { m.flags &= -257, nh(m, o, a, i, t), m.mode & 1 && eh(i, u, t), t = m, l = u; var x = t.updateQueue; if (x === null) { var v = new Set; v.add(l), t.updateQueue = v } else x.add(l); break e } else { if (!(t & 1)) { eh(i, u, t), nd(); break e } l = Error(A(426)) } } else if (ne && a.mode & 1) { var S = th(o); if (S !== null) { !(S.flags & 65536) && (S.flags |= 256), nh(S, o, a, i, t), _c(cs(l, a)); break e } } i = l = cs(l, a), ge !== 4 && (ge = 2), Zs === null ? Zs = [i] : Zs.push(i), i = o; do { switch (i.tag) { case 3: i.flags |= 65536, t &= -t, i.lanes |= t; var p = eg(i, l, t); Gf(i, p); break e; case 1: a = l; var h = i.type, g = i.stateNode; if (!(i.flags & 128) && (typeof h.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (Ln === null || !Ln.has(g)))) { i.flags |= 65536, t &= -t, i.lanes |= t; var P = tg(i, a, t); Gf(i, P); break e } }i = i.return } while (i !== null) } xg(n) } catch (E) { t = E, he === n && n !== null && (he = n = n.return); continue } break } while (!0) } function vg() { var e = na.current; return na.current = ta, e === null ? ta : e } function nd() { (ge === 0 || ge === 3 || ge === 2) && (ge = 4), Ce === null || !(hr & 268435455) && !(ba & 268435455) || yn(Ce, Te) } function ia(e, t) { var n = K; K |= 2; var r = vg(); (Ce !== e || Te !== t) && (Wt = null, ar(e, t)); do try { GS(); break } catch (s) { gg(e, s) } while (!0); if (Fc(), K = n, na.current = r, he !== null) throw Error(A(261)); return Ce = null, Te = 0, ge } function GS() { for (; he !== null;)wg(he) } function XS() { for (; he !== null && !xx();)wg(he) } function wg(e) { var t = Cg(e.alternate, e, Ye); e.memoizedProps = e.pendingProps, t === null ? xg(e) : he = t, qc.current = null } function xg(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = BS(n, t), n !== null) { n.flags &= 32767, he = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ge = 6, he = null; return } } else if (n = US(n, t, Ye), n !== null) { he = n; return } if (t = t.sibling, t !== null) { he = t; return } he = t = e } while (t !== null); ge === 0 && (ge = 5) } function Qn(e, t, n) { var r = G, s = ft.transition; try { ft.transition = null, G = 1, YS(e, t, n, r) } finally { ft.transition = s, G = r } return null } function YS(e, t, n, r) { do $r(); while (Rn !== null); if (K & 6) throw Error(A(327)); n = e.finishedWork; var s = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(A(177)); e.callbackNode = null, e.callbackPriority = 0; var i = n.lanes | n.childLanes; if (Mx(e, i), e === Ce && (he = Ce = null, Te = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || uo || (uo = !0, Pg(zo, function () { return $r(), null })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) { i = ft.transition, ft.transition = null; var o = G; G = 1; var a = K; K |= 4, qc.current = null, WS(e, n), pg(n, e), yS(au), Bo = !!ou, au = ou = null, e.current = n, HS(n), Sx(), K = a, G = o, ft.transition = i } else e.current = n; if (uo && (uo = !1, Rn = e, sa = s), i = e.pendingLanes, i === 0 && (Ln = null), Ex(n.stateNode), Xe(e, fe()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)s = t[n], r(s.value, { componentStack: s.stack, digest: s.digest }); if (ra) throw ra = !1, e = Ru, Ru = null, e; return sa & 1 && e.tag !== 0 && $r(), i = e.pendingLanes, i & 1 ? e === bu ? Js++ : (Js = 0, bu = e) : Js = 0, Bn(), null } function $r() { if (Rn !== null) { var e = ey(sa), t = ft.transition, n = G; try { if (ft.transition = null, G = 16 > e ? 16 : e, Rn === null) var r = !1; else { if (e = Rn, Rn = null, sa = 0, K & 6) throw Error(A(331)); var s = K; for (K |= 4, L = e.current; L !== null;) { var i = L, o = i.child; if (L.flags & 16) { var a = i.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (L = u; L !== null;) { var c = L; switch (c.tag) { case 0: case 11: case 15: qs(8, c, i) }var d = c.child; if (d !== null) d.return = c, L = d; else for (; L !== null;) { c = L; var f = c.sibling, m = c.return; if (dg(c), c === u) { L = null; break } if (f !== null) { f.return = m, L = f; break } L = m } } } var x = i.alternate; if (x !== null) { var v = x.child; if (v !== null) { x.child = null; do { var S = v.sibling; v.sibling = null, v = S } while (v !== null) } } L = i } } if (i.subtreeFlags & 2064 && o !== null) o.return = i, L = o; else e: for (; L !== null;) { if (i = L, i.flags & 2048) switch (i.tag) { case 0: case 11: case 15: qs(9, i, i.return) }var p = i.sibling; if (p !== null) { p.return = i.return, L = p; break e } L = i.return } } var h = e.current; for (L = h; L !== null;) { o = L; var g = o.child; if (o.subtreeFlags & 2064 && g !== null) g.return = o, L = g; else e: for (o = h; L !== null;) { if (a = L, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Ra(9, a) } } catch (E) { ce(a, a.return, E) } if (a === o) { L = null; break e } var P = a.sibling; if (P !== null) { P.return = a.return, L = P; break e } L = a.return } } if (K = s, Bn(), Ot && typeof Ot.onPostCommitFiberRoot == "function") try { Ot.onPostCommitFiberRoot(wa, e) } catch { } r = !0 } return r } finally { G = n, ft.transition = t } } return !1 } function mh(e, t, n) { t = cs(n, t), t = eg(e, t, 1), e = Nn(e, t, 1), t = Ve(), e !== null && (_i(e, 1, t), Xe(e, t)) } function ce(e, t, n) { if (e.tag === 3) mh(e, e, n); else for (; t !== null;) { if (t.tag === 3) { mh(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Ln === null || !Ln.has(r))) { e = cs(n, e), e = tg(t, e, 1), t = Nn(t, e, 1), e = Ve(), t !== null && (_i(t, 1, e), Xe(t, e)); break } } t = t.return } } function qS(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Ve(), e.pingedLanes |= e.suspendedLanes & n, Ce === e && (Te & n) === n && (ge === 4 || ge === 3 && (Te & 130023424) === Te && 500 > fe() - Jc ? ar(e, 0) : Zc |= n), Xe(e, t) } function Sg(e, t) { t === 0 && (e.mode & 1 ? (t = Ji, Ji <<= 1, !(Ji & 130023424) && (Ji = 4194304)) : t = 1); var n = Ve(); e = nn(e, t), e !== null && (_i(e, t, n), Xe(e, n)) } function ZS(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), Sg(e, n) } function JS(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, s = e.memoizedState; s !== null && (n = s.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(A(314)) }r !== null && r.delete(t), Sg(e, n) } var Cg; Cg = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Qe.current) Ke = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return Ke = !1, zS(e, t, n); Ke = !!(e.flags & 131072) } else Ke = !1, ne && t.flags & 1048576 && ky(t, Xo, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Ro(e, t), e = t.pendingProps; var s = os(t, je.current); Br(t, n), s = Kc(null, t, r, e, s, n); var i = Qc(); return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ge(r) ? (i = !0, Qo(t)) : i = !1, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, Uc(t), s.updater = ka, t.stateNode = s, s._reactInternals = t, yu(t, r, e, n), t = wu(null, t, r, !0, i, n)) : (t.tag = 0, ne && i && jc(t), Fe(null, t, s, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Ro(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = t1(r), e = vt(r, e), s) { case 0: t = vu(null, t, r, e, n); break e; case 1: t = ih(null, t, r, e, n); break e; case 11: t = rh(null, t, r, e, n); break e; case 14: t = sh(null, t, r, vt(r.type, e), n); break e }throw Error(A(306, r, "")) } return t; case 0: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : vt(r, s), vu(e, t, r, s, n); case 1: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : vt(r, s), ih(e, t, r, s, n); case 3: e: { if (ig(t), e === null) throw Error(A(387)); r = t.pendingProps, i = t.memoizedState, s = i.element, Ny(e, t), Zo(t, r, null, n); var o = t.memoizedState; if (r = o.element, i.isDehydrated) if (i = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) { s = cs(Error(A(423)), t), t = oh(e, t, r, n, s); break e } else if (r !== s) { s = cs(Error(A(424)), t), t = oh(e, t, r, n, s); break e } else for (qe = Dn(t.stateNode.containerInfo.firstChild), Ze = t, ne = !0, Ct = null, n = My(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (as(), r === s) { t = rn(e, t, n); break e } Fe(e, t, r, n) } t = t.child } return t; case 5: return Ly(t), e === null && hu(t), r = t.type, s = t.pendingProps, i = e !== null ? e.memoizedProps : null, o = s.children, lu(r, s) ? o = null : i !== null && lu(r, i) && (t.flags |= 32), sg(e, t), Fe(e, t, o, n), t.child; case 6: return e === null && hu(t), null; case 13: return og(e, t, n); case 4: return Bc(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = ls(t, null, r, n) : Fe(e, t, r, n), t.child; case 11: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : vt(r, s), rh(e, t, r, s, n); case 7: return Fe(e, t, t.pendingProps, n), t.child; case 8: return Fe(e, t, t.pendingProps.children, n), t.child; case 12: return Fe(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, s = t.pendingProps, i = t.memoizedProps, o = s.value, q(Yo, r._currentValue), r._currentValue = o, i !== null) if (kt(i.value, o)) { if (i.children === s.children && !Qe.current) { t = rn(e, t, n); break e } } else for (i = t.child, i !== null && (i.return = t); i !== null;) { var a = i.dependencies; if (a !== null) { o = i.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (i.tag === 1) { l = Yt(-1, n & -n), l.tag = 2; var u = i.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } i.lanes |= n, l = i.alternate, l !== null && (l.lanes |= n), pu(i.return, n, t), a.lanes |= n; break } l = l.next } } else if (i.tag === 10) o = i.type === t.type ? null : i.child; else if (i.tag === 18) { if (o = i.return, o === null) throw Error(A(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), pu(o, n, t), o = i.sibling } else o = i.child; if (o !== null) o.return = i; else for (o = i; o !== null;) { if (o === t) { o = null; break } if (i = o.sibling, i !== null) { i.return = o.return, o = i; break } o = o.return } i = o } Fe(e, t, s.children, n), t = t.child } return t; case 9: return s = t.type, r = t.pendingProps.children, Br(t, n), s = ht(s), r = r(s), t.flags |= 1, Fe(e, t, r, n), t.child; case 14: return r = t.type, s = vt(r, t.pendingProps), s = vt(r.type, s), sh(e, t, r, s, n); case 15: return ng(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : vt(r, s), Ro(e, t), t.tag = 1, Ge(r) ? (e = !0, Qo(t)) : e = !1, Br(t, n), Jy(t, r, s), yu(t, r, s, n), wu(null, t, r, !0, e, n); case 19: return ag(e, t, n); case 22: return rg(e, t, n) }throw Error(A(156, t.tag)) }; function Pg(e, t) { return Ym(e, t) } function e1(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function dt(e, t, n, r) { return new e1(e, t, n, r) } function rd(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function t1(e) { if (typeof e == "function") return rd(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Cc) return 11; if (e === Pc) return 14 } return 2 } function On(e, t) { var n = e.alternate; return n === null ? (n = dt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Mo(e, t, n, r, s, i) { var o = 2; if (r = e, typeof e == "function") rd(e) && (o = 1); else if (typeof e == "string") o = 5; else e: switch (e) { case Cr: return lr(n.children, s, i, t); case Sc: o = 8, s |= 8; break; case zl: return e = dt(12, n, t, s | 2), e.elementType = zl, e.lanes = i, e; case Ul: return e = dt(13, n, t, s), e.elementType = Ul, e.lanes = i, e; case Bl: return e = dt(19, n, t, s), e.elementType = Bl, e.lanes = i, e; case Lm: return Aa(n, s, i, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Dm: o = 10; break e; case Nm: o = 9; break e; case Cc: o = 11; break e; case Pc: o = 14; break e; case hn: o = 16, r = null; break e }throw Error(A(130, e == null ? e : typeof e, "")) }return t = dt(o, n, t, s), t.elementType = e, t.type = r, t.lanes = i, t } function lr(e, t, n, r) { return e = dt(7, e, r, t), e.lanes = n, e } function Aa(e, t, n, r) { return e = dt(22, e, r, t), e.elementType = Lm, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function vl(e, t, n) { return e = dt(6, e, null, t), e.lanes = n, e } function wl(e, t, n) { return t = dt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function n1(e, t, n, r, s) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ja(0), this.expirationTimes = Ja(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ja(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null } function sd(e, t, n, r, s, i, o, a, l) { return e = new n1(e, t, n, a, l), t === 1 ? (t = 1, i === !0 && (t |= 8)) : t = 0, i = dt(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Uc(i), e } function r1(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Sr, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function Eg(e) { if (!e) return In; e = e._reactInternals; e: { if (vr(e) !== e || e.tag !== 1) throw Error(A(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ge(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(A(171)) } if (e.tag === 1) { var n = e.type; if (Ge(n)) return Ey(e, n, t) } return t } function Tg(e, t, n, r, s, i, o, a, l) { return e = sd(n, r, !0, e, s, i, o, a, l), e.context = Eg(null), n = e.current, r = Ve(), s = jn(n), i = Yt(r, s), i.callback = t ?? null, Nn(n, i, s), e.current.lanes = s, _i(e, s, r), Xe(e, r), e } function Ma(e, t, n, r) { var s = t.current, i = Ve(), o = jn(s); return n = Eg(n), t.context === null ? t.context = n : t.pendingContext = n, t = Yt(i, o), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Nn(s, t, o), e !== null && (Tt(e, s, o, i), Eo(e, s, o)), o } function oa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function yh(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function id(e, t) { yh(e, t), (e = e.alternate) && yh(e, t) } var kg = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function od(e) { this._internalRoot = e } Da.prototype.render = od.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(A(409)); Ma(e, t, null, null) }; Da.prototype.unmount = od.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; pr(function () { Ma(null, e, null, null) }), t[tn] = null } }; function Da(e) { this._internalRoot = e } Da.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = ry(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < mn.length && t !== 0 && t < mn[n].priority; n++); mn.splice(n, 0, e), n === 0 && iy(e) } }; function ad(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Na(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function gh() { } function s1(e, t, n, r, s) { if (s) { if (typeof r == "function") { var i = r; r = function () { var u = oa(o); i.call(u) } } var o = Tg(t, r, e, 0, null, !1, !1, "", gh); return e._reactRootContainer = o, e[tn] = o.current, hi(e.nodeType === 8 ? e.parentNode : e), pr(), o } for (; s = e.lastChild;)e.removeChild(s); if (typeof r == "function") { var a = r; r = function () { var u = oa(l); a.call(u) } } var l = sd(e, 0, !1, null, null, !1, !1, "", gh); return e._reactRootContainer = l, e[tn] = l.current, hi(e.nodeType === 8 ? e.parentNode : e), pr(function () { Ma(t, l, n, r) }), l } function La(e, t, n, r, s) { var i = n._reactRootContainer; if (i) { var o = i; if (typeof s == "function") { var a = s; s = function () { var l = oa(o); a.call(l) } } Ma(t, o, e, s) } else o = s1(n, t, e, s, r); return oa(o) } ty = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Vs(t.pendingLanes); n !== 0 && (kc(t, n | 1), Xe(t, fe()), !(K & 6) && (ds = fe() + 500, Bn())) } break; case 13: pr(function () { var r = nn(e, 1); if (r !== null) { var s = Ve(); Tt(r, e, 1, s) } }), id(e, 1) } }; Rc = function (e) { if (e.tag === 13) { var t = nn(e, 134217728); if (t !== null) { var n = Ve(); Tt(t, e, 134217728, n) } id(e, 134217728) } }; ny = function (e) { if (e.tag === 13) { var t = jn(e), n = nn(e, t); if (n !== null) { var r = Ve(); Tt(n, e, t, r) } id(e, t) } }; ry = function () { return G }; sy = function (e, t) { var n = G; try { return G = e, t() } finally { G = n } }; Zl = function (e, t, n) { switch (t) { case "input": if (Hl(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var s = Pa(r); if (!s) throw Error(A(90)); Om(r), Hl(r, s) } } } break; case "textarea": Im(e, n); break; case "select": t = n.value, t != null && Fr(e, !!n.multiple, t, !1) } }; Wm = ed; Hm = pr; var i1 = { usingClientEntryPoint: !1, Events: [Fi, kr, Pa, Bm, $m, ed] }, Ls = { findFiberByHostInstance: Yn, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, o1 = { bundleType: Ls.bundleType, version: Ls.version, rendererPackageName: Ls.rendererPackageName, rendererConfig: Ls.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: on.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Gm(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ls.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var co = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!co.isDisabled && co.supportsFiber) try { wa = co.inject(o1), Ot = co } catch { } } rt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = i1; rt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!ad(t)) throw Error(A(200)); return r1(e, t, null, n) }; rt.createRoot = function (e, t) { if (!ad(e)) throw Error(A(299)); var n = !1, r = "", s = kg; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = sd(e, 1, !1, null, null, n, !1, r, s), e[tn] = t.current, hi(e.nodeType === 8 ? e.parentNode : e), new od(t) }; rt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(A(188)) : (e = Object.keys(e).join(","), Error(A(268, e))); return e = Gm(t), e = e === null ? null : e.stateNode, e }; rt.flushSync = function (e) { return pr(e) }; rt.hydrate = function (e, t, n) { if (!Na(t)) throw Error(A(200)); return La(null, e, t, !0, n) }; rt.hydrateRoot = function (e, t, n) { if (!ad(e)) throw Error(A(405)); var r = n != null && n.hydratedSources || null, s = !1, i = "", o = kg; if (n != null && (n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = Tg(t, null, e, 1, n ?? null, s, !1, i, o), e[tn] = t.current, hi(e), r) for (e = 0; e < r.length; e++)n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, s] : t.mutableSourceEagerHydrationData.push(n, s); return new Da(t) }; rt.render = function (e, t, n) { if (!Na(t)) throw Error(A(200)); return La(null, e, t, !1, n) }; rt.unmountComponentAtNode = function (e) { if (!Na(e)) throw Error(A(40)); return e._reactRootContainer ? (pr(function () { La(null, null, e, !1, function () { e._reactRootContainer = null, e[tn] = null }) }), !0) : !1 }; rt.unstable_batchedUpdates = ed; rt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Na(n)) throw Error(A(200)); if (e == null || e._reactInternals === void 0) throw Error(A(38)); return La(e, t, n, !1, r) }; rt.version = "18.3.1-next-f1338f8080-20240426"; function Rg() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Rg) } catch (e) { console.error(e) } } Rg(), Rm.exports = rt; var ja = Rm.exports; const a1 = mm(ja); var bg, vh = ja; bg = vh.createRoot, vh.hydrateRoot; var xs = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(e) { return this.listeners.add(e), this.onSubscribe(), () => { this.listeners.delete(e), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, mr = typeof window > "u" || "Deno" in globalThis; function lt() { } function l1(e, t) { return typeof e == "function" ? e(t) : e } function Du(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function Ag(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function Wr(e, t) { return typeof e == "function" ? e(t) : e } function Pt(e, t) { return typeof e == "function" ? e(t) : e } function wh(e, t) { const { type: n = "all", exact: r, fetchStatus: s, predicate: i, queryKey: o, stale: a } = e; if (o) { if (r) { if (t.queryHash !== ld(o, t.options)) return !1 } else if (!Ci(t.queryKey, o)) return !1 } if (n !== "all") { const l = t.isActive(); if (n === "active" && !l || n === "inactive" && l) return !1 } return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || i && !i(t)) } function xh(e, t) { const { exact: n, status: r, predicate: s, mutationKey: i } = e; if (i) { if (!t.options.mutationKey) return !1; if (n) { if (yr(t.options.mutationKey) !== yr(i)) return !1 } else if (!Ci(t.options.mutationKey, i)) return !1 } return !(r && t.state.status !== r || s && !s(t)) } function ld(e, t) { return ((t == null ? void 0 : t.queryKeyHashFn) || yr)(e) } function yr(e) { return JSON.stringify(e, (t, n) => Nu(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n) } function Ci(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(n => !Ci(e[n], t[n])) : !1 } function Mg(e, t) { if (e === t) return e; const n = Sh(e) && Sh(t); if (n || Nu(e) && Nu(t)) { const r = n ? e : Object.keys(e), s = r.length, i = n ? t : Object.keys(t), o = i.length, a = n ? [] : {}; let l = 0; for (let u = 0; u < o; u++) { const c = n ? u : i[u]; (!n && r.includes(c) || n) && e[c] === void 0 && t[c] === void 0 ? (a[c] = void 0, l++) : (a[c] = Mg(e[c], t[c]), a[c] === e[c] && e[c] !== void 0 && l++) } return s === o && l === s ? e : a } return t } function aa(e, t) { if (!t || Object.keys(e).length !== Object.keys(t).length) return !1; for (const n in e) if (e[n] !== t[n]) return !1; return !0 } function Sh(e) { return Array.isArray(e) && e.length === Object.keys(e).length } function Nu(e) { if (!Ch(e)) return !1; const t = e.constructor; if (t === void 0) return !0; const n = t.prototype; return !(!Ch(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype) } function Ch(e) { return Object.prototype.toString.call(e) === "[object Object]" } function u1(e) { return new Promise(t => { setTimeout(t, e) }) } function Lu(e, t, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? Mg(e, t) : t } function c1(e, t, n = 0) { const r = [...e, t]; return n && r.length > n ? r.slice(1) : r } function d1(e, t, n = 0) { const r = [t, ...e]; return n && r.length > n ? r.slice(0, -1) : r } var ud = Symbol(); function Dg(e, t) { return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === ud ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn } var er, gn, Kr, im, f1 = (im = class extends xs { constructor() { super(); _(this, er); _(this, gn); _(this, Kr); N(this, Kr, t => { if (!mr && window.addEventListener) { const n = () => t(); return window.addEventListener("visibilitychange", n, !1), () => { window.removeEventListener("visibilitychange", n) } } }) } onSubscribe() { C(this, gn) || this.setEventListener(C(this, Kr)) } onUnsubscribe() { var t; this.hasListeners() || ((t = C(this, gn)) == null || t.call(this), N(this, gn, void 0)) } setEventListener(t) { var n; N(this, Kr, t), (n = C(this, gn)) == null || n.call(this), N(this, gn, t(r => { typeof r == "boolean" ? this.setFocused(r) : this.onFocus() })) } setFocused(t) { C(this, er) !== t && (N(this, er, t), this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(n => { n(t) }) } isFocused() { var t; return typeof C(this, er) == "boolean" ? C(this, er) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden" } }, er = new WeakMap, gn = new WeakMap, Kr = new WeakMap, im), cd = new f1, Qr, vn, Gr, om, h1 = (om = class extends xs { constructor() { super(); _(this, Qr, !0); _(this, vn); _(this, Gr); N(this, Gr, t => { if (!mr && window.addEventListener) { const n = () => t(!0), r = () => t(!1); return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => { window.removeEventListener("online", n), window.removeEventListener("offline", r) } } }) } onSubscribe() { C(this, vn) || this.setEventListener(C(this, Gr)) } onUnsubscribe() { var t; this.hasListeners() || ((t = C(this, vn)) == null || t.call(this), N(this, vn, void 0)) } setEventListener(t) { var n; N(this, Gr, t), (n = C(this, vn)) == null || n.call(this), N(this, vn, t(this.setOnline.bind(this))) } setOnline(t) { C(this, Qr) !== t && (N(this, Qr, t), this.listeners.forEach(r => { r(t) })) } isOnline() { return C(this, Qr) } }, Qr = new WeakMap, vn = new WeakMap, Gr = new WeakMap, om), la = new h1; function ju() { let e, t; const n = new Promise((s, i) => { e = s, t = i }); n.status = "pending", n.catch(() => { }); function r(s) { Object.assign(n, s), delete n.resolve, delete n.reject } return n.resolve = s => { r({ status: "fulfilled", value: s }), e(s) }, n.reject = s => { r({ status: "rejected", reason: s }), t(s) }, n } function p1(e) { return Math.min(1e3 * 2 ** e, 3e4) } function Ng(e) { return (e ?? "online") === "online" ? la.isOnline() : !0 } var Lg = class extends Error { constructor(e) { super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent } }; function xl(e) { return e instanceof Lg } function jg(e) { let t = !1, n = 0, r = !1, s; const i = ju(), o = v => { var S; r || (f(new Lg(v)), (S = e.abort) == null || S.call(e)) }, a = () => { t = !0 }, l = () => { t = !1 }, u = () => cd.isFocused() && (e.networkMode === "always" || la.isOnline()) && e.canRun(), c = () => Ng(e.networkMode) && e.canRun(), d = v => { var S; r || (r = !0, (S = e.onSuccess) == null || S.call(e, v), s == null || s(), i.resolve(v)) }, f = v => { var S; r || (r = !0, (S = e.onError) == null || S.call(e, v), s == null || s(), i.reject(v)) }, m = () => new Promise(v => { var S; s = p => { (r || u()) && v(p) }, (S = e.onPause) == null || S.call(e) }).then(() => { var v; s = void 0, r || (v = e.onContinue) == null || v.call(e) }), x = () => { if (r) return; let v; const S = n === 0 ? e.initialPromise : void 0; try { v = S ?? e.fn() } catch (p) { v = Promise.reject(p) } Promise.resolve(v).then(d).catch(p => { var R; if (r) return; const h = e.retry ?? (mr ? 0 : 3), g = e.retryDelay ?? p1, P = typeof g == "function" ? g(n, p) : g, E = h === !0 || typeof h == "number" && n < h || typeof h == "function" && h(n, p); if (t || !E) { f(p); return } n++, (R = e.onFail) == null || R.call(e, n, p), u1(P).then(() => u() ? void 0 : m()).then(() => { t ? f(p) : x() }) }) }; return { promise: i, cancel: o, continue: () => (s == null || s(), i), cancelRetry: a, continueRetry: l, canStart: c, start: () => (c() ? x() : m().then(x), i) } } function m1() { let e = [], t = 0, n = a => { a() }, r = a => { a() }, s = a => setTimeout(a, 0); const i = a => { t ? e.push(a) : s(() => { n(a) }) }, o = () => { const a = e; e = [], a.length && s(() => { r(() => { a.forEach(l => { n(l) }) }) }) }; return { batch: a => { let l; t++; try { l = a() } finally { t--, t || o() } return l }, batchCalls: a => (...l) => { i(() => { a(...l) }) }, schedule: i, setNotifyFunction: a => { n = a }, setBatchNotifyFunction: a => { r = a }, setScheduler: a => { s = a } } } var ye = m1(), tr, am, Og = (am = class { constructor() { _(this, tr) } destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), Du(this.gcTime) && N(this, tr, setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(e) { this.gcTime = Math.max(this.gcTime || 0, e ?? (mr ? 1 / 0 : 5 * 60 * 1e3)) } clearGcTimeout() { C(this, tr) && (clearTimeout(C(this, tr)), N(this, tr, void 0)) } }, tr = new WeakMap, am), Xr, Yr, at, Ae, Di, nr, wt, $t, lm, y1 = (lm = class extends Og { constructor(t) { super(); _(this, wt); _(this, Xr); _(this, Yr); _(this, at); _(this, Ae); _(this, Di); _(this, nr); N(this, nr, !1), N(this, Di, t.defaultOptions), this.setOptions(t.options), this.observers = [], N(this, at, t.cache), this.queryKey = t.queryKey, this.queryHash = t.queryHash, N(this, Xr, g1(this.options)), this.state = t.state ?? C(this, Xr), this.scheduleGc() } get meta() { return this.options.meta } get promise() { var t; return (t = C(this, Ae)) == null ? void 0 : t.promise } setOptions(t) { this.options = { ...C(this, Di), ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && C(this, at).remove(this) } setData(t, n) { const r = Lu(this.state.data, t, this.options); return B(this, wt, $t).call(this, { data: r, type: "success", dataUpdatedAt: n == null ? void 0 : n.updatedAt, manual: n == null ? void 0 : n.manual }), r } setState(t, n) { B(this, wt, $t).call(this, { type: "setState", state: t, setStateOptions: n }) } cancel(t) { var r, s; const n = (r = C(this, Ae)) == null ? void 0 : r.promise; return (s = C(this, Ae)) == null || s.cancel(t), n ? n.then(lt).catch(lt) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(C(this, Xr)) } isActive() { return this.observers.some(t => Pt(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ud || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStale() { return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 } isStaleByTime(t = 0) { return this.state.isInvalidated || this.state.data === void 0 || !Ag(this.state.dataUpdatedAt, t) } onFocus() { var n; const t = this.observers.find(r => r.shouldFetchOnWindowFocus()); t == null || t.refetch({ cancelRefetch: !1 }), (n = C(this, Ae)) == null || n.continue() } onOnline() { var n; const t = this.observers.find(r => r.shouldFetchOnReconnect()); t == null || t.refetch({ cancelRefetch: !1 }), (n = C(this, Ae)) == null || n.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), C(this, at).notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (C(this, Ae) && (C(this, nr) ? C(this, Ae).cancel({ revert: !0 }) : C(this, Ae).cancelRetry()), this.scheduleGc()), C(this, at).notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || B(this, wt, $t).call(this, { type: "invalidate" }) } fetch(t, n) { var l, u, c; if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({ silent: !0 }); else if (C(this, Ae)) return C(this, Ae).continueRetry(), C(this, Ae).promise } if (t && this.setOptions(t), !this.options.queryFn) { const d = this.observers.find(f => f.options.queryFn); d && this.setOptions(d.options) } const r = new AbortController, s = d => { Object.defineProperty(d, "signal", { enumerable: !0, get: () => (N(this, nr, !0), r.signal) }) }, i = () => { const d = Dg(this.options, n), f = { queryKey: this.queryKey, meta: this.meta }; return s(f), N(this, nr, !1), this.options.persister ? this.options.persister(d, f, this) : d(f) }, o = { fetchOptions: n, options: this.options, queryKey: this.queryKey, state: this.state, fetchFn: i }; s(o), (l = this.options.behavior) == null || l.onFetch(o, this), N(this, Yr, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = o.fetchOptions) == null ? void 0 : u.meta)) && B(this, wt, $t).call(this, { type: "fetch", meta: (c = o.fetchOptions) == null ? void 0 : c.meta }); const a = d => { var f, m, x, v; xl(d) && d.silent || B(this, wt, $t).call(this, { type: "error", error: d }), xl(d) || ((m = (f = C(this, at).config).onError) == null || m.call(f, d, this), (v = (x = C(this, at).config).onSettled) == null || v.call(x, this.state.data, d, this)), this.scheduleGc() }; return N(this, Ae, jg({ initialPromise: n == null ? void 0 : n.initialPromise, fn: o.fetchFn, abort: r.abort.bind(r), onSuccess: d => { var f, m, x, v; if (d === void 0) { a(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(d) } catch (S) { a(S); return } (m = (f = C(this, at).config).onSuccess) == null || m.call(f, d, this), (v = (x = C(this, at).config).onSettled) == null || v.call(x, d, this.state.error, this), this.scheduleGc() }, onError: a, onFail: (d, f) => { B(this, wt, $t).call(this, { type: "failed", failureCount: d, error: f }) }, onPause: () => { B(this, wt, $t).call(this, { type: "pause" }) }, onContinue: () => { B(this, wt, $t).call(this, { type: "continue" }) }, retry: o.options.retry, retryDelay: o.options.retryDelay, networkMode: o.options.networkMode, canRun: () => !0 })), C(this, Ae).start() } }, Xr = new WeakMap, Yr = new WeakMap, at = new WeakMap, Ae = new WeakMap, Di = new WeakMap, nr = new WeakMap, wt = new WeakSet, $t = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...r, fetchStatus: "paused" }; case "continue": return { ...r, fetchStatus: "fetching" }; case "fetch": return { ...r, ..._g(r.data, this.options), fetchMeta: t.meta ?? null }; case "success": return { ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const s = t.error; return xl(s) && s.revert && C(this, Yr) ? { ...C(this, Yr), fetchStatus: "idle" } : { ...r, error: s, errorUpdateCount: r.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: r.fetchFailureCount + 1, fetchFailureReason: s, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...r, isInvalidated: !0 }; case "setState": return { ...r, ...t.state } } }; this.state = n(this.state), ye.batch(() => { this.observers.forEach(r => { r.onQueryUpdate() }), C(this, at).notify({ query: this, type: "updated", action: t }) }) }, lm); function _g(e, t) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: Ng(t.networkMode) ? "fetching" : "paused", ...e === void 0 && { error: null, status: "pending" } } } function g1(e) { const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0; return { data: t, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var Mt, um, v1 = (um = class extends xs { constructor(t = {}) { super(); _(this, Mt); this.config = t, N(this, Mt, new Map) } build(t, n, r) { const s = n.queryKey, i = n.queryHash ?? ld(s, n); let o = this.get(i); return o || (o = new y1({ cache: this, queryKey: s, queryHash: i, options: t.defaultQueryOptions(n), state: r, defaultOptions: t.getQueryDefaults(s) }), this.add(o)), o } add(t) { C(this, Mt).has(t.queryHash) || (C(this, Mt).set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const n = C(this, Mt).get(t.queryHash); n && (t.destroy(), n === t && C(this, Mt).delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { ye.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return C(this, Mt).get(t) } getAll() { return [...C(this, Mt).values()] } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => wh(n, r)) } findAll(t = {}) { const n = this.getAll(); return Object.keys(t).length > 0 ? n.filter(r => wh(t, r)) : n } notify(t) { ye.batch(() => { this.listeners.forEach(n => { n(t) }) }) } onFocus() { ye.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { ye.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, Mt = new WeakMap, um), Dt, _e, rr, Nt, dn, cm, w1 = (cm = class extends Og { constructor(t) { super(); _(this, Nt); _(this, Dt); _(this, _e); _(this, rr); this.mutationId = t.mutationId, N(this, _e, t.mutationCache), N(this, Dt, []), this.state = t.state || Ig(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { C(this, Dt).includes(t) || (C(this, Dt).push(t), this.clearGcTimeout(), C(this, _e).notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { N(this, Dt, C(this, Dt).filter(n => n !== t)), this.scheduleGc(), C(this, _e).notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { C(this, Dt).length || (this.state.status === "pending" ? this.scheduleGc() : C(this, _e).remove(this)) } continue() { var t; return ((t = C(this, rr)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables) } async execute(t) { var s, i, o, a, l, u, c, d, f, m, x, v, S, p, h, g, P, E, R, k; N(this, rr, jg({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (T, b) => { B(this, Nt, dn).call(this, { type: "failed", failureCount: T, error: b }) }, onPause: () => { B(this, Nt, dn).call(this, { type: "pause" }) }, onContinue: () => { B(this, Nt, dn).call(this, { type: "continue" }) }, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => C(this, _e).canRun(this) })); const n = this.state.status === "pending", r = !C(this, rr).canStart(); try { if (!n) { B(this, Nt, dn).call(this, { type: "pending", variables: t, isPaused: r }), await ((i = (s = C(this, _e).config).onMutate) == null ? void 0 : i.call(s, t, this)); const b = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, t)); b !== this.state.context && B(this, Nt, dn).call(this, { type: "pending", context: b, variables: t, isPaused: r }) } const T = await C(this, rr).start(); return await ((u = (l = C(this, _e).config).onSuccess) == null ? void 0 : u.call(l, T, t, this.state.context, this)), await ((d = (c = this.options).onSuccess) == null ? void 0 : d.call(c, T, t, this.state.context)), await ((m = (f = C(this, _e).config).onSettled) == null ? void 0 : m.call(f, T, null, this.state.variables, this.state.context, this)), await ((v = (x = this.options).onSettled) == null ? void 0 : v.call(x, T, null, t, this.state.context)), B(this, Nt, dn).call(this, { type: "success", data: T }), T } catch (T) { try { throw await ((p = (S = C(this, _e).config).onError) == null ? void 0 : p.call(S, T, t, this.state.context, this)), await ((g = (h = this.options).onError) == null ? void 0 : g.call(h, T, t, this.state.context)), await ((E = (P = C(this, _e).config).onSettled) == null ? void 0 : E.call(P, void 0, T, this.state.variables, this.state.context, this)), await ((k = (R = this.options).onSettled) == null ? void 0 : k.call(R, void 0, T, t, this.state.context)), T } finally { B(this, Nt, dn).call(this, { type: "error", error: T }) } } finally { C(this, _e).runNext(this) } } }, Dt = new WeakMap, _e = new WeakMap, rr = new WeakMap, Nt = new WeakSet, dn = function (t) { const n = r => { switch (t.type) { case "failed": return { ...r, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...r, isPaused: !0 }; case "continue": return { ...r, isPaused: !1 }; case "pending": return { ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = n(this.state), ye.batch(() => { C(this, Dt).forEach(r => { r.onMutationUpdate(t) }), C(this, _e).notify({ mutation: this, type: "updated", action: t }) }) }, cm); function Ig() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var Kt, xt, Ni, dm, x1 = (dm = class extends xs { constructor(t = {}) { super(); _(this, Kt); _(this, xt); _(this, Ni); this.config = t, N(this, Kt, new Set), N(this, xt, new Map), N(this, Ni, 0) } build(t, n, r) { const s = new w1({ mutationCache: this, mutationId: ++Qi(this, Ni)._, options: t.defaultMutationOptions(n), state: r }); return this.add(s), s } add(t) { C(this, Kt).add(t); const n = fo(t); if (typeof n == "string") { const r = C(this, xt).get(n); r ? r.push(t) : C(this, xt).set(n, [t]) } this.notify({ type: "added", mutation: t }) } remove(t) { if (C(this, Kt).delete(t)) { const n = fo(t); if (typeof n == "string") { const r = C(this, xt).get(n); if (r) if (r.length > 1) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } else r[0] === t && C(this, xt).delete(n) } } this.notify({ type: "removed", mutation: t }) } canRun(t) { const n = fo(t); if (typeof n == "string") { const r = C(this, xt).get(n), s = r == null ? void 0 : r.find(i => i.state.status === "pending"); return !s || s === t } else return !0 } runNext(t) { var r; const n = fo(t); if (typeof n == "string") { const s = (r = C(this, xt).get(n)) == null ? void 0 : r.find(i => i !== t && i.state.isPaused); return (s == null ? void 0 : s.continue()) ?? Promise.resolve() } else return Promise.resolve() } clear() { ye.batch(() => { C(this, Kt).forEach(t => { this.notify({ type: "removed", mutation: t }) }), C(this, Kt).clear(), C(this, xt).clear() }) } getAll() { return Array.from(C(this, Kt)) } find(t) { const n = { exact: !0, ...t }; return this.getAll().find(r => xh(n, r)) } findAll(t = {}) { return this.getAll().filter(n => xh(t, n)) } notify(t) { ye.batch(() => { this.listeners.forEach(n => { n(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(n => n.state.isPaused); return ye.batch(() => Promise.all(t.map(n => n.continue().catch(lt)))) } }, Kt = new WeakMap, xt = new WeakMap, Ni = new WeakMap, dm); function fo(e) { var t; return (t = e.options.scope) == null ? void 0 : t.id } function Ph(e) { return { onFetch: (t, n) => { var c, d, f, m, x; const r = t.options, s = (f = (d = (c = t.fetchOptions) == null ? void 0 : c.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : f.direction, i = ((m = t.state.data) == null ? void 0 : m.pages) || [], o = ((x = t.state.data) == null ? void 0 : x.pageParams) || []; let a = { pages: [], pageParams: [] }, l = 0; const u = async () => { let v = !1; const S = g => { Object.defineProperty(g, "signal", { enumerable: !0, get: () => (t.signal.aborted ? v = !0 : t.signal.addEventListener("abort", () => { v = !0 }), t.signal) }) }, p = Dg(t.options, t.fetchOptions), h = async (g, P, E) => { if (v) return Promise.reject(); if (P == null && g.pages.length) return Promise.resolve(g); const R = { queryKey: t.queryKey, pageParam: P, direction: E ? "backward" : "forward", meta: t.options.meta }; S(R); const k = await p(R), { maxPages: T } = t.options, b = E ? d1 : c1; return { pages: b(g.pages, k, T), pageParams: b(g.pageParams, P, T) } }; if (s && i.length) { const g = s === "backward", P = g ? S1 : Eh, E = { pages: i, pageParams: o }, R = P(r, E); a = await h(E, R, g) } else { const g = e ?? i.length; do { const P = l === 0 ? o[0] ?? r.initialPageParam : Eh(r, a); if (l > 0 && P == null) break; a = await h(a, P), l++ } while (l < g) } return a }; t.options.persister ? t.fetchFn = () => { var v, S; return (S = (v = t.options).persister) == null ? void 0 : S.call(v, u, { queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, n) } : t.fetchFn = u } } } function Eh(e, { pages: t, pageParams: n }) { const r = t.length - 1; return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0 } function S1(e, { pages: t, pageParams: n }) { var r; return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0 } var le, wn, xn, qr, Zr, Sn, Jr, es, fm, C1 = (fm = class { constructor(e = {}) { _(this, le); _(this, wn); _(this, xn); _(this, qr); _(this, Zr); _(this, Sn); _(this, Jr); _(this, es); N(this, le, e.queryCache || new v1), N(this, wn, e.mutationCache || new x1), N(this, xn, e.defaultOptions || {}), N(this, qr, new Map), N(this, Zr, new Map), N(this, Sn, 0) } mount() { Qi(this, Sn)._++, C(this, Sn) === 1 && (N(this, Jr, cd.subscribe(async e => { e && (await this.resumePausedMutations(), C(this, le).onFocus()) })), N(this, es, la.subscribe(async e => { e && (await this.resumePausedMutations(), C(this, le).onOnline()) }))) } unmount() { var e, t; Qi(this, Sn)._--, C(this, Sn) === 0 && ((e = C(this, Jr)) == null || e.call(this), N(this, Jr, void 0), (t = C(this, es)) == null || t.call(this), N(this, es, void 0)) } isFetching(e) { return C(this, le).findAll({ ...e, fetchStatus: "fetching" }).length } isMutating(e) { return C(this, wn).findAll({ ...e, status: "pending" }).length } getQueryData(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = C(this, le).get(t.queryHash)) == null ? void 0 : n.state.data } ensureQueryData(e) { const t = this.defaultQueryOptions(e), n = C(this, le).build(this, t), r = n.state.data; return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Wr(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r)) } getQueriesData(e) { return C(this, le).findAll(e).map(({ queryKey: t, state: n }) => { const r = n.data; return [t, r] }) } setQueryData(e, t, n) { const r = this.defaultQueryOptions({ queryKey: e }), s = C(this, le).get(r.queryHash), i = s == null ? void 0 : s.state.data, o = l1(t, i); if (o !== void 0) return C(this, le).build(this, r).setData(o, { ...n, manual: !0 }) } setQueriesData(e, t, n) { return ye.batch(() => C(this, le).findAll(e).map(({ queryKey: r }) => [r, this.setQueryData(r, t, n)])) } getQueryState(e) { var n; const t = this.defaultQueryOptions({ queryKey: e }); return (n = C(this, le).get(t.queryHash)) == null ? void 0 : n.state } removeQueries(e) { const t = C(this, le); ye.batch(() => { t.findAll(e).forEach(n => { t.remove(n) }) }) } resetQueries(e, t) { const n = C(this, le), r = { type: "active", ...e }; return ye.batch(() => (n.findAll(e).forEach(s => { s.reset() }), this.refetchQueries(r, t))) } cancelQueries(e, t = {}) { const n = { revert: !0, ...t }, r = ye.batch(() => C(this, le).findAll(e).map(s => s.cancel(n))); return Promise.all(r).then(lt).catch(lt) } invalidateQueries(e, t = {}) { return ye.batch(() => { if (C(this, le).findAll(e).forEach(r => { r.invalidate() }), (e == null ? void 0 : e.refetchType) === "none") return Promise.resolve(); const n = { ...e, type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active" }; return this.refetchQueries(n, t) }) } refetchQueries(e, t = {}) { const n = { ...t, cancelRefetch: t.cancelRefetch ?? !0 }, r = ye.batch(() => C(this, le).findAll(e).filter(s => !s.isDisabled()).map(s => { let i = s.fetch(void 0, n); return n.throwOnError || (i = i.catch(lt)), s.state.fetchStatus === "paused" ? Promise.resolve() : i })); return Promise.all(r).then(lt) } fetchQuery(e) { const t = this.defaultQueryOptions(e); t.retry === void 0 && (t.retry = !1); const n = C(this, le).build(this, t); return n.isStaleByTime(Wr(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data) } prefetchQuery(e) { return this.fetchQuery(e).then(lt).catch(lt) } fetchInfiniteQuery(e) { return e.behavior = Ph(e.pages), this.fetchQuery(e) } prefetchInfiniteQuery(e) { return this.fetchInfiniteQuery(e).then(lt).catch(lt) } ensureInfiniteQueryData(e) { return e.behavior = Ph(e.pages), this.ensureQueryData(e) } resumePausedMutations() { return la.isOnline() ? C(this, wn).resumePausedMutations() : Promise.resolve() } getQueryCache() { return C(this, le) } getMutationCache() { return C(this, wn) } getDefaultOptions() { return C(this, xn) } setDefaultOptions(e) { N(this, xn, e) } setQueryDefaults(e, t) { C(this, qr).set(yr(e), { queryKey: e, defaultOptions: t }) } getQueryDefaults(e) { const t = [...C(this, qr).values()], n = {}; return t.forEach(r => { Ci(e, r.queryKey) && Object.assign(n, r.defaultOptions) }), n } setMutationDefaults(e, t) { C(this, Zr).set(yr(e), { mutationKey: e, defaultOptions: t }) } getMutationDefaults(e) { const t = [...C(this, Zr).values()]; let n = {}; return t.forEach(r => { Ci(e, r.mutationKey) && (n = { ...n, ...r.defaultOptions }) }), n } defaultQueryOptions(e) { if (e._defaulted) return e; const t = { ...C(this, xn).queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }; return t.queryHash || (t.queryHash = ld(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === ud && (t.enabled = !1), t } defaultMutationOptions(e) { return e != null && e._defaulted ? e : { ...C(this, xn).mutations, ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey), ...e, _defaulted: !0 } } clear() { C(this, le).clear(), C(this, wn).clear() } }, le = new WeakMap, wn = new WeakMap, xn = new WeakMap, qr = new WeakMap, Zr = new WeakMap, Sn = new WeakMap, Jr = new WeakMap, es = new WeakMap, fm), $e, W, Li, Ie, sr, ts, Cn, Lt, ji, ns, rs, ir, or, Pn, ss, Q, Us, Ou, _u, Iu, Fu, Vu, zu, Uu, Fg, hm, P1 = (hm = class extends xs { constructor(t, n) { super(); _(this, Q); _(this, $e); _(this, W); _(this, Li); _(this, Ie); _(this, sr); _(this, ts); _(this, Cn); _(this, Lt); _(this, ji); _(this, ns); _(this, rs); _(this, ir); _(this, or); _(this, Pn); _(this, ss, new Set); this.options = n, N(this, $e, t), N(this, Lt, null), N(this, Cn, ju()), this.options.experimental_prefetchInRender || C(this, Cn).reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(n) } bindMethods() { this.refetch = this.refetch.bind(this) } onSubscribe() { this.listeners.size === 1 && (C(this, W).addObserver(this), Th(C(this, W), this.options) ? B(this, Q, Us).call(this) : this.updateResult(), B(this, Q, Fu).call(this)) } onUnsubscribe() { this.hasListeners() || this.destroy() } shouldFetchOnReconnect() { return Bu(C(this, W), this.options, this.options.refetchOnReconnect) } shouldFetchOnWindowFocus() { return Bu(C(this, W), this.options, this.options.refetchOnWindowFocus) } destroy() { this.listeners = new Set, B(this, Q, Vu).call(this), B(this, Q, zu).call(this), C(this, W).removeObserver(this) } setOptions(t, n) { const r = this.options, s = C(this, W); if (this.options = C(this, $e).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Pt(this.options.enabled, C(this, W)) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean"); B(this, Q, Uu).call(this), C(this, W).setOptions(this.options), r._defaulted && !aa(this.options, r) && C(this, $e).getQueryCache().notify({ type: "observerOptionsUpdated", query: C(this, W), observer: this }); const i = this.hasListeners(); i && kh(C(this, W), s, this.options, r) && B(this, Q, Us).call(this), this.updateResult(n), i && (C(this, W) !== s || Pt(this.options.enabled, C(this, W)) !== Pt(r.enabled, C(this, W)) || Wr(this.options.staleTime, C(this, W)) !== Wr(r.staleTime, C(this, W))) && B(this, Q, Ou).call(this); const o = B(this, Q, _u).call(this); i && (C(this, W) !== s || Pt(this.options.enabled, C(this, W)) !== Pt(r.enabled, C(this, W)) || o !== C(this, Pn)) && B(this, Q, Iu).call(this, o) } getOptimisticResult(t) { const n = C(this, $e).getQueryCache().build(C(this, $e), t), r = this.createResult(n, t); return T1(this, r) && (N(this, Ie, r), N(this, ts, this.options), N(this, sr, C(this, W).state)), r } getCurrentResult() { return C(this, Ie) } trackResult(t, n) { const r = {}; return Object.keys(t).forEach(s => { Object.defineProperty(r, s, { configurable: !1, enumerable: !0, get: () => (this.trackProp(s), n == null || n(s), t[s]) }) }), r } trackProp(t) { C(this, ss).add(t) } getCurrentQuery() { return C(this, W) } refetch({ ...t } = {}) { return this.fetch({ ...t }) } fetchOptimistic(t) { const n = C(this, $e).defaultQueryOptions(t), r = C(this, $e).getQueryCache().build(C(this, $e), n); return r.fetch().then(() => this.createResult(r, n)) } fetch(t) { return B(this, Q, Us).call(this, { ...t, cancelRefetch: t.cancelRefetch ?? !0 }).then(() => (this.updateResult(), C(this, Ie))) } createResult(t, n) { var T; const r = C(this, W), s = this.options, i = C(this, Ie), o = C(this, sr), a = C(this, ts), u = t !== r ? t.state : C(this, Li), { state: c } = t; let d = { ...c }, f = !1, m; if (n._optimisticResults) { const b = this.hasListeners(), M = !b && Th(t, n), F = b && kh(t, r, n, s); (M || F) && (d = { ...d, ..._g(c.data, t.options) }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle") } let { error: x, errorUpdatedAt: v, status: S } = d; if (n.select && d.data !== void 0) if (i && d.data === (o == null ? void 0 : o.data) && n.select === C(this, ji)) m = C(this, ns); else try { N(this, ji, n.select), m = n.select(d.data), m = Lu(i == null ? void 0 : i.data, m, n), N(this, ns, m), N(this, Lt, null) } catch (b) { N(this, Lt, b) } else m = d.data; if (n.placeholderData !== void 0 && m === void 0 && S === "pending") { let b; if (i != null && i.isPlaceholderData && n.placeholderData === (a == null ? void 0 : a.placeholderData)) b = i.data; else if (b = typeof n.placeholderData == "function" ? n.placeholderData((T = C(this, rs)) == null ? void 0 : T.state.data, C(this, rs)) : n.placeholderData, n.select && b !== void 0) try { b = n.select(b), N(this, Lt, null) } catch (M) { N(this, Lt, M) } b !== void 0 && (S = "success", m = Lu(i == null ? void 0 : i.data, b, n), f = !0) } C(this, Lt) && (x = C(this, Lt), m = C(this, ns), v = Date.now(), S = "error"); const p = d.fetchStatus === "fetching", h = S === "pending", g = S === "error", P = h && p, E = m !== void 0, k = { status: S, fetchStatus: d.fetchStatus, isPending: h, isSuccess: S === "success", isError: g, isInitialLoading: P, isLoading: P, data: m, dataUpdatedAt: d.dataUpdatedAt, error: x, errorUpdatedAt: v, failureCount: d.fetchFailureCount, failureReason: d.fetchFailureReason, errorUpdateCount: d.errorUpdateCount, isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0, isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount, isFetching: p, isRefetching: p && !h, isLoadingError: g && !E, isPaused: d.fetchStatus === "paused", isPlaceholderData: f, isRefetchError: g && E, isStale: dd(t, n), refetch: this.refetch, promise: C(this, Cn) }; if (this.options.experimental_prefetchInRender) { const b = j => { k.status === "error" ? j.reject(k.error) : k.data !== void 0 && j.resolve(k.data) }, M = () => { const j = N(this, Cn, k.promise = ju()); b(j) }, F = C(this, Cn); switch (F.status) { case "pending": t.queryHash === r.queryHash && b(F); break; case "fulfilled": (k.status === "error" || k.data !== F.value) && M(); break; case "rejected": (k.status !== "error" || k.error !== F.reason) && M(); break } } return k } updateResult(t) { const n = C(this, Ie), r = this.createResult(C(this, W), this.options); if (N(this, sr, C(this, W).state), N(this, ts, this.options), C(this, sr).data !== void 0 && N(this, rs, C(this, W)), aa(r, n)) return; N(this, Ie, r); const s = {}, i = () => { if (!n) return !0; const { notifyOnChangeProps: o } = this.options, a = typeof o == "function" ? o() : o; if (a === "all" || !a && !C(this, ss).size) return !0; const l = new Set(a ?? C(this, ss)); return this.options.throwOnError && l.add("error"), Object.keys(C(this, Ie)).some(u => { const c = u; return C(this, Ie)[c] !== n[c] && l.has(c) }) }; (t == null ? void 0 : t.listeners) !== !1 && i() && (s.listeners = !0), B(this, Q, Fg).call(this, { ...s, ...t }) } onQueryUpdate() { this.updateResult(), this.hasListeners() && B(this, Q, Fu).call(this) } }, $e = new WeakMap, W = new WeakMap, Li = new WeakMap, Ie = new WeakMap, sr = new WeakMap, ts = new WeakMap, Cn = new WeakMap, Lt = new WeakMap, ji = new WeakMap, ns = new WeakMap, rs = new WeakMap, ir = new WeakMap, or = new WeakMap, Pn = new WeakMap, ss = new WeakMap, Q = new WeakSet, Us = function (t) { B(this, Q, Uu).call(this); let n = C(this, W).fetch(this.options, t); return t != null && t.throwOnError || (n = n.catch(lt)), n }, Ou = function () { B(this, Q, Vu).call(this); const t = Wr(this.options.staleTime, C(this, W)); if (mr || C(this, Ie).isStale || !Du(t)) return; const r = Ag(C(this, Ie).dataUpdatedAt, t) + 1; N(this, ir, setTimeout(() => { C(this, Ie).isStale || this.updateResult() }, r)) }, _u = function () { return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(C(this, W)) : this.options.refetchInterval) ?? !1 }, Iu = function (t) { B(this, Q, zu).call(this), N(this, Pn, t), !(mr || Pt(this.options.enabled, C(this, W)) === !1 || !Du(C(this, Pn)) || C(this, Pn) === 0) && N(this, or, setInterval(() => { (this.options.refetchIntervalInBackground || cd.isFocused()) && B(this, Q, Us).call(this) }, C(this, Pn))) }, Fu = function () { B(this, Q, Ou).call(this), B(this, Q, Iu).call(this, B(this, Q, _u).call(this)) }, Vu = function () { C(this, ir) && (clearTimeout(C(this, ir)), N(this, ir, void 0)) }, zu = function () { C(this, or) && (clearInterval(C(this, or)), N(this, or, void 0)) }, Uu = function () { const t = C(this, $e).getQueryCache().build(C(this, $e), this.options); if (t === C(this, W)) return; const n = C(this, W); N(this, W, t), N(this, Li, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this)) }, Fg = function (t) { ye.batch(() => { t.listeners && this.listeners.forEach(n => { n(C(this, Ie)) }), C(this, $e).getQueryCache().notify({ query: C(this, W), type: "observerResultsUpdated" }) }) }, hm); function E1(e, t) { return Pt(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1) } function Th(e, t) { return E1(e, t) || e.state.data !== void 0 && Bu(e, t, t.refetchOnMount) } function Bu(e, t, n) { if (Pt(t.enabled, e) !== !1) { const r = typeof n == "function" ? n(e) : n; return r === "always" || r !== !1 && dd(e, t) } return !1 } function kh(e, t, n, r) { return (e !== t || Pt(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && dd(e, n) } function dd(e, t) { return Pt(t.enabled, e) !== !1 && e.isStaleByTime(Wr(t.staleTime, e)) } function T1(e, t) { return !aa(e.getCurrentResult(), t) } var En, Tn, We, Qt, Jt, Do, $u, pm, k1 = (pm = class extends xs { constructor(n, r) { super(); _(this, Jt); _(this, En); _(this, Tn); _(this, We); _(this, Qt); N(this, En, n), this.setOptions(r), this.bindMethods(), B(this, Jt, Do).call(this) } bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) } setOptions(n) { var s; const r = this.options; this.options = C(this, En).defaultMutationOptions(n), aa(this.options, r) || C(this, En).getMutationCache().notify({ type: "observerOptionsUpdated", mutation: C(this, We), observer: this }), r != null && r.mutationKey && this.options.mutationKey && yr(r.mutationKey) !== yr(this.options.mutationKey) ? this.reset() : ((s = C(this, We)) == null ? void 0 : s.state.status) === "pending" && C(this, We).setOptions(this.options) } onUnsubscribe() { var n; this.hasListeners() || (n = C(this, We)) == null || n.removeObserver(this) } onMutationUpdate(n) { B(this, Jt, Do).call(this), B(this, Jt, $u).call(this, n) } getCurrentResult() { return C(this, Tn) } reset() { var n; (n = C(this, We)) == null || n.removeObserver(this), N(this, We, void 0), B(this, Jt, Do).call(this), B(this, Jt, $u).call(this) } mutate(n, r) { var s; return N(this, Qt, r), (s = C(this, We)) == null || s.removeObserver(this), N(this, We, C(this, En).getMutationCache().build(C(this, En), this.options)), C(this, We).addObserver(this), C(this, We).execute(n) } }, En = new WeakMap, Tn = new WeakMap, We = new WeakMap, Qt = new WeakMap, Jt = new WeakSet, Do = function () { var r; const n = ((r = C(this, We)) == null ? void 0 : r.state) ?? Ig(); N(this, Tn, { ...n, isPending: n.status === "pending", isSuccess: n.status === "success", isError: n.status === "error", isIdle: n.status === "idle", mutate: this.mutate, reset: this.reset }) }, $u = function (n) { ye.batch(() => { var r, s, i, o, a, l, u, c; if (C(this, Qt) && this.hasListeners()) { const d = C(this, Tn).variables, f = C(this, Tn).context; (n == null ? void 0 : n.type) === "success" ? ((s = (r = C(this, Qt)).onSuccess) == null || s.call(r, n.data, d, f), (o = (i = C(this, Qt)).onSettled) == null || o.call(i, n.data, null, d, f)) : (n == null ? void 0 : n.type) === "error" && ((l = (a = C(this, Qt)).onError) == null || l.call(a, n.error, d, f), (c = (u = C(this, Qt)).onSettled) == null || c.call(u, void 0, n.error, d, f)) } this.listeners.forEach(d => { d(C(this, Tn)) }) }) }, pm), Vg = y.createContext(void 0), zg = e => { const t = y.useContext(Vg); if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one"); return t }, R1 = ({ client: e, children: t }) => (y.useEffect(() => (e.mount(), () => { e.unmount() }), [e]), w.jsx(Vg.Provider, { value: e, children: t })), Ug = y.createContext(!1), b1 = () => y.useContext(Ug); Ug.Provider; function A1() { let e = !1; return { clearReset: () => { e = !1 }, reset: () => { e = !0 }, isReset: () => e } } var M1 = y.createContext(A1()), D1 = () => y.useContext(M1); function Bg(e, t) { return typeof e == "function" ? e(...t) : !!e } function Wu() { } var N1 = (e, t) => { (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1)) }, L1 = e => { y.useEffect(() => { e.clearReset() }, [e]) }, j1 = ({ result: e, errorResetBoundary: t, throwOnError: n, query: r }) => e.isError && !t.isReset() && !e.isFetching && r && Bg(n, [e.error, r]), O1 = e => { const t = e.staleTime; e.suspense && (e.staleTime = typeof t == "function" ? (...n) => Math.max(t(...n), 1e3) : Math.max(t ?? 1e3, 1e3), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3))) }, _1 = (e, t) => e.isLoading && e.isFetching && !t, I1 = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending, Rh = (e, t, n) => t.fetchOptimistic(e).catch(() => { n.clearReset() }); function F1(e, t, n) { var d, f, m, x, v; const r = zg(), s = b1(), i = D1(), o = r.defaultQueryOptions(e); (f = (d = r.getDefaultOptions().queries) == null ? void 0 : d._experimental_beforeQuery) == null || f.call(d, o), o._optimisticResults = s ? "isRestoring" : "optimistic", O1(o), N1(o, i), L1(i); const a = !r.getQueryCache().get(o.queryHash), [l] = y.useState(() => new t(r, o)), u = l.getOptimisticResult(o), c = !s && e.subscribed !== !1; if (y.useSyncExternalStore(y.useCallback(S => { const p = c ? l.subscribe(ye.batchCalls(S)) : Wu; return l.updateResult(), p }, [l, c]), () => l.getCurrentResult(), () => l.getCurrentResult()), y.useEffect(() => { l.setOptions(o, { listeners: !1 }) }, [o, l]), I1(o, u)) throw Rh(o, l, i); if (j1({ result: u, errorResetBoundary: i, throwOnError: o.throwOnError, query: r.getQueryCache().get(o.queryHash) })) throw u.error; if ((x = (m = r.getDefaultOptions().queries) == null ? void 0 : m._experimental_afterQuery) == null || x.call(m, o, u), o.experimental_prefetchInRender && !mr && _1(u, s)) { const S = a ? Rh(o, l, i) : (v = r.getQueryCache().get(o.queryHash)) == null ? void 0 : v.promise; S == null || S.catch(Wu).finally(() => { l.updateResult() }) } return o.notifyOnChangeProps ? u : l.trackResult(u) } function V1(e, t) { return F1(e, P1) } function z1(e, t) { const n = zg(), [r] = y.useState(() => new k1(n, e)); y.useEffect(() => { r.setOptions(e) }, [r, e]); const s = y.useSyncExternalStore(y.useCallback(o => r.subscribe(ye.batchCalls(o)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()), i = y.useCallback((o, a) => { r.mutate(o, a).catch(Wu) }, [r]); if (s.error && Bg(r.options.throwOnError, [s.error])) throw s.error; return { ...s, mutate: i, mutateAsync: s.mutate } } const U1 = new C1({ defaultOptions: { queries: { queryFn: async ({ queryKey: e }) => { const t = await fetch(e[0], { credentials: "include" }); if (!t.ok) throw t.status >= 500 ? new Error(`${t.status}: ${t.statusText}`) : new Error(`${t.status}: ${await t.text()}`); return t.json() }, refetchInterval: !1, refetchOnWindowFocus: !1, staleTime: 1e3 * 60, retry: !1 }, mutations: { retry: !1 } } }), B1 = 1, $1 = 1e6; let Sl = 0; function W1() { return Sl = (Sl + 1) % Number.MAX_SAFE_INTEGER, Sl.toString() } const Cl = new Map, bh = e => { if (Cl.has(e)) return; const t = setTimeout(() => { Cl.delete(e), ei({ type: "REMOVE_TOAST", toastId: e }) }, $1); Cl.set(e, t) }, H1 = (e, t) => { switch (t.type) { case "ADD_TOAST": return { ...e, toasts: [t.toast, ...e.toasts].slice(0, B1) }; case "UPDATE_TOAST": return { ...e, toasts: e.toasts.map(n => n.id === t.toast.id ? { ...n, ...t.toast } : n) }; case "DISMISS_TOAST": { const { toastId: n } = t; return n ? bh(n) : e.toasts.forEach(r => { bh(r.id) }), { ...e, toasts: e.toasts.map(r => r.id === n || n === void 0 ? { ...r, open: !1 } : r) } } case "REMOVE_TOAST": return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(n => n.id !== t.toastId) } } }, No = []; let Lo = { toasts: [] }; function ei(e) { Lo = H1(Lo, e), No.forEach(t => { t(Lo) }) } function K1({ ...e }) { const t = W1(), n = s => ei({ type: "UPDATE_TOAST", toast: { ...s, id: t } }), r = () => ei({ type: "DISMISS_TOAST", toastId: t }); return ei({ type: "ADD_TOAST", toast: { ...e, id: t, open: !0, onOpenChange: s => { s || r() } } }), { id: t, dismiss: r, update: n } } function Q1() { const [e, t] = y.useState(Lo); return y.useEffect(() => (No.push(t), () => { const n = No.indexOf(t); n > -1 && No.splice(n, 1) }), [e]), { ...e, toast: K1, dismiss: n => ei({ type: "DISMISS_TOAST", toastId: n }) } } function pe(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (s) { if (e == null || e(s), n === !1 || !s.defaultPrevented) return t == null ? void 0 : t(s) } } function Ah(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function $g(...e) { return t => { let n = !1; const r = e.map(s => { const i = Ah(s, t); return !n && typeof i == "function" && (n = !0), i }); if (n) return () => { for (let s = 0; s < r.length; s++) { const i = r[s]; typeof i == "function" ? i() : Ah(e[s], null) } } } } function tt(...e) { return y.useCallback($g(...e), e) } function fd(e, t = []) { let n = []; function r(i, o) { const a = y.createContext(o), l = n.length; n = [...n, o]; const u = d => { var p; const { scope: f, children: m, ...x } = d, v = ((p = f == null ? void 0 : f[e]) == null ? void 0 : p[l]) || a, S = y.useMemo(() => x, Object.values(x)); return w.jsx(v.Provider, { value: S, children: m }) }; u.displayName = i + "Provider"; function c(d, f) { var v; const m = ((v = f == null ? void 0 : f[e]) == null ? void 0 : v[l]) || a, x = y.useContext(m); if (x) return x; if (o !== void 0) return o; throw new Error(`\`${d}\` must be used within \`${i}\``) } return [u, c] } const s = () => { const i = n.map(o => y.createContext(o)); return function (a) { const l = (a == null ? void 0 : a[e]) || i; return y.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l]) } }; return s.scopeName = e, [r, G1(s, ...t)] } function G1(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(s => ({ useScope: s(), scopeName: s.scopeName })); return function (i) { const o = r.reduce((a, { useScope: l, scopeName: u }) => { const d = l(i)[`__scope${u}`]; return { ...a, ...d } }, {}); return y.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]) } }; return n.scopeName = t.scopeName, n } var Pi = y.forwardRef((e, t) => { const { children: n, ...r } = e, s = y.Children.toArray(n), i = s.find(Y1); if (i) { const o = i.props.children, a = s.map(l => l === i ? y.Children.count(o) > 1 ? y.Children.only(null) : y.isValidElement(o) ? o.props.children : null : l); return w.jsx(Hu, { ...r, ref: t, children: y.isValidElement(o) ? y.cloneElement(o, void 0, a) : null }) } return w.jsx(Hu, { ...r, ref: t, children: n }) }); Pi.displayName = "Slot"; var Hu = y.forwardRef((e, t) => { const { children: n, ...r } = e; if (y.isValidElement(n)) { const s = Z1(n); return y.cloneElement(n, { ...q1(r, n.props), ref: t ? $g(t, s) : s }) } return y.Children.count(n) > 1 ? y.Children.only(null) : null }); Hu.displayName = "SlotClone"; var X1 = ({ children: e }) => w.jsx(w.Fragment, { children: e }); function Y1(e) { return y.isValidElement(e) && e.type === X1 } function q1(e, t) { const n = { ...t }; for (const r in t) { const s = e[r], i = t[r]; /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => { i(...a), s(...a) } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...i } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" ")) } return { ...e, ...n } } function Z1(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function J1(e) { const t = e + "CollectionProvider", [n, r] = fd(t), [s, i] = n(t, { collectionRef: { current: null }, itemMap: new Map }), o = m => { const { scope: x, children: v } = m, S = cn.useRef(null), p = cn.useRef(new Map).current; return w.jsx(s, { scope: x, itemMap: p, collectionRef: S, children: v }) }; o.displayName = t; const a = e + "CollectionSlot", l = cn.forwardRef((m, x) => { const { scope: v, children: S } = m, p = i(a, v), h = tt(x, p.collectionRef); return w.jsx(Pi, { ref: h, children: S }) }); l.displayName = a; const u = e + "CollectionItemSlot", c = "data-radix-collection-item", d = cn.forwardRef((m, x) => { const { scope: v, children: S, ...p } = m, h = cn.useRef(null), g = tt(x, h), P = i(u, v); return cn.useEffect(() => (P.itemMap.set(h, { ref: h, ...p }), () => void P.itemMap.delete(h))), w.jsx(Pi, { [c]: "", ref: g, children: S }) }); d.displayName = u; function f(m) { const x = i(e + "CollectionConsumer", m); return cn.useCallback(() => { const S = x.collectionRef.current; if (!S) return []; const p = Array.from(S.querySelectorAll(`[${c}]`)); return Array.from(x.itemMap.values()).sort((P, E) => p.indexOf(P.ref.current) - p.indexOf(E.ref.current)) }, [x.collectionRef, x.itemMap]) } return [{ Provider: o, Slot: l, ItemSlot: d }, f, r] } var eC = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], Be = eC.reduce((e, t) => { const n = y.forwardRef((r, s) => { const { asChild: i, ...o } = r, a = i ? Pi : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), w.jsx(a, { ...o, ref: s }) }); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }, {}); function Wg(e, t) { e && ja.flushSync(() => e.dispatchEvent(t)) } function Ne(e) { const t = y.useRef(e); return y.useEffect(() => { t.current = e }), y.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function tC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Ne(e); y.useEffect(() => { const r = s => { s.key === "Escape" && n(s) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var nC = "DismissableLayer", Ku = "dismissableLayer.update", rC = "dismissableLayer.pointerDownOutside", sC = "dismissableLayer.focusOutside", Mh, Hg = y.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), Kg = y.forwardRef((e, t) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l } = e, u = y.useContext(Hg), [c, d] = y.useState(null), f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, m] = y.useState({}), x = tt(t, k => d(k)), v = Array.from(u.layers), [S] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), p = v.indexOf(S), h = c ? v.indexOf(c) : -1, g = u.layersWithOutsidePointerEventsDisabled.size > 0, P = h >= p, E = oC(k => { const T = k.target, b = [...u.branches].some(M => M.contains(T)); !P || b || (s == null || s(k), o == null || o(k), k.defaultPrevented || a == null || a()) }, f), R = aC(k => { const T = k.target;[...u.branches].some(M => M.contains(T)) || (i == null || i(k), o == null || o(k), k.defaultPrevented || a == null || a()) }, f); return tC(k => { h === u.layers.size - 1 && (r == null || r(k), !k.defaultPrevented && a && (k.preventDefault(), a())) }, f), y.useEffect(() => { if (c) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (Mh = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), Dh(), () => { n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = Mh) } }, [c, f, n, u]), y.useEffect(() => () => { c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), Dh()) }, [c, u]), y.useEffect(() => { const k = () => m({}); return document.addEventListener(Ku, k), () => document.removeEventListener(Ku, k) }, []), w.jsx(Be.div, { ...l, ref: x, style: { pointerEvents: g ? P ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: pe(e.onFocusCapture, R.onFocusCapture), onBlurCapture: pe(e.onBlurCapture, R.onBlurCapture), onPointerDownCapture: pe(e.onPointerDownCapture, E.onPointerDownCapture) }) }); Kg.displayName = nC; var iC = "DismissableLayerBranch", Qg = y.forwardRef((e, t) => { const n = y.useContext(Hg), r = y.useRef(null), s = tt(t, r); return y.useEffect(() => { const i = r.current; if (i) return n.branches.add(i), () => { n.branches.delete(i) } }, [n.branches]), w.jsx(Be.div, { ...e, ref: s }) }); Qg.displayName = iC; function oC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Ne(e), r = y.useRef(!1), s = y.useRef(() => { }); return y.useEffect(() => { const i = a => { if (a.target && !r.current) { let l = function () { Gg(rC, n, u, { discrete: !0 }) }; const u = { originalEvent: a }; a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, { once: !0 })) : l() } else t.removeEventListener("click", s.current); r.current = !1 }, o = window.setTimeout(() => { t.addEventListener("pointerdown", i) }, 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", s.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function aC(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Ne(e), r = y.useRef(!1); return y.useEffect(() => { const s = i => { i.target && !r.current && Gg(sC, n, { originalEvent: i }, { discrete: !1 }) }; return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function Dh() { const e = new CustomEvent(Ku); document.dispatchEvent(e) } function Gg(e, t, n, { discrete: r }) { const s = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Wg(s, i) : s.dispatchEvent(i) } var lC = Kg, uC = Qg, Ei = globalThis != null && globalThis.document ? y.useLayoutEffect : () => { }, cC = "Portal", Xg = y.forwardRef((e, t) => { var a; const { container: n, ...r } = e, [s, i] = y.useState(!1); Ei(() => i(!0), []); const o = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body); return o ? a1.createPortal(w.jsx(Be.div, { ...r, ref: t }), o) : null }); Xg.displayName = cC; function dC(e, t) { return y.useReducer((n, r) => t[n][r] ?? n, e) } var Ss = e => { const { present: t, children: n } = e, r = fC(t), s = typeof n == "function" ? n({ present: r.isPresent }) : y.Children.only(n), i = tt(r.ref, hC(s)); return typeof n == "function" || r.isPresent ? y.cloneElement(s, { ref: i }) : null }; Ss.displayName = "Presence"; function fC(e) { const [t, n] = y.useState(), r = y.useRef({}), s = y.useRef(e), i = y.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = dC(o, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return y.useEffect(() => { const u = ho(r.current); i.current = a === "mounted" ? u : "none" }, [a]), Ei(() => { const u = r.current, c = s.current; if (c !== e) { const f = i.current, m = ho(u); e ? l("MOUNT") : m === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && f !== m ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e } }, [e, l]), Ei(() => { if (t) { let u; const c = t.ownerDocument.defaultView ?? window, d = m => { const v = ho(r.current).includes(m.animationName); if (m.target === t && v && (l("ANIMATION_END"), !s.current)) { const S = t.style.animationFillMode; t.style.animationFillMode = "forwards", u = c.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = S) }) } }, f = m => { m.target === t && (i.current = ho(r.current)) }; return t.addEventListener("animationstart", f), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => { c.clearTimeout(u), t.removeEventListener("animationstart", f), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d) } } else l("ANIMATION_END") }, [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(a), ref: y.useCallback(u => { u && (r.current = getComputedStyle(u)), n(u) }, []) } } function ho(e) { return (e == null ? void 0 : e.animationName) || "none" } function hC(e) { var r, s; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function pC({ prop: e, defaultProp: t, onChange: n = () => { } }) { const [r, s] = mC({ defaultProp: t, onChange: n }), i = e !== void 0, o = i ? e : r, a = Ne(n), l = y.useCallback(u => { if (i) { const d = typeof u == "function" ? u(e) : u; d !== e && a(d) } else s(u) }, [i, e, s, a]); return [o, l] } function mC({ defaultProp: e, onChange: t }) { const n = y.useState(e), [r] = n, s = y.useRef(r), i = Ne(t); return y.useEffect(() => { s.current !== r && (i(r), s.current = r) }, [r, s, i]), n } var yC = "VisuallyHidden", hd = y.forwardRef((e, t) => w.jsx(Be.span, { ...e, ref: t, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...e.style } })); hd.displayName = yC; var pd = "ToastProvider", [md, gC, vC] = J1("Toast"), [Yg, a2] = fd("Toast", [vC]), [wC, Oa] = Yg(pd), qg = e => { const { __scopeToast: t, label: n = "Notification", duration: r = 5e3, swipeDirection: s = "right", swipeThreshold: i = 50, children: o } = e, [a, l] = y.useState(null), [u, c] = y.useState(0), d = y.useRef(!1), f = y.useRef(!1); return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${pd}\`. Expected non-empty \`string\`.`), w.jsx(md.Provider, { scope: t, children: w.jsx(wC, { scope: t, label: n, duration: r, swipeDirection: s, swipeThreshold: i, toastCount: u, viewport: a, onViewportChange: l, onToastAdd: y.useCallback(() => c(m => m + 1), []), onToastRemove: y.useCallback(() => c(m => m - 1), []), isFocusedToastEscapeKeyDownRef: d, isClosePausedRef: f, children: o }) }) }; qg.displayName = pd; var Zg = "ToastViewport", xC = ["F8"], Qu = "toast.viewportPause", Gu = "toast.viewportResume", Jg = y.forwardRef((e, t) => { const { __scopeToast: n, hotkey: r = xC, label: s = "Notifications ({hotkey})", ...i } = e, o = Oa(Zg, n), a = gC(n), l = y.useRef(null), u = y.useRef(null), c = y.useRef(null), d = y.useRef(null), f = tt(t, d, o.onViewportChange), m = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), x = o.toastCount > 0; y.useEffect(() => { const S = p => { var g; r.length !== 0 && r.every(P => p[P] || p.code === P) && ((g = d.current) == null || g.focus()) }; return document.addEventListener("keydown", S), () => document.removeEventListener("keydown", S) }, [r]), y.useEffect(() => { const S = l.current, p = d.current; if (x && S && p) { const h = () => { if (!o.isClosePausedRef.current) { const R = new CustomEvent(Qu); p.dispatchEvent(R), o.isClosePausedRef.current = !0 } }, g = () => { if (o.isClosePausedRef.current) { const R = new CustomEvent(Gu); p.dispatchEvent(R), o.isClosePausedRef.current = !1 } }, P = R => { !S.contains(R.relatedTarget) && g() }, E = () => { S.contains(document.activeElement) || g() }; return S.addEventListener("focusin", h), S.addEventListener("focusout", P), S.addEventListener("pointermove", h), S.addEventListener("pointerleave", E), window.addEventListener("blur", h), window.addEventListener("focus", g), () => { S.removeEventListener("focusin", h), S.removeEventListener("focusout", P), S.removeEventListener("pointermove", h), S.removeEventListener("pointerleave", E), window.removeEventListener("blur", h), window.removeEventListener("focus", g) } } }, [x, o.isClosePausedRef]); const v = y.useCallback(({ tabbingDirection: S }) => { const h = a().map(g => { const P = g.ref.current, E = [P, ...LC(P)]; return S === "forwards" ? E : E.reverse() }); return (S === "forwards" ? h.reverse() : h).flat() }, [a]); return y.useEffect(() => { const S = d.current; if (S) { const p = h => { var E, R, k; const g = h.altKey || h.ctrlKey || h.metaKey; if (h.key === "Tab" && !g) { const T = document.activeElement, b = h.shiftKey; if (h.target === S && b) { (E = u.current) == null || E.focus(); return } const j = v({ tabbingDirection: b ? "backwards" : "forwards" }), Oe = j.findIndex(z => z === T); Pl(j.slice(Oe + 1)) ? h.preventDefault() : b ? (R = u.current) == null || R.focus() : (k = c.current) == null || k.focus() } }; return S.addEventListener("keydown", p), () => S.removeEventListener("keydown", p) } }, [a, v]), w.jsxs(uC, { ref: l, role: "region", "aria-label": s.replace("{hotkey}", m), tabIndex: -1, style: { pointerEvents: x ? void 0 : "none" }, children: [x && w.jsx(Xu, { ref: u, onFocusFromOutsideViewport: () => { const S = v({ tabbingDirection: "forwards" }); Pl(S) } }), w.jsx(md.Slot, { scope: n, children: w.jsx(Be.ol, { tabIndex: -1, ...i, ref: f }) }), x && w.jsx(Xu, { ref: c, onFocusFromOutsideViewport: () => { const S = v({ tabbingDirection: "backwards" }); Pl(S) } })] }) }); Jg.displayName = Zg; var ev = "ToastFocusProxy", Xu = y.forwardRef((e, t) => { const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = e, i = Oa(ev, n); return w.jsx(hd, { "aria-hidden": !0, tabIndex: 0, ...s, ref: t, style: { position: "fixed" }, onFocus: o => { var u; const a = o.relatedTarget; !((u = i.viewport) != null && u.contains(a)) && r() } }) }); Xu.displayName = ev; var _a = "Toast", SC = "toast.swipeStart", CC = "toast.swipeMove", PC = "toast.swipeCancel", EC = "toast.swipeEnd", tv = y.forwardRef((e, t) => { const { forceMount: n, open: r, defaultOpen: s, onOpenChange: i, ...o } = e, [a = !0, l] = pC({ prop: r, defaultProp: s, onChange: i }); return w.jsx(Ss, { present: n || a, children: w.jsx(RC, { open: a, ...o, ref: t, onClose: () => l(!1), onPause: Ne(e.onPause), onResume: Ne(e.onResume), onSwipeStart: pe(e.onSwipeStart, u => { u.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: pe(e.onSwipeMove, u => { const { x: c, y: d } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`) }), onSwipeCancel: pe(e.onSwipeCancel, u => { u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y") }), onSwipeEnd: pe(e.onSwipeEnd, u => { const { x: c, y: d } = u.detail.delta; u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), l(!1) }) }) }) }); tv.displayName = _a; var [TC, kC] = Yg(_a, { onClose() { } }), RC = y.forwardRef((e, t) => { const { __scopeToast: n, type: r = "foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: u, onSwipeStart: c, onSwipeMove: d, onSwipeCancel: f, onSwipeEnd: m, ...x } = e, v = Oa(_a, n), [S, p] = y.useState(null), h = tt(t, z => p(z)), g = y.useRef(null), P = y.useRef(null), E = s || v.duration, R = y.useRef(0), k = y.useRef(E), T = y.useRef(0), { onToastAdd: b, onToastRemove: M } = v, F = Ne(() => { var ve; (S == null ? void 0 : S.contains(document.activeElement)) && ((ve = v.viewport) == null || ve.focus()), o() }), j = y.useCallback(z => { !z || z === 1 / 0 || (window.clearTimeout(T.current), R.current = new Date().getTime(), T.current = window.setTimeout(F, z)) }, [F]); y.useEffect(() => { const z = v.viewport; if (z) { const ve = () => { j(k.current), u == null || u() }, we = () => { const X = new Date().getTime() - R.current; k.current = k.current - X, window.clearTimeout(T.current), l == null || l() }; return z.addEventListener(Qu, we), z.addEventListener(Gu, ve), () => { z.removeEventListener(Qu, we), z.removeEventListener(Gu, ve) } } }, [v.viewport, E, l, u, j]), y.useEffect(() => { i && !v.isClosePausedRef.current && j(E) }, [i, E, v.isClosePausedRef, j]), y.useEffect(() => (b(), () => M()), [b, M]); const Oe = y.useMemo(() => S ? lv(S) : null, [S]); return v.viewport ? w.jsxs(w.Fragment, { children: [Oe && w.jsx(bC, { __scopeToast: n, role: "status", "aria-live": r === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: Oe }), w.jsx(TC, { scope: n, onClose: F, children: ja.createPortal(w.jsx(md.ItemSlot, { scope: n, children: w.jsx(lC, { asChild: !0, onEscapeKeyDown: pe(a, () => { v.isFocusedToastEscapeKeyDownRef.current || F(), v.isFocusedToastEscapeKeyDownRef.current = !1 }), children: w.jsx(Be.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": i ? "open" : "closed", "data-swipe-direction": v.swipeDirection, ...x, ref: h, style: { userSelect: "none", touchAction: "none", ...e.style }, onKeyDown: pe(e.onKeyDown, z => { z.key === "Escape" && (a == null || a(z.nativeEvent), z.nativeEvent.defaultPrevented || (v.isFocusedToastEscapeKeyDownRef.current = !0, F())) }), onPointerDown: pe(e.onPointerDown, z => { z.button === 0 && (g.current = { x: z.clientX, y: z.clientY }) }), onPointerMove: pe(e.onPointerMove, z => { if (!g.current) return; const ve = z.clientX - g.current.x, we = z.clientY - g.current.y, X = !!P.current, D = ["left", "right"].includes(v.swipeDirection), O = ["left", "up"].includes(v.swipeDirection) ? Math.min : Math.max, V = D ? O(0, ve) : 0, H = D ? 0 : O(0, we), ae = z.pointerType === "touch" ? 10 : 2, Ut = { x: V, y: H }, Rt = { originalEvent: z, delta: Ut }; X ? (P.current = Ut, po(CC, d, Rt, { discrete: !1 })) : Nh(Ut, v.swipeDirection, ae) ? (P.current = Ut, po(SC, c, Rt, { discrete: !1 }), z.target.setPointerCapture(z.pointerId)) : (Math.abs(ve) > ae || Math.abs(we) > ae) && (g.current = null) }), onPointerUp: pe(e.onPointerUp, z => { const ve = P.current, we = z.target; if (we.hasPointerCapture(z.pointerId) && we.releasePointerCapture(z.pointerId), P.current = null, g.current = null, ve) { const X = z.currentTarget, D = { originalEvent: z, delta: ve }; Nh(ve, v.swipeDirection, v.swipeThreshold) ? po(EC, m, D, { discrete: !0 }) : po(PC, f, D, { discrete: !0 }), X.addEventListener("click", O => O.preventDefault(), { once: !0 }) } }) }) }) }), v.viewport) })] }) : null }), bC = e => { const { __scopeToast: t, children: n, ...r } = e, s = Oa(_a, t), [i, o] = y.useState(!1), [a, l] = y.useState(!1); return DC(() => o(!0)), y.useEffect(() => { const u = window.setTimeout(() => l(!0), 1e3); return () => window.clearTimeout(u) }, []), a ? null : w.jsx(Xg, { asChild: !0, children: w.jsx(hd, { ...r, children: i && w.jsxs(w.Fragment, { children: [s.label, " ", n] }) }) }) }, AC = "ToastTitle", nv = y.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return w.jsx(Be.div, { ...r, ref: t }) }); nv.displayName = AC; var MC = "ToastDescription", rv = y.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e; return w.jsx(Be.div, { ...r, ref: t }) }); rv.displayName = MC; var sv = "ToastAction", iv = y.forwardRef((e, t) => { const { altText: n, ...r } = e; return n.trim() ? w.jsx(av, { altText: n, asChild: !0, children: w.jsx(yd, { ...r, ref: t }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${sv}\`. Expected non-empty \`string\`.`), null) }); iv.displayName = sv; var ov = "ToastClose", yd = y.forwardRef((e, t) => { const { __scopeToast: n, ...r } = e, s = kC(ov, n); return w.jsx(av, { asChild: !0, children: w.jsx(Be.button, { type: "button", ...r, ref: t, onClick: pe(e.onClick, s.onClose) }) }) }); yd.displayName = ov; var av = y.forwardRef((e, t) => { const { __scopeToast: n, altText: r, ...s } = e; return w.jsx(Be.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": r || void 0, ...s, ref: t }) }); function lv(e) { const t = []; return Array.from(e.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), NC(r)) { const s = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === ""; if (!s) if (i) { const o = r.dataset.radixToastAnnounceAlt; o && t.push(o) } else t.push(...lv(r)) } }), t } function po(e, t, n, { discrete: r }) { const s = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n }); t && s.addEventListener(e, t, { once: !0 }), r ? Wg(s, i) : s.dispatchEvent(i) } var Nh = (e, t, n = 0) => { const r = Math.abs(e.x), s = Math.abs(e.y), i = r > s; return t === "left" || t === "right" ? i && r > n : !i && s > n }; function DC(e = () => { }) { const t = Ne(e); Ei(() => { let n = 0, r = 0; return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => { window.cancelAnimationFrame(n), window.cancelAnimationFrame(r) } }, [t]) } function NC(e) { return e.nodeType === e.ELEMENT_NODE } function LC(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const s = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function Pl(e) { const t = document.activeElement; return e.some(n => n === t ? !0 : (n.focus(), document.activeElement !== t)) } var jC = qg, uv = Jg, cv = tv, dv = nv, fv = rv, hv = iv, pv = yd; function mv(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var s = e.length; for (t = 0; t < s; t++)e[t] && (n = mv(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function yv() { for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = mv(e)) && (r && (r += " "), r += t); return r } const Lh = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, jh = yv, gd = (e, t) => n => { var r; if ((t == null ? void 0 : t.variants) == null) return jh(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className); const { variants: s, defaultVariants: i } = t, o = Object.keys(s).map(u => { const c = n == null ? void 0 : n[u], d = i == null ? void 0 : i[u]; if (c === null) return null; const f = Lh(c) || Lh(d); return s[u][f] }), a = n && Object.entries(n).reduce((u, c) => { let [d, f] = c; return f === void 0 || (u[d] = f), u }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => { let { class: d, className: f, ...m } = c; return Object.entries(m).every(x => { let [v, S] = x; return Array.isArray(S) ? S.includes({ ...i, ...a }[v]) : { ...i, ...a }[v] === S }) ? [...u, d, f] : u }, []); return jh(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className) };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const OC = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), gv = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var _C = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const IC = y.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: s = "", children: i, iconNode: o, ...a }, l) => y.createElement("svg", { ref: l, ..._C, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: gv("lucide", s), ...a }, [...o.map(([u, c]) => y.createElement(u, c)), ...Array.isArray(i) ? i : [i]]));/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vt = (e, t) => { const n = y.forwardRef(({ className: r, ...s }, i) => y.createElement(IC, { ref: i, iconNode: t, className: gv(`lucide-${OC(e)}`, r), ...s })); return n.displayName = `${e}`, n };/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const FC = Vt("ArrowLeft", [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vv = Vt("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const VC = Vt("ExternalLink", [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zC = Vt("Link2", [["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }], ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }], ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wv = Vt("LoaderCircle", [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const UC = Vt("MessageSquarePlus", [["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }], ["path", { d: "M12 7v6", key: "lw1j43" }], ["path", { d: "M9 10h6", key: "9gxzsh" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const BC = Vt("Moon", [["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xv = Vt("Search", [["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }], ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $C = Vt("Sun", [["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }], ["path", { d: "M12 2v2", key: "tus03m" }], ["path", { d: "M12 20v2", key: "1lh1kg" }], ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }], ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }], ["path", { d: "M2 12h2", key: "1t8f8n" }], ["path", { d: "M20 12h2", key: "1q8mjw" }], ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }], ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]]);/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const WC = Vt("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), vd = "-", HC = e => { const t = QC(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: o => { const a = o.split(vd); return a[0] === "" && a.length !== 1 && a.shift(), Sv(a, t) || KC(o) }, getConflictingClassGroupIds: (o, a) => { const l = n[o] || []; return a && r[o] ? [...l, ...r[o]] : l } } }, Sv = (e, t) => { var o; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), s = r ? Sv(e.slice(1), r) : void 0; if (s) return s; if (t.validators.length === 0) return; const i = e.join(vd); return (o = t.validators.find(({ validator: a }) => a(i))) == null ? void 0 : o.classGroupId }, Oh = /^\[(.+)\]$/, KC = e => { if (Oh.test(e)) { const t = Oh.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, QC = e => { const { theme: t, prefix: n } = e, r = { nextPart: new Map, validators: [] }; return XC(Object.entries(e.classGroups), n).forEach(([i, o]) => { Yu(o, r, i, t) }), r }, Yu = (e, t, n, r) => { e.forEach(s => { if (typeof s == "string") { const i = s === "" ? t : _h(t, s); i.classGroupId = n; return } if (typeof s == "function") { if (GC(s)) { Yu(s(r), t, n, r); return } t.validators.push({ validator: s, classGroupId: n }); return } Object.entries(s).forEach(([i, o]) => { Yu(o, _h(t, i), n, r) }) }) }, _h = (e, t) => { let n = e; return t.split(vd).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, GC = e => e.isThemeGetter, XC = (e, t) => t ? e.map(([n, r]) => { const s = r.map(i => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [t + o, a])) : i); return [n, s] }) : e, YC = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const s = (i, o) => { n.set(i, o), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(i) { let o = n.get(i); if (o !== void 0) return o; if ((o = r.get(i)) !== void 0) return s(i, o), o }, set(i, o) { n.has(i) ? n.set(i, o) : s(i, o) } } }, Cv = "!", qC = e => { const { separator: t, experimentalParseClassName: n } = e, r = t.length === 1, s = t[0], i = t.length, o = a => { const l = []; let u = 0, c = 0, d; for (let S = 0; S < a.length; S++) { let p = a[S]; if (u === 0) { if (p === s && (r || a.slice(S, S + i) === t)) { l.push(a.slice(c, S)), c = S + i; continue } if (p === "/") { d = S; continue } } p === "[" ? u++ : p === "]" && u-- } const f = l.length === 0 ? a : a.substring(c), m = f.startsWith(Cv), x = m ? f.substring(1) : f, v = d && d > c ? d - c : void 0; return { modifiers: l, hasImportantModifier: m, baseClassName: x, maybePostfixModifierPosition: v } }; return n ? a => n({ className: a, parseClassName: o }) : o }, ZC = e => { if (e.length <= 1) return e; const t = []; let n = []; return e.forEach(r => { r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r) }), t.push(...n.sort()), t }, JC = e => ({ cache: YC(e.cacheSize), parseClassName: qC(e), ...HC(e) }), eP = /\s+/, tP = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s } = t, i = [], o = e.trim().split(eP); let a = ""; for (let l = o.length - 1; l >= 0; l -= 1) { const u = o[l], { modifiers: c, hasImportantModifier: d, baseClassName: f, maybePostfixModifierPosition: m } = n(u); let x = !!m, v = r(x ? f.substring(0, m) : f); if (!v) { if (!x) { a = u + (a.length > 0 ? " " + a : a); continue } if (v = r(f), !v) { a = u + (a.length > 0 ? " " + a : a); continue } x = !1 } const S = ZC(c).join(":"), p = d ? S + Cv : S, h = p + v; if (i.includes(h)) continue; i.push(h); const g = s(v, x); for (let P = 0; P < g.length; ++P) { const E = g[P]; i.push(p + E) } a = u + (a.length > 0 ? " " + a : a) } return a }; function nP() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = Pv(t)) && (r && (r += " "), r += n); return r } const Pv = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = Pv(e[r])) && (n && (n += " "), n += t); return n }; function rP(e, ...t) { let n, r, s, i = o; function o(l) { const u = t.reduce((c, d) => d(c), e()); return n = JC(u), r = n.cache.get, s = n.cache.set, i = a, a(l) } function a(l) { const u = r(l); if (u) return u; const c = tP(l, n); return s(l, c), c } return function () { return i(nP.apply(null, arguments)) } } const Z = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, Ev = /^\[(?:([a-z-]+):)?(.+)\]$/i, sP = /^\d+\/\d+$/, iP = new Set(["px", "full", "screen"]), oP = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, aP = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, lP = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, uP = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, cP = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Bt = e => Hr(e) || iP.has(e) || sP.test(e), ln = e => Cs(e, "length", vP), Hr = e => !!e && !Number.isNaN(Number(e)), El = e => Cs(e, "number", Hr), js = e => !!e && Number.isInteger(Number(e)), dP = e => e.endsWith("%") && Hr(e.slice(0, -1)), U = e => Ev.test(e), un = e => oP.test(e), fP = new Set(["length", "size", "percentage"]), hP = e => Cs(e, fP, Tv), pP = e => Cs(e, "position", Tv), mP = new Set(["image", "url"]), yP = e => Cs(e, mP, xP), gP = e => Cs(e, "", wP), Os = () => !0, Cs = (e, t, n) => { const r = Ev.exec(e); return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1 }, vP = e => aP.test(e) && !lP.test(e), Tv = () => !1, wP = e => uP.test(e), xP = e => cP.test(e), SP = () => { const e = Z("colors"), t = Z("spacing"), n = Z("blur"), r = Z("brightness"), s = Z("borderColor"), i = Z("borderRadius"), o = Z("borderSpacing"), a = Z("borderWidth"), l = Z("contrast"), u = Z("grayscale"), c = Z("hueRotate"), d = Z("invert"), f = Z("gap"), m = Z("gradientColorStops"), x = Z("gradientColorStopPositions"), v = Z("inset"), S = Z("margin"), p = Z("opacity"), h = Z("padding"), g = Z("saturate"), P = Z("scale"), E = Z("sepia"), R = Z("skew"), k = Z("space"), T = Z("translate"), b = () => ["auto", "contain", "none"], M = () => ["auto", "hidden", "clip", "visible", "scroll"], F = () => ["auto", U, t], j = () => [U, t], Oe = () => ["", Bt, ln], z = () => ["auto", Hr, U], ve = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], we = () => ["solid", "dashed", "dotted", "double", "none"], X = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], D = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], O = () => ["", "0", U], V = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], H = () => [Hr, U]; return { cacheSize: 500, separator: ":", theme: { colors: [Os], spacing: [Bt, ln], blur: ["none", "", un, U], brightness: H(), borderColor: [e], borderRadius: ["none", "", "full", un, U], borderSpacing: j(), borderWidth: Oe(), contrast: H(), grayscale: O(), hueRotate: H(), invert: O(), gap: j(), gradientColorStops: [e], gradientColorStopPositions: [dP, ln], inset: F(), margin: F(), opacity: H(), padding: j(), saturate: H(), scale: H(), sepia: O(), skew: H(), space: j(), translate: j() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", U] }], container: ["container"], columns: [{ columns: [un] }], "break-after": [{ "break-after": V() }], "break-before": [{ "break-before": V() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...ve(), U] }], overflow: [{ overflow: M() }], "overflow-x": [{ "overflow-x": M() }], "overflow-y": [{ "overflow-y": M() }], overscroll: [{ overscroll: b() }], "overscroll-x": [{ "overscroll-x": b() }], "overscroll-y": [{ "overscroll-y": b() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [v] }], "inset-x": [{ "inset-x": [v] }], "inset-y": [{ "inset-y": [v] }], start: [{ start: [v] }], end: [{ end: [v] }], top: [{ top: [v] }], right: [{ right: [v] }], bottom: [{ bottom: [v] }], left: [{ left: [v] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", js, U] }], basis: [{ basis: F() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", U] }], grow: [{ grow: O() }], shrink: [{ shrink: O() }], order: [{ order: ["first", "last", "none", js, U] }], "grid-cols": [{ "grid-cols": [Os] }], "col-start-end": [{ col: ["auto", { span: ["full", js, U] }, U] }], "col-start": [{ "col-start": z() }], "col-end": [{ "col-end": z() }], "grid-rows": [{ "grid-rows": [Os] }], "row-start-end": [{ row: ["auto", { span: [js, U] }, U] }], "row-start": [{ "row-start": z() }], "row-end": [{ "row-end": z() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", U] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", U] }], gap: [{ gap: [f] }], "gap-x": [{ "gap-x": [f] }], "gap-y": [{ "gap-y": [f] }], "justify-content": [{ justify: ["normal", ...D()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...D(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...D(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [h] }], px: [{ px: [h] }], py: [{ py: [h] }], ps: [{ ps: [h] }], pe: [{ pe: [h] }], pt: [{ pt: [h] }], pr: [{ pr: [h] }], pb: [{ pb: [h] }], pl: [{ pl: [h] }], m: [{ m: [S] }], mx: [{ mx: [S] }], my: [{ my: [S] }], ms: [{ ms: [S] }], me: [{ me: [S] }], mt: [{ mt: [S] }], mr: [{ mr: [S] }], mb: [{ mb: [S] }], ml: [{ ml: [S] }], "space-x": [{ "space-x": [k] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [k] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", U, t] }], "min-w": [{ "min-w": [U, t, "min", "max", "fit"] }], "max-w": [{ "max-w": [U, t, "none", "full", "min", "max", "fit", "prose", { screen: [un] }, un] }], h: [{ h: [U, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [U, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [U, t, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [U, t, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", un, ln] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", El] }], "font-family": [{ font: [Os] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", U] }], "line-clamp": [{ "line-clamp": ["none", Hr, El] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Bt, U] }], "list-image": [{ "list-image": ["none", U] }], "list-style-type": [{ list: ["none", "disc", "decimal", U] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [e] }], "placeholder-opacity": [{ "placeholder-opacity": [p] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [e] }], "text-opacity": [{ "text-opacity": [p] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...we(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", Bt, ln] }], "underline-offset": [{ "underline-offset": ["auto", Bt, U] }], "text-decoration-color": [{ decoration: [e] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: j() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", U] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", U] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [p] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...ve(), pP] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", hP] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, yP] }], "bg-color": [{ bg: [e] }], "gradient-from-pos": [{ from: [x] }], "gradient-via-pos": [{ via: [x] }], "gradient-to-pos": [{ to: [x] }], "gradient-from": [{ from: [m] }], "gradient-via": [{ via: [m] }], "gradient-to": [{ to: [m] }], rounded: [{ rounded: [i] }], "rounded-s": [{ "rounded-s": [i] }], "rounded-e": [{ "rounded-e": [i] }], "rounded-t": [{ "rounded-t": [i] }], "rounded-r": [{ "rounded-r": [i] }], "rounded-b": [{ "rounded-b": [i] }], "rounded-l": [{ "rounded-l": [i] }], "rounded-ss": [{ "rounded-ss": [i] }], "rounded-se": [{ "rounded-se": [i] }], "rounded-ee": [{ "rounded-ee": [i] }], "rounded-es": [{ "rounded-es": [i] }], "rounded-tl": [{ "rounded-tl": [i] }], "rounded-tr": [{ "rounded-tr": [i] }], "rounded-br": [{ "rounded-br": [i] }], "rounded-bl": [{ "rounded-bl": [i] }], "border-w": [{ border: [a] }], "border-w-x": [{ "border-x": [a] }], "border-w-y": [{ "border-y": [a] }], "border-w-s": [{ "border-s": [a] }], "border-w-e": [{ "border-e": [a] }], "border-w-t": [{ "border-t": [a] }], "border-w-r": [{ "border-r": [a] }], "border-w-b": [{ "border-b": [a] }], "border-w-l": [{ "border-l": [a] }], "border-opacity": [{ "border-opacity": [p] }], "border-style": [{ border: [...we(), "hidden"] }], "divide-x": [{ "divide-x": [a] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [a] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [p] }], "divide-style": [{ divide: we() }], "border-color": [{ border: [s] }], "border-color-x": [{ "border-x": [s] }], "border-color-y": [{ "border-y": [s] }], "border-color-s": [{ "border-s": [s] }], "border-color-e": [{ "border-e": [s] }], "border-color-t": [{ "border-t": [s] }], "border-color-r": [{ "border-r": [s] }], "border-color-b": [{ "border-b": [s] }], "border-color-l": [{ "border-l": [s] }], "divide-color": [{ divide: [s] }], "outline-style": [{ outline: ["", ...we()] }], "outline-offset": [{ "outline-offset": [Bt, U] }], "outline-w": [{ outline: [Bt, ln] }], "outline-color": [{ outline: [e] }], "ring-w": [{ ring: Oe() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [e] }], "ring-opacity": [{ "ring-opacity": [p] }], "ring-offset-w": [{ "ring-offset": [Bt, ln] }], "ring-offset-color": [{ "ring-offset": [e] }], shadow: [{ shadow: ["", "inner", "none", un, gP] }], "shadow-color": [{ shadow: [Os] }], opacity: [{ opacity: [p] }], "mix-blend": [{ "mix-blend": [...X(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": X() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [n] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [l] }], "drop-shadow": [{ "drop-shadow": ["", "none", un, U] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [c] }], invert: [{ invert: [d] }], saturate: [{ saturate: [g] }], sepia: [{ sepia: [E] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [n] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [l] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [c] }], "backdrop-invert": [{ "backdrop-invert": [d] }], "backdrop-opacity": [{ "backdrop-opacity": [p] }], "backdrop-saturate": [{ "backdrop-saturate": [g] }], "backdrop-sepia": [{ "backdrop-sepia": [E] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [o] }], "border-spacing-x": [{ "border-spacing-x": [o] }], "border-spacing-y": [{ "border-spacing-y": [o] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", U] }], duration: [{ duration: H() }], ease: [{ ease: ["linear", "in", "out", "in-out", U] }], delay: [{ delay: H() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", U] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [P] }], "scale-x": [{ "scale-x": [P] }], "scale-y": [{ "scale-y": [P] }], rotate: [{ rotate: [js, U] }], "translate-x": [{ "translate-x": [T] }], "translate-y": [{ "translate-y": [T] }], "skew-x": [{ "skew-x": [R] }], "skew-y": [{ "skew-y": [R] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", U] }], accent: [{ accent: ["auto", e] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", U] }], "caret-color": [{ caret: [e] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": j() }], "scroll-mx": [{ "scroll-mx": j() }], "scroll-my": [{ "scroll-my": j() }], "scroll-ms": [{ "scroll-ms": j() }], "scroll-me": [{ "scroll-me": j() }], "scroll-mt": [{ "scroll-mt": j() }], "scroll-mr": [{ "scroll-mr": j() }], "scroll-mb": [{ "scroll-mb": j() }], "scroll-ml": [{ "scroll-ml": j() }], "scroll-p": [{ "scroll-p": j() }], "scroll-px": [{ "scroll-px": j() }], "scroll-py": [{ "scroll-py": j() }], "scroll-ps": [{ "scroll-ps": j() }], "scroll-pe": [{ "scroll-pe": j() }], "scroll-pt": [{ "scroll-pt": j() }], "scroll-pr": [{ "scroll-pr": j() }], "scroll-pb": [{ "scroll-pb": j() }], "scroll-pl": [{ "scroll-pl": j() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", U] }], fill: [{ fill: [e, "none"] }], "stroke-w": [{ stroke: [Bt, ln, El] }], stroke: [{ stroke: [e, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, CP = rP(SP); function Y(...e) { return CP(yv(e)) } const PP = jC, kv = y.forwardRef(({ className: e, ...t }, n) => w.jsx(uv, { ref: n, className: Y("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e), ...t })); kv.displayName = uv.displayName; const EP = gd("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), Rv = y.forwardRef(({ className: e, variant: t, ...n }, r) => w.jsx(cv, { ref: r, className: Y(EP({ variant: t }), e), ...n })); Rv.displayName = cv.displayName; const TP = y.forwardRef(({ className: e, ...t }, n) => w.jsx(hv, { ref: n, className: Y("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", e), ...t })); TP.displayName = hv.displayName; const bv = y.forwardRef(({ className: e, ...t }, n) => w.jsx(pv, { ref: n, className: Y("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e), "toast-close": "", ...t, children: w.jsx(WC, { className: "h-4 w-4" }) })); bv.displayName = pv.displayName; const Av = y.forwardRef(({ className: e, ...t }, n) => w.jsx(dv, { ref: n, className: Y("text-sm font-semibold", e), ...t })); Av.displayName = dv.displayName; const Mv = y.forwardRef(({ className: e, ...t }, n) => w.jsx(fv, { ref: n, className: Y("text-sm opacity-90", e), ...t })); Mv.displayName = fv.displayName; function kP() { const { toasts: e } = Q1(); return w.jsxs(PP, { children: [e.map(function ({ id: t, title: n, description: r, action: s, ...i }) { return w.jsxs(Rv, { ...i, children: [w.jsxs("div", { className: "grid gap-1", children: [n && w.jsx(Av, { children: n }), r && w.jsx(Mv, { children: r })] }), s, w.jsx(bv, {})] }, t) }), w.jsx(kv, {})] }) } function RP(e, t) { if (e instanceof RegExp) return { keys: !1, pattern: e }; var n, r, s, i, o = [], a = "", l = e.split("/"); for (l[0] || l.shift(); s = l.shift();)n = s[0], n === "*" ? (o.push(n), a += s[1] === "?" ? "(?:/(.*))?" : "/(.*)") : n === ":" ? (r = s.indexOf("?", 1), i = s.indexOf(".", 1), o.push(s.substring(1, ~r ? r : ~i ? i : s.length)), a += ~r && !~i ? "(?:/([^/]+?))?" : "/([^/]+?)", ~i && (a += (~r ? "?" : "") + "\\" + s.substring(i))) : a += "/" + s; return { keys: o, pattern: new RegExp("^" + a + (t ? "(?=$|/)" : "/?$"), "i") } } var Dv = { exports: {} }, Nv = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fs = y; function bP(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var AP = typeof Object.is == "function" ? Object.is : bP, MP = fs.useState, DP = fs.useEffect, NP = fs.useLayoutEffect, LP = fs.useDebugValue; function jP(e, t) { var n = t(), r = MP({ inst: { value: n, getSnapshot: t } }), s = r[0].inst, i = r[1]; return NP(function () { s.value = n, s.getSnapshot = t, Tl(s) && i({ inst: s }) }, [e, n, t]), DP(function () { return Tl(s) && i({ inst: s }), e(function () { Tl(s) && i({ inst: s }) }) }, [e]), LP(n), n } function Tl(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !AP(e, n) } catch { return !0 } } function OP(e, t) { return t() } var _P = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? OP : jP; Nv.useSyncExternalStore = fs.useSyncExternalStore !== void 0 ? fs.useSyncExternalStore : _P; Dv.exports = Nv; var IP = Dv.exports; const FP = qw.useInsertionEffect, VP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", zP = VP ? y.useLayoutEffect : y.useEffect, UP = FP || zP, Lv = e => { const t = y.useRef([e, (...n) => t[0](...n)]).current; return UP(() => { t[0] = e }), t[1] }, BP = "popstate", wd = "pushState", xd = "replaceState", $P = "hashchange", Ih = [BP, wd, xd, $P], WP = e => { for (const t of Ih) addEventListener(t, e); return () => { for (const t of Ih) removeEventListener(t, e) } }, jv = (e, t) => IP.useSyncExternalStore(WP, e, t), HP = () => location.search, KP = ({ ssrSearch: e = "" } = {}) => jv(HP, () => e), Fh = () => location.pathname, QP = ({ ssrPath: e } = {}) => jv(Fh, e ? () => e : Fh), GP = (e, { replace: t = !1, state: n = null } = {}) => history[t ? xd : wd](n, "", e), XP = (e = {}) => [QP(e), GP], Vh = Symbol.for("wouter_v3"); if (typeof history < "u" && typeof window[Vh] > "u") { for (const e of [wd, xd]) { const t = history[e]; history[e] = function () { const n = t.apply(this, arguments), r = new Event(e); return r.arguments = arguments, dispatchEvent(r), n } } Object.defineProperty(window, Vh, { value: !0 }) } const YP = (e, t) => t.toLowerCase().indexOf(e.toLowerCase()) ? "~" + t : t.slice(e.length) || "/", Ov = (e = "") => e === "/" ? "" : e, qP = (e, t) => e[0] === "~" ? e.slice(1) : Ov(t) + e, ZP = (e = "", t) => YP(zh(Ov(e)), zh(t)), zh = e => { try { return decodeURI(e) } catch { return e } }, _v = { hook: XP, searchHook: KP, parser: RP, base: "", ssrPath: void 0, ssrSearch: void 0, hrefs: e => e }, Iv = y.createContext(_v), zi = () => y.useContext(Iv), Fv = {}, Vv = y.createContext(Fv), JP = () => y.useContext(Vv), Ia = e => { const [t, n] = e.hook(e); return [ZP(e.base, t), Lv((r, s) => n(qP(r, e.base), s))] }, Sd = () => Ia(zi()), zv = (e, t, n, r) => { const { pattern: s, keys: i } = t instanceof RegExp ? { keys: !1, pattern: t } : e(t || "*", r), o = s.exec(n) || [], [a, ...l] = o; return a !== void 0 ? [!0, (() => { const u = i !== !1 ? Object.fromEntries(i.map((d, f) => [d, l[f]])) : o.groups; let c = { ...l }; return u && Object.assign(c, u), c })(), ...r ? [a] : []] : [!1, null] }, eE = ({ children: e, ...t }) => { var c, d; const n = zi(), r = t.hook ? _v : n; let s = r; const [i, o] = ((c = t.ssrPath) == null ? void 0 : c.split("?")) ?? []; o && (t.ssrSearch = o, t.ssrPath = i), t.hrefs = t.hrefs ?? ((d = t.hook) == null ? void 0 : d.hrefs); let a = y.useRef({}), l = a.current, u = l; for (let f in r) { const m = f === "base" ? r[f] + (t[f] || "") : t[f] || r[f]; l === u && m !== u[f] && (a.current = u = { ...u }), u[f] = m, m !== r[f] && (s = u) } return y.createElement(Iv.Provider, { value: s, children: e }) }, Uh = ({ children: e, component: t }, n) => t ? y.createElement(t, { params: n }) : typeof e == "function" ? e(n) : e, tE = e => { let t = y.useRef(Fv), n = t.current; for (const r in e) e[r] !== n[r] && (n = e); return Object.keys(e).length === 0 && (n = e), t.current = n }, kl = ({ path: e, nest: t, match: n, ...r }) => { const s = zi(), [i] = Ia(s), [o, a, l] = n ?? zv(s.parser, e, i, t), u = tE({ ...JP(), ...a }); if (!o) return null; const c = l ? y.createElement(eE, { base: l }, Uh(r, u)) : Uh(r, u); return y.createElement(Vv.Provider, { value: u, children: c }) }; y.forwardRef((e, t) => { const n = zi(), [r, s] = Ia(n), { to: i = "", href: o = i, onClick: a, asChild: l, children: u, className: c, replace: d, state: f, ...m } = e, x = Lv(S => { S.ctrlKey || S.metaKey || S.altKey || S.shiftKey || S.button !== 0 || (a == null || a(S), S.defaultPrevented || (S.preventDefault(), s(o, e))) }), v = n.hrefs(o[0] === "~" ? o.slice(1) : n.base + o, n); return l && y.isValidElement(u) ? y.cloneElement(u, { onClick: x, href: v }) : y.createElement("a", { ...m, onClick: x, href: v, className: c != null && c.call ? c(r === o) : c, children: u, ref: t }) }); const Uv = e => Array.isArray(e) ? e.flatMap(t => Uv(t && t.type === y.Fragment ? t.props.children : t)) : [e], nE = ({ children: e, location: t }) => { const n = zi(), [r] = Ia(n); for (const s of Uv(e)) { let i = 0; if (y.isValidElement(s) && (i = zv(n.parser, s.props.path, t || r, s.props.nest))[0]) return y.cloneElement(s, { match: i }) } return null }, rE = gd("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), Ui = y.forwardRef(({ className: e, variant: t, size: n, asChild: r = !1, ...s }, i) => { const o = r ? Pi : "button"; return w.jsx(o, { className: Y(rE({ variant: t, size: n, className: e })), ref: i, ...s }) }); Ui.displayName = "Button"; function sE() { const [e, t] = y.useState("light"); y.useEffect(() => { const r = document.documentElement.classList.contains("dark"); t(r ? "dark" : "light") }, []); function n() { t(e === "light" ? "dark" : "light"), document.documentElement.classList.toggle("dark") } return w.jsx(Ui, { variant: "ghost", size: "icon", onClick: n, className: "fixed top-4 right-4", children: e === "light" ? w.jsx(BC, { className: "h-5 w-5" }) : w.jsx($C, { className: "h-5 w-5" }) }) } const Cd = y.createContext({}); function Pd(e) { const t = y.useRef(null); return t.current === null && (t.current = e()), t.current } const Fa = y.createContext(null), Ed = y.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); class iE extends y.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent) { const r = this.props.sizeRef.current; r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function oE({ children: e, isPresent: t }) {
  const n = y.useId(), r = y.useRef(null), s = y.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: i } = y.useContext(Ed); return y.useInsertionEffect(() => {
    const { width: o, height: a, top: l, left: u } = s.current; if (t || !r.current || !o || !a) return; r.current.dataset.motionPopId = n; const c = document.createElement("style"); return i && (c.nonce = i), document.head.appendChild(c), c.sheet && c.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${u}px !important;
          }
        `), () => { document.head.removeChild(c) }
  }, [t]), w.jsx(iE, { isPresent: t, childRef: r, sizeRef: s, children: y.cloneElement(e, { ref: r }) })
} const aE = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: i, mode: o }) => { const a = Pd(lE), l = y.useId(), u = y.useCallback(d => { a.set(d, !0); for (const f of a.values()) if (!f) return; r && r() }, [a, r]), c = y.useMemo(() => ({ id: l, initial: t, isPresent: n, custom: s, onExitComplete: u, register: d => (a.set(d, !1), () => a.delete(d)) }), i ? [Math.random(), u] : [n, u]); return y.useMemo(() => { a.forEach((d, f) => a.set(f, !1)) }, [n]), y.useEffect(() => { !n && !a.size && r && r() }, [n]), o === "popLayout" && (e = w.jsx(oE, { isPresent: n, children: e })), w.jsx(Fa.Provider, { value: c, children: e }) }; function lE() { return new Map } function Bv(e = !0) { const t = y.useContext(Fa); if (t === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: s } = t, i = y.useId(); y.useEffect(() => { e && s(i) }, [e]); const o = y.useCallback(() => e && r && r(i), [i, r, e]); return !n && r ? [!1, o] : [!0] } const mo = e => e.key || ""; function Bh(e) { const t = []; return y.Children.forEach(e, n => { y.isValidElement(n) && t.push(n) }), t } const Td = typeof window < "u", $v = Td ? y.useLayoutEffect : y.useEffect, Wv = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: s = !0, mode: i = "sync", propagate: o = !1 }) => { const [a, l] = Bv(o), u = y.useMemo(() => Bh(e), [e]), c = o && !a ? [] : u.map(mo), d = y.useRef(!0), f = y.useRef(u), m = Pd(() => new Map), [x, v] = y.useState(u), [S, p] = y.useState(u); $v(() => { d.current = !1, f.current = u; for (let P = 0; P < S.length; P++) { const E = mo(S[P]); c.includes(E) ? m.delete(E) : m.get(E) !== !0 && m.set(E, !1) } }, [S, c.length, c.join("-")]); const h = []; if (u !== x) { let P = [...u]; for (let E = 0; E < S.length; E++) { const R = S[E], k = mo(R); c.includes(k) || (P.splice(E, 0, R), h.push(R)) } i === "wait" && h.length && (P = h), p(Bh(P)), v(u); return } const { forceRender: g } = y.useContext(Cd); return w.jsx(w.Fragment, { children: S.map(P => { const E = mo(P), R = o && !a ? !1 : u === S || c.includes(E), k = () => { if (m.has(E)) m.set(E, !0); else return; let T = !0; m.forEach(b => { b || (T = !1) }), T && (g == null || g(), p(f.current), o && (l == null || l()), r && r()) }; return w.jsx(aE, { isPresent: R, initial: !d.current || n ? void 0 : !1, custom: R ? void 0 : t, presenceAffectsLayout: s, mode: i, onExitComplete: R ? void 0 : k, children: P }, E) }) }) }, Je = e => e; let qu = Je; function kd(e) { let t; return () => (t === void 0 && (t = e()), t) } const hs = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }, qt = e => e * 1e3, Zt = e => e / 1e3, uE = { skipAnimations: !1, useManualTiming: !1 }; function cE(e) { let t = new Set, n = new Set, r = !1, s = !1; const i = new WeakSet; let o = { delta: 0, timestamp: 0, isProcessing: !1 }; function a(u) { i.has(u) && (l.schedule(u), e()), u(o) } const l = { schedule: (u, c = !1, d = !1) => { const m = d && r ? t : n; return c && i.add(u), m.has(u) || m.add(u), u }, cancel: u => { n.delete(u), i.delete(u) }, process: u => { if (o = u, r) { s = !0; return } r = !0, [t, n] = [n, t], t.forEach(a), t.clear(), r = !1, s && (s = !1, l.process(u)) } }; return l } const yo = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], dE = 40; function Hv(e, t) { let n = !1, r = !0; const s = { delta: 0, timestamp: 0, isProcessing: !1 }, i = () => n = !0, o = yo.reduce((p, h) => (p[h] = cE(i), p), {}), { read: a, resolveKeyframes: l, update: u, preRender: c, render: d, postRender: f } = o, m = () => { const p = performance.now(); n = !1, s.delta = r ? 1e3 / 60 : Math.max(Math.min(p - s.timestamp, dE), 1), s.timestamp = p, s.isProcessing = !0, a.process(s), l.process(s), u.process(s), c.process(s), d.process(s), f.process(s), s.isProcessing = !1, n && t && (r = !1, e(m)) }, x = () => { n = !0, r = !0, s.isProcessing || e(m) }; return { schedule: yo.reduce((p, h) => { const g = o[h]; return p[h] = (P, E = !1, R = !1) => (n || x(), g.schedule(P, E, R)), p }, {}), cancel: p => { for (let h = 0; h < yo.length; h++)o[yo[h]].cancel(p) }, state: s, steps: o } } const { schedule: te, cancel: Fn, state: Ee, steps: Rl } = Hv(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Je, !0), Kv = y.createContext({ strict: !1 }), $h = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ps = {}; for (const e in $h) ps[e] = { isEnabled: t => $h[e].some(n => !!t[n]) }; function fE(e) { for (const t in e) ps[t] = { ...ps[t], ...e[t] } } const hE = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function ua(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || hE.has(e) } let Qv = e => !ua(e); function pE(e) { e && (Qv = t => t.startsWith("on") ? !ua(t) : e(t)) } try { pE(require("@emotion/is-prop-valid").default) } catch { } function mE(e, t, n) { const r = {}; for (const s in e) s === "values" && typeof e.values == "object" || (Qv(s) || n === !0 && ua(s) || !t && !ua(s) || e.draggable && s.startsWith("onDrag")) && (r[s] = e[s]); return r } function yE(e) { if (typeof Proxy > "u") return e; const t = new Map, n = (...r) => e(...r); return new Proxy(n, { get: (r, s) => s === "create" ? e : (t.has(s) || t.set(s, e(s)), t.get(s)) }) } const Va = y.createContext({}); function Ti(e) { return typeof e == "string" || Array.isArray(e) } function za(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } const Rd = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], bd = ["initial", ...Rd]; function Ua(e) { return za(e.animate) || bd.some(t => Ti(e[t])) } function Gv(e) { return !!(Ua(e) || e.variants) } function gE(e, t) { if (Ua(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || Ti(n) ? n : void 0, animate: Ti(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function vE(e) { const { initial: t, animate: n } = gE(e, y.useContext(Va)); return y.useMemo(() => ({ initial: t, animate: n }), [Wh(t), Wh(n)]) } function Wh(e) { return Array.isArray(e) ? e.join(" ") : e } const wE = Symbol.for("motionComponentSymbol"); function Lr(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function xE(e, t, n) { return y.useCallback(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : Lr(n) && (n.current = r)) }, [t]) } const Ad = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), SE = "framerAppearId", Xv = "data-" + Ad(SE), { schedule: Md, cancel: l2 } = Hv(queueMicrotask, !1), Yv = y.createContext({}); function CE(e, t, n, r, s) { var i, o; const { visualElement: a } = y.useContext(Va), l = y.useContext(Kv), u = y.useContext(Fa), c = y.useContext(Ed).reducedMotion, d = y.useRef(null); r = r || l.renderer, !d.current && r && (d.current = r(e, { visualState: t, parent: a, props: n, presenceContext: u, blockInitialAnimation: u ? u.initial === !1 : !1, reducedMotionConfig: c })); const f = d.current, m = y.useContext(Yv); f && !f.projection && s && (f.type === "html" || f.type === "svg") && PE(d.current, n, s, m); const x = y.useRef(!1); y.useInsertionEffect(() => { f && x.current && f.update(n, u) }); const v = n[Xv], S = y.useRef(!!v && !(!((i = window.MotionHandoffIsComplete) === null || i === void 0) && i.call(window, v)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, v))); return $v(() => { f && (x.current = !0, window.MotionIsMounted = !0, f.updateFeatures(), Md.render(f.render), S.current && f.animationState && f.animationState.animateChanges()) }), y.useEffect(() => { f && (!S.current && f.animationState && f.animationState.animateChanges(), S.current && (queueMicrotask(() => { var p; (p = window.MotionHandoffMarkAsComplete) === null || p === void 0 || p.call(window, v) }), S.current = !1)) }), f } function PE(e, t, n, r) { const { layoutId: s, layout: i, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: u } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : qv(e.parent)), e.projection.setOptions({ layoutId: s, layout: i, alwaysMeasureLayout: !!o || a && Lr(a), visualElement: e, animationType: typeof i == "string" ? i : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: u }) } function qv(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : qv(e.parent) } function EE({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: s }) { var i, o; e && fE(e); function a(u, c) { let d; const f = { ...y.useContext(Ed), ...u, layoutId: TE(u) }, { isStatic: m } = f, x = vE(u), v = r(u, m); if (!m && Td) { kE(); const S = RE(f); d = S.MeasureLayout, x.visualElement = CE(s, v, f, t, S.ProjectionNode) } return w.jsxs(Va.Provider, { value: x, children: [d && x.visualElement ? w.jsx(d, { visualElement: x.visualElement, ...f }) : null, n(s, u, xE(v, x.visualElement, c), v, m, x.visualElement)] }) } a.displayName = `motion.${typeof s == "string" ? s : `create(${(o = (i = s.displayName) !== null && i !== void 0 ? i : s.name) !== null && o !== void 0 ? o : ""})`}`; const l = y.forwardRef(a); return l[wE] = s, l } function TE({ layoutId: e }) { const t = y.useContext(Cd).id; return t && e !== void 0 ? t + "-" + e : e } function kE(e, t) { y.useContext(Kv).strict } function RE(e) { const { drag: t, layout: n } = ps; if (!t && !n) return {}; const r = { ...t, ...n }; return { MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } const bE = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Dd(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(bE.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function Zv(e, { style: t, vars: n }, r, s) { Object.assign(e.style, t, s && s.getProjectionStyles(r)); for (const i in n) e.style.setProperty(i, n[i]) } const Jv = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function e0(e, t, n, r) { Zv(e, t, void 0, r); for (const s in t.attrs) e.setAttribute(Jv.has(s) ? s : Ad(s), t.attrs[s]) } const Le = e => !!(e && e.getVelocity), Ps = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Es = new Set(Ps), ca = {}; function AE(e) { Object.assign(ca, e) } function t0(e, { layout: t, layoutId: n }) { return Es.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!ca[e] || e === "opacity") } function Nd(e, t, n) { var r; const { style: s } = e, i = {}; for (const o in s) (Le(s[o]) || t.style && Le(t.style[o]) || t0(o, e) || ((r = n == null ? void 0 : n.getValue(o)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (i[o] = s[o]); return i } function n0(e, t, n) { const r = Nd(e, t, n); for (const s in e) if (Le(e[s]) || Le(t[s])) { const i = Ps.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s; r[i] = e[s] } return r } function Hh(e) { const t = [{}, {}]; return e == null || e.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function Ld(e, t, n, r) { if (typeof t == "function") { const [s, i] = Hh(r); t = t(n !== void 0 ? n : e.custom, s, i) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [s, i] = Hh(r); t = t(n !== void 0 ? n : e.custom, s, i) } return t } const Zu = e => Array.isArray(e), ME = e => !!(e && typeof e == "object" && e.mix && e.toValue), DE = e => Zu(e) ? e[e.length - 1] || 0 : e; function jo(e) { const t = Le(e) ? e.get() : e; return ME(t) ? t.toValue() : t } function NE({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, s, i) { const o = { latestValues: LE(r, s, i, e), renderState: t() }; return n && (o.mount = a => n(r, a, o)), o } const r0 = e => (t, n) => { const r = y.useContext(Va), s = y.useContext(Fa), i = () => NE(e, t, r, s); return n ? i() : Pd(i) }; function LE(e, t, n, r) { const s = {}, i = r(e, {}); for (const f in i) s[f] = jo(i[f]); let { initial: o, animate: a } = e; const l = Ua(e), u = Gv(e); t && u && !l && e.inherit !== !1 && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate)); let c = n ? n.initial === !1 : !1; c = c || o === !1; const d = c ? a : o; if (d && typeof d != "boolean" && !za(d)) { const f = Array.isArray(d) ? d : [d]; for (let m = 0; m < f.length; m++) { const x = Ld(e, f[m]); if (x) { const { transitionEnd: v, transition: S, ...p } = x; for (const h in p) { let g = p[h]; if (Array.isArray(g)) { const P = c ? g.length - 1 : 0; g = g[P] } g !== null && (s[h] = g) } for (const h in v) s[h] = v[h] } } } return s } const jd = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), s0 = () => ({ ...jd(), attrs: {} }), i0 = e => t => typeof t == "string" && t.startsWith(e), o0 = i0("--"), jE = i0("var(--"), Od = e => jE(e) ? OE.test(e.split("/*")[0].trim()) : !1, OE = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, a0 = (e, t) => t && typeof e == "number" ? t.transform(e) : e, sn = (e, t, n) => n > t ? t : n < e ? e : n, Ts = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, ki = { ...Ts, transform: e => sn(0, 1, e) }, go = { ...Ts, default: 1 }, Bi = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), fn = Bi("deg"), It = Bi("%"), I = Bi("px"), _E = Bi("vh"), IE = Bi("vw"), Kh = { ...It, parse: e => It.parse(e) / 100, transform: e => It.transform(e * 100) }, FE = { borderWidth: I, borderTopWidth: I, borderRightWidth: I, borderBottomWidth: I, borderLeftWidth: I, borderRadius: I, radius: I, borderTopLeftRadius: I, borderTopRightRadius: I, borderBottomRightRadius: I, borderBottomLeftRadius: I, width: I, maxWidth: I, height: I, maxHeight: I, top: I, right: I, bottom: I, left: I, padding: I, paddingTop: I, paddingRight: I, paddingBottom: I, paddingLeft: I, margin: I, marginTop: I, marginRight: I, marginBottom: I, marginLeft: I, backgroundPositionX: I, backgroundPositionY: I }, VE = { rotate: fn, rotateX: fn, rotateY: fn, rotateZ: fn, scale: go, scaleX: go, scaleY: go, scaleZ: go, skew: fn, skewX: fn, skewY: fn, distance: I, translateX: I, translateY: I, translateZ: I, x: I, y: I, z: I, perspective: I, transformPerspective: I, opacity: ki, originX: Kh, originY: Kh, originZ: I }, Qh = { ...Ts, transform: Math.round }, _d = { ...FE, ...VE, zIndex: Qh, size: I, fillOpacity: ki, strokeOpacity: ki, numOctaves: Qh }, zE = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, UE = Ps.length; function BE(e, t, n) { let r = "", s = !0; for (let i = 0; i < UE; i++) { const o = Ps[i], a = e[o]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { const u = a0(a, _d[o]); if (!l) { s = !1; const c = zE[o] || o; r += `${c}(${u}) ` } n && (t[o] = u) } } return r = r.trim(), n ? r = n(t, s ? "" : r) : s && (r = "none"), r } function Id(e, t, n) { const { style: r, vars: s, transformOrigin: i } = e; let o = !1, a = !1; for (const l in t) { const u = t[l]; if (Es.has(l)) { o = !0; continue } else if (o0(l)) { s[l] = u; continue } else { const c = a0(u, _d[l]); l.startsWith("origin") ? (a = !0, i[l] = c) : r[l] = c } } if (t.transform || (o || n ? r.transform = BE(t, e.transform, n) : r.transform && (r.transform = "none")), a) { const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = i; r.transformOrigin = `${l} ${u} ${c}` } } function Gh(e, t, n) { return typeof e == "string" ? e : I.transform(t + n * e) } function $E(e, t, n) { const r = Gh(t, e.x, e.width), s = Gh(n, e.y, e.height); return `${r} ${s}` } const WE = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, HE = { offset: "strokeDashoffset", array: "strokeDasharray" }; function KE(e, t, n = 1, r = 0, s = !0) { e.pathLength = 1; const i = s ? WE : HE; e[i.offset] = I.transform(-r); const o = I.transform(t), a = I.transform(n); e[i.array] = `${o} ${a}` } function Fd(e, { attrX: t, attrY: n, attrScale: r, originX: s, originY: i, pathLength: o, pathSpacing: a = 1, pathOffset: l = 0, ...u }, c, d) { if (Id(e, u, d), c) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: f, style: m, dimensions: x } = e; f.transform && (x && (m.transform = f.transform), delete f.transform), x && (s !== void 0 || i !== void 0 || m.transform) && (m.transformOrigin = $E(x, s !== void 0 ? s : .5, i !== void 0 ? i : .5)), t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), o !== void 0 && KE(f, o, a, l, !1) } const Vd = e => typeof e == "string" && e.toLowerCase() === "svg", QE = { useVisualState: r0({ scrapeMotionValuesFromProps: n0, createRenderState: s0, onMount: (e, t, { renderState: n, latestValues: r }) => { te.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), te.render(() => { Fd(n, r, Vd(t.tagName), e.transformTemplate), e0(t, n) }) } }) }, GE = { useVisualState: r0({ scrapeMotionValuesFromProps: Nd, createRenderState: jd }) }; function l0(e, t, n) { for (const r in t) !Le(t[r]) && !t0(r, n) && (e[r] = t[r]) } function XE({ transformTemplate: e }, t) { return y.useMemo(() => { const n = jd(); return Id(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function YE(e, t) { const n = e.style || {}, r = {}; return l0(r, n, e), Object.assign(r, XE(e, t)), r } function qE(e, t) { const n = {}, r = YE(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } function ZE(e, t, n, r) { const s = y.useMemo(() => { const i = s0(); return Fd(i, t, Vd(r), e.transformTemplate), { ...i.attrs, style: { ...i.style } } }, [t]); if (e.style) { const i = {}; l0(i, e.style, e), s.style = { ...i, ...s.style } } return s } function JE(e = !1) { return (n, r, s, { latestValues: i }, o) => { const l = (Dd(n) ? ZE : qE)(r, i, o, n), u = mE(r, typeof n == "string", e), c = n !== y.Fragment ? { ...u, ...l, ref: s } : {}, { children: d } = r, f = y.useMemo(() => Le(d) ? d.get() : d, [d]); return y.createElement(n, { ...c, children: f }) } } function eT(e, t) { return function (r, { forwardMotionProps: s } = { forwardMotionProps: !1 }) { const o = { ...Dd(r) ? QE : GE, preloadedFeatures: e, useRender: JE(s), createVisualElement: t, Component: r }; return EE(o) } } function u0(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function Ba(e, t, n) { const r = e.getProps(); return Ld(r, t, n !== void 0 ? n : r.custom, e) } const tT = kd(() => window.ScrollTimeline !== void 0); class nT { constructor(t) { this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean) } get finished() { return Promise.all(this.animations.map(t => "finished" in t ? t.finished : t)) } getAll(t) { return this.animations[0][t] } setAll(t, n) { for (let r = 0; r < this.animations.length; r++)this.animations[r][t] = n } attachTimeline(t, n) { const r = this.animations.map(s => { if (tT() && s.attachTimeline) return s.attachTimeline(t); if (typeof n == "function") return n(s) }); return () => { r.forEach((s, i) => { s && s(), this.animations[i].stop() }) } } get time() { return this.getAll("time") } set time(t) { this.setAll("time", t) } get speed() { return this.getAll("speed") } set speed(t) { this.setAll("speed", t) } get startTime() { return this.getAll("startTime") } get duration() { let t = 0; for (let n = 0; n < this.animations.length; n++)t = Math.max(t, this.animations[n].duration); return t } runAll(t) { this.animations.forEach(n => n[t]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } class rT extends nT { then(t, n) { return Promise.all(this.animations).then(t).catch(n) } } function zd(e, t) { return e ? e[t] || e.default || e : void 0 } const Ju = 2e4; function c0(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < Ju;)t += n, r = e.next(t); return t >= Ju ? 1 / 0 : t } function Ud(e) { return typeof e == "function" } function Xh(e, t) { e.timeline = t, e.onfinish = null } const Bd = e => Array.isArray(e) && typeof e[0] == "number", sT = { linearEasing: void 0 }; function iT(e, t) { const n = kd(e); return () => { var r; return (r = sT[t]) !== null && r !== void 0 ? r : n() } } const da = iT(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), d0 = (e, t, n = 10) => { let r = ""; const s = Math.max(Math.round(t / n), 2); for (let i = 0; i < s; i++)r += e(hs(0, s - 1, i)) + ", "; return `linear(${r.substring(0, r.length - 2)})` }; function f0(e) { return !!(typeof e == "function" && da() || !e || typeof e == "string" && (e in ec || da()) || Bd(e) || Array.isArray(e) && e.every(f0)) } const Bs = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, ec = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Bs([0, .65, .55, 1]), circOut: Bs([.55, 0, 1, .45]), backIn: Bs([.31, .01, .66, -.59]), backOut: Bs([.33, 1.53, .69, .99]) }; function h0(e, t) { if (e) return typeof e == "function" && da() ? d0(e, t) : Bd(e) ? Bs(e) : Array.isArray(e) ? e.map(n => h0(n, t) || ec.easeOut) : ec[e] } const gt = { x: !1, y: !1 }; function p0() { return gt.x || gt.y } function oT(e, t, n) { var r; if (e instanceof Element) return [e]; if (typeof e == "string") { let s = document; const i = (r = void 0) !== null && r !== void 0 ? r : s.querySelectorAll(e); return i ? Array.from(i) : [] } return Array.from(e) } function m0(e, t) { const n = oT(e), r = new AbortController, s = { passive: !0, ...t, signal: r.signal }; return [n, s, () => r.abort()] } function Yh(e) { return t => { t.pointerType === "touch" || p0() || e(t) } } function aT(e, t, n = {}) { const [r, s, i] = m0(e, n), o = Yh(a => { const { target: l } = a, u = t(a); if (typeof u != "function" || !l) return; const c = Yh(d => { u(d), l.removeEventListener("pointerleave", c) }); l.addEventListener("pointerleave", c, s) }); return r.forEach(a => { a.addEventListener("pointerenter", o, s) }), i } const y0 = (e, t) => t ? e === t ? !0 : y0(e, t.parentElement) : !1, $d = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, lT = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function uT(e) { return lT.has(e.tagName) || e.tabIndex !== -1 } const $s = new WeakSet; function qh(e) { return t => { t.key === "Enter" && e(t) } } function bl(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const cT = (e, t) => { const n = e.currentTarget; if (!n) return; const r = qh(() => { if ($s.has(n)) return; bl(n, "down"); const s = qh(() => { bl(n, "up") }), i = () => bl(n, "cancel"); n.addEventListener("keyup", s, t), n.addEventListener("blur", i, t) }); n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t) }; function Zh(e) { return $d(e) && !p0() } function dT(e, t, n = {}) { const [r, s, i] = m0(e, n), o = a => { const l = a.currentTarget; if (!Zh(a) || $s.has(l)) return; $s.add(l); const u = t(a), c = (m, x) => { window.removeEventListener("pointerup", d), window.removeEventListener("pointercancel", f), !(!Zh(m) || !$s.has(l)) && ($s.delete(l), typeof u == "function" && u(m, { success: x })) }, d = m => { c(m, n.useGlobalTarget || y0(l, m.target)) }, f = m => { c(m, !1) }; window.addEventListener("pointerup", d, s), window.addEventListener("pointercancel", f, s) }; return r.forEach(a => { !uT(a) && a.getAttribute("tabindex") === null && (a.tabIndex = 0), (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), a.addEventListener("focus", u => cT(u, s), s) }), i } function fT(e) { return e === "x" || e === "y" ? gt[e] ? null : (gt[e] = !0, () => { gt[e] = !1 }) : gt.x || gt.y ? null : (gt.x = gt.y = !0, () => { gt.x = gt.y = !1 }) } const g0 = new Set(["width", "height", "top", "left", "right", "bottom", ...Ps]); let Oo; function hT() { Oo = void 0 } const Ft = { now: () => (Oo === void 0 && Ft.set(Ee.isProcessing || uE.useManualTiming ? Ee.timestamp : performance.now()), Oo), set: e => { Oo = e, queueMicrotask(hT) } }; function Wd(e, t) { e.indexOf(t) === -1 && e.push(t) } function Hd(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class Kd { constructor() { this.subscriptions = [] } add(t) { return Wd(this.subscriptions, t), () => Hd(this.subscriptions, t) } notify(t, n, r) { const s = this.subscriptions.length; if (s) if (s === 1) this.subscriptions[0](t, n, r); else for (let i = 0; i < s; i++) { const o = this.subscriptions[i]; o && o(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } function v0(e, t) { return t ? e * (1e3 / t) : 0 } const Jh = 30, pT = e => !isNaN(parseFloat(e)); class mT { constructor(t, n = {}) { this.version = "11.17.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, s = !0) => { const i = Ft.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), s && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = Ft.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = pT(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new Kd); const r = this.events[t].add(n); return t === "change" ? () => { r(), te.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = Ft.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Jh) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, Jh); return v0(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Ri(e, t) { return new mT(e, t) } function yT(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ri(n)) } function gT(e, t) { const n = Ba(e, t); let { transitionEnd: r = {}, transition: s = {}, ...i } = n || {}; i = { ...i, ...r }; for (const o in i) { const a = DE(i[o]); yT(e, o, a) } } function vT(e) { return !!(Le(e) && e.add) } function tc(e, t) { const n = e.getValue("willChange"); if (vT(n)) return n.add(t) } function w0(e) { return e.props[Xv] } const x0 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, wT = 1e-7, xT = 12; function ST(e, t, n, r, s) { let i, o, a = 0; do o = t + (n - t) / 2, i = x0(o, r, s) - e, i > 0 ? n = o : t = o; while (Math.abs(i) > wT && ++a < xT); return o } function $i(e, t, n, r) { if (e === t && n === r) return Je; const s = i => ST(i, 0, 1, e, n); return i => i === 0 || i === 1 ? i : x0(s(i), t, r) } const S0 = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, C0 = e => t => 1 - e(1 - t), P0 = $i(.33, 1.53, .69, .99), Qd = C0(P0), E0 = S0(Qd), T0 = e => (e *= 2) < 1 ? .5 * Qd(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), Gd = e => 1 - Math.sin(Math.acos(e)), k0 = C0(Gd), R0 = S0(Gd), b0 = e => /^0[^.\s]+$/u.test(e); function CT(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || b0(e) : !0 } const ti = e => Math.round(e * 1e5) / 1e5, Xd = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function PT(e) { return e == null } const ET = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Yd = (e, t) => n => !!(typeof n == "string" && ET.test(n) && n.startsWith(e) || t && !PT(n) && Object.prototype.hasOwnProperty.call(n, t)), A0 = (e, t, n) => r => { if (typeof r != "string") return r; const [s, i, o, a] = r.match(Xd); return { [e]: parseFloat(s), [t]: parseFloat(i), [n]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, TT = e => sn(0, 255, e), Al = { ...Ts, transform: e => Math.round(TT(e)) }, Jn = { test: Yd("rgb", "red"), parse: A0("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Al.transform(e) + ", " + Al.transform(t) + ", " + Al.transform(n) + ", " + ti(ki.transform(r)) + ")" }; function kT(e) { let t = "", n = "", r = "", s = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), s = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), s = e.substring(4, 5), t += t, n += n, r += r, s += s), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: s ? parseInt(s, 16) / 255 : 1 } } const nc = { test: Yd("#"), parse: kT, transform: Jn.transform }, jr = { test: Yd("hsl", "hue"), parse: A0("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + It.transform(ti(t)) + ", " + It.transform(ti(n)) + ", " + ti(ki.transform(r)) + ")" }, Me = { test: e => Jn.test(e) || nc.test(e) || jr.test(e), parse: e => Jn.test(e) ? Jn.parse(e) : jr.test(e) ? jr.parse(e) : nc.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Jn.transform(e) : jr.transform(e) }, RT = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function bT(e) { var t, n; return isNaN(e) && typeof e == "string" && (((t = e.match(Xd)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(RT)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } const M0 = "number", D0 = "color", AT = "var", MT = "var(", ep = "${}", DT = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function bi(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, s = []; let i = 0; const a = t.replace(DT, l => (Me.test(l) ? (r.color.push(i), s.push(D0), n.push(Me.parse(l))) : l.startsWith(MT) ? (r.var.push(i), s.push(AT), n.push(l)) : (r.number.push(i), s.push(M0), n.push(parseFloat(l))), ++i, ep)).split(ep); return { values: n, split: a, indexes: r, types: s } } function N0(e) { return bi(e).values } function L0(e) { const { split: t, types: n } = bi(e), r = t.length; return s => { let i = ""; for (let o = 0; o < r; o++)if (i += t[o], s[o] !== void 0) { const a = n[o]; a === M0 ? i += ti(s[o]) : a === D0 ? i += Me.transform(s[o]) : i += s[o] } return i } } const NT = e => typeof e == "number" ? 0 : e; function LT(e) { const t = N0(e); return L0(e)(t.map(NT)) } const Vn = { test: bT, parse: N0, createTransformer: L0, getAnimatableNone: LT }, jT = new Set(["brightness", "contrast", "saturate", "opacity"]); function OT(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(Xd) || []; if (!r) return e; const s = n.replace(r, ""); let i = jT.has(t) ? 1 : 0; return r !== n && (i *= 100), t + "(" + i + s + ")" } const _T = /\b([a-z-]*)\(.*?\)/gu, rc = { ...Vn, getAnimatableNone: e => { const t = e.match(_T); return t ? t.map(OT).join(" ") : e } }, IT = { ..._d, color: Me, backgroundColor: Me, outlineColor: Me, fill: Me, stroke: Me, borderColor: Me, borderTopColor: Me, borderRightColor: Me, borderBottomColor: Me, borderLeftColor: Me, filter: rc, WebkitFilter: rc }, qd = e => IT[e]; function j0(e, t) { let n = qd(e); return n !== rc && (n = Vn), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const FT = new Set(["auto", "none", "0"]); function VT(e, t, n) { let r = 0, s; for (; r < e.length && !s;) { const i = e[r]; typeof i == "string" && !FT.has(i) && bi(i).values.length && (s = e[r]), r++ } if (s && n) for (const i of t) e[i] = j0(n, s) } const tp = e => e === Ts || e === I, np = (e, t) => parseFloat(e.split(", ")[t]), rp = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; const s = r.match(/^matrix3d\((.+)\)$/u); if (s) return np(s[1], t); { const i = r.match(/^matrix\((.+)\)$/u); return i ? np(i[1], e) : 0 } }, zT = new Set(["x", "y", "z"]), UT = Ps.filter(e => !zT.has(e)); function BT(e) { const t = []; return UT.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const ms = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: rp(4, 13), y: rp(5, 14) }; ms.translateX = ms.x; ms.translateY = ms.y; const ur = new Set; let sc = !1, ic = !1; function O0() { if (ic) { const e = Array.from(ur).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { const s = BT(r); s.length && (n.set(r, s), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const s = n.get(r); s && s.forEach(([i, o]) => { var a; (a = r.getValue(i)) === null || a === void 0 || a.set(o) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } ic = !1, sc = !1, ur.forEach(e => e.complete()), ur.clear() } function _0() { ur.forEach(e => { e.readKeyframes(), e.needsMeasurement && (ic = !0) }) } function $T() { _0(), O0() } class Zd { constructor(t, n, r, s, i, o = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (ur.add(this), sc || (sc = !0, te.read(_0), te.resolveKeyframes(O0))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: s } = this; for (let i = 0; i < t.length; i++)if (t[i] === null) if (i === 0) { const o = s == null ? void 0 : s.get(), a = t[t.length - 1]; if (o !== void 0) t[0] = o; else if (r && n) { const l = r.readValue(n, a); l != null && (t[0] = l) } t[0] === void 0 && (t[0] = a), s && o === void 0 && s.set(t[0]) } else t[i] = t[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ur.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, ur.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const I0 = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), WT = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function HT(e) { const t = WT.exec(e); if (!t) return [,]; const [, n, r, s] = t; return [`--${n ?? r}`, s] } function F0(e, t, n = 1) { const [r, s] = HT(e); if (!r) return; const i = window.getComputedStyle(t).getPropertyValue(r); if (i) { const o = i.trim(); return I0(o) ? parseFloat(o) : o } return Od(s) ? F0(s, t, n + 1) : s } const V0 = e => t => t.test(e), KT = { test: e => e === "auto", parse: e => e }, z0 = [Ts, I, It, fn, IE, _E, KT], sp = e => z0.find(V0(e)); class U0 extends Zd { constructor(t, n, r, s, i) { super(t, n, r, s, i, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let l = 0; l < t.length; l++) { let u = t[l]; if (typeof u == "string" && (u = u.trim(), Od(u))) { const c = F0(u, n.current); c !== void 0 && (t[l] = c), l === t.length - 1 && (this.finalKeyframe = u) } } if (this.resolveNoneKeyframes(), !g0.has(r) || t.length !== 2) return; const [s, i] = t, o = sp(s), a = sp(i); if (o !== a) if (tp(o) && tp(a)) for (let l = 0; l < t.length; l++) { const u = t[l]; typeof u == "string" && (t[l] = parseFloat(u)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let s = 0; s < t.length; s++)CT(t[s]) && r.push(s); r.length && VT(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ms[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const s = n[n.length - 1]; s !== void 0 && t.getValue(r, s).jump(s, !1) } measureEndState() { var t; const { element: n, name: r, unresolvedKeyframes: s } = this; if (!n || !n.current) return; const i = n.getValue(r); i && i.jump(this.measuredOrigin, !1); const o = s.length - 1, a = s[o]; s[o] = ms[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, u]) => { n.getValue(l).set(u) }), this.resolveNoneKeyframes() } } const ip = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Vn.test(e) || e === "0") && !e.startsWith("url(")); function QT(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function GT(e, t, n, r) { const s = e[0]; if (s === null) return !1; if (t === "display" || t === "visibility") return !0; const i = e[e.length - 1], o = ip(s, t), a = ip(i, t); return !o || !a ? !1 : QT(e) || (n === "spring" || Ud(n)) && r } const XT = e => e !== null; function $a(e, { repeat: t, repeatType: n = "loop" }, r) { const s = e.filter(XT), i = t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1; return !i || r === void 0 ? s[i] : r } const YT = 40; class B0 { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: s = 0, repeatDelay: i = 0, repeatType: o = "loop", ...a }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Ft.now(), this.options = { autoplay: t, delay: n, type: r, repeat: s, repeatDelay: i, repeatType: o, ...a }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > YT ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && $T(), this._resolved } onKeyframesResolved(t, n) { this.resolvedAt = Ft.now(), this.hasAttemptedResolve = !0; const { name: r, type: s, velocity: i, delay: o, onComplete: a, onUpdate: l, isGenerator: u } = this.options; if (!u && !GT(t, r, s, i)) if (o) this.options.duration = 0; else { l == null || l($a(t, this.options, n)), a == null || a(), this.resolveFinishedPromise(); return } const c = this.initPlayback(t, n); c !== !1 && (this._resolved = { keyframes: t, finalKeyframe: n, ...c }, this.onPostResolved()) } onPostResolved() { } then(t, n) { return this.currentFinishedPromise.then(t, n) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(t => { this.resolveFinishedPromise = t }) } } const se = (e, t, n) => e + (t - e) * n; function Ml(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function qT({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let s = 0, i = 0, o = 0; if (!t) s = i = o = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; s = Ml(l, a, e + 1 / 3), i = Ml(l, a, e), o = Ml(l, a, e - 1 / 3) } return { red: Math.round(s * 255), green: Math.round(i * 255), blue: Math.round(o * 255), alpha: r } } function fa(e, t) { return n => n > 0 ? t : e } const Dl = (e, t, n) => { const r = e * e, s = n * (t * t - r) + r; return s < 0 ? 0 : Math.sqrt(s) }, ZT = [nc, Jn, jr], JT = e => ZT.find(t => t.test(e)); function op(e) { const t = JT(e); if (!t) return !1; let n = t.parse(e); return t === jr && (n = qT(n)), n } const ap = (e, t) => { const n = op(e), r = op(t); if (!n || !r) return fa(e, t); const s = { ...n }; return i => (s.red = Dl(n.red, r.red, i), s.green = Dl(n.green, r.green, i), s.blue = Dl(n.blue, r.blue, i), s.alpha = se(n.alpha, r.alpha, i), Jn.transform(s)) }, ek = (e, t) => n => t(e(n)), Wi = (...e) => e.reduce(ek), oc = new Set(["none", "hidden"]); function tk(e, t) { return oc.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function nk(e, t) { return n => se(e, t, n) } function Jd(e) { return typeof e == "number" ? nk : typeof e == "string" ? Od(e) ? fa : Me.test(e) ? ap : ik : Array.isArray(e) ? $0 : typeof e == "object" ? Me.test(e) ? ap : rk : fa } function $0(e, t) { const n = [...e], r = n.length, s = e.map((i, o) => Jd(i)(i, t[o])); return i => { for (let o = 0; o < r; o++)n[o] = s[o](i); return n } } function rk(e, t) { const n = { ...e, ...t }, r = {}; for (const s in n) e[s] !== void 0 && t[s] !== void 0 && (r[s] = Jd(e[s])(e[s], t[s])); return s => { for (const i in r) n[i] = r[i](s); return n } } function sk(e, t) { var n; const r = [], s = { color: 0, var: 0, number: 0 }; for (let i = 0; i < t.values.length; i++) { const o = t.types[i], a = e.indexes[o][s[o]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[i] = l, s[o]++ } return r } const ik = (e, t) => { const n = Vn.createTransformer(t), r = bi(e), s = bi(t); return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? oc.has(e) && !s.values.length || oc.has(t) && !r.values.length ? tk(e, t) : Wi($0(sk(r, s), s.values), n) : fa(e, t) }; function W0(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? se(e, t, n) : Jd(e)(e, t) } const ok = 5; function H0(e, t, n) { const r = Math.max(t - ok, 0); return v0(n - e(r), t - r) } const ue = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, lp = .001; function ak({ duration: e = ue.duration, bounce: t = ue.bounce, velocity: n = ue.velocity, mass: r = ue.mass }) { let s, i, o = 1 - t; o = sn(ue.minDamping, ue.maxDamping, o), e = sn(ue.minDuration, ue.maxDuration, Zt(e)), o < 1 ? (s = u => { const c = u * o, d = c * e, f = c - n, m = ac(u, o), x = Math.exp(-d); return lp - f / m * x }, i = u => { const d = u * o * e, f = d * n + n, m = Math.pow(o, 2) * Math.pow(u, 2) * e, x = Math.exp(-d), v = ac(Math.pow(u, 2), o); return (-s(u) + lp > 0 ? -1 : 1) * ((f - m) * x) / v }) : (s = u => { const c = Math.exp(-u * e), d = (u - n) * e + 1; return -.001 + c * d }, i = u => { const c = Math.exp(-u * e), d = (n - u) * (e * e); return c * d }); const a = 5 / e, l = uk(s, i, a); if (e = qt(e), isNaN(l)) return { stiffness: ue.stiffness, damping: ue.damping, duration: e }; { const u = Math.pow(l, 2) * r; return { stiffness: u, damping: o * 2 * Math.sqrt(r * u), duration: e } } } const lk = 12; function uk(e, t, n) { let r = n; for (let s = 1; s < lk; s++)r = r - e(r) / t(r); return r } function ac(e, t) { return e * Math.sqrt(1 - t * t) } const ck = ["duration", "bounce"], dk = ["stiffness", "damping", "mass"]; function up(e, t) { return t.some(n => e[n] !== void 0) } function fk(e) { let t = { velocity: ue.velocity, stiffness: ue.stiffness, damping: ue.damping, mass: ue.mass, isResolvedFromDuration: !1, ...e }; if (!up(e, dk) && up(e, ck)) if (e.visualDuration) { const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), s = r * r, i = 2 * sn(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(s); t = { ...t, mass: ue.mass, stiffness: s, damping: i } } else { const n = ak(e); t = { ...t, ...n, mass: ue.mass }, t.isResolvedFromDuration = !0 } return t } function K0(e = ue.visualDuration, t = ue.bounce) { const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: s } = n; const i = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: i }, { stiffness: l, damping: u, mass: c, duration: d, velocity: f, isResolvedFromDuration: m } = fk({ ...n, velocity: -Zt(n.velocity || 0) }), x = f || 0, v = u / (2 * Math.sqrt(l * c)), S = o - i, p = Zt(Math.sqrt(l / c)), h = Math.abs(S) < 5; r || (r = h ? ue.restSpeed.granular : ue.restSpeed.default), s || (s = h ? ue.restDelta.granular : ue.restDelta.default); let g; if (v < 1) { const E = ac(p, v); g = R => { const k = Math.exp(-v * p * R); return o - k * ((x + v * p * S) / E * Math.sin(E * R) + S * Math.cos(E * R)) } } else if (v === 1) g = E => o - Math.exp(-p * E) * (S + (x + p * S) * E); else { const E = p * Math.sqrt(v * v - 1); g = R => { const k = Math.exp(-v * p * R), T = Math.min(E * R, 300); return o - k * ((x + v * p * S) * Math.sinh(T) + E * S * Math.cosh(T)) / E } } const P = { calculatedDuration: m && d || null, next: E => { const R = g(E); if (m) a.done = E >= d; else { let k = 0; v < 1 && (k = E === 0 ? qt(x) : H0(g, E, R)); const T = Math.abs(k) <= r, b = Math.abs(o - R) <= s; a.done = T && b } return a.value = a.done ? o : R, a }, toString: () => { const E = Math.min(c0(P), Ju), R = d0(k => P.next(E * k).value, E, 30); return E + "ms " + R } }; return P } function cp({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: i = 500, modifyTarget: o, min: a, max: l, restDelta: u = .5, restSpeed: c }) { const d = e[0], f = { done: !1, value: d }, m = T => a !== void 0 && T < a || l !== void 0 && T > l, x = T => a === void 0 ? l : l === void 0 || Math.abs(a - T) < Math.abs(l - T) ? a : l; let v = n * t; const S = d + v, p = o === void 0 ? S : o(S); p !== S && (v = p - d); const h = T => -v * Math.exp(-T / r), g = T => p + h(T), P = T => { const b = h(T), M = g(T); f.done = Math.abs(b) <= u, f.value = f.done ? p : M }; let E, R; const k = T => { m(f.value) && (E = T, R = K0({ keyframes: [f.value, x(f.value)], velocity: H0(g, T, f.value), damping: s, stiffness: i, restDelta: u, restSpeed: c })) }; return k(0), { calculatedDuration: null, next: T => { let b = !1; return !R && E === void 0 && (b = !0, P(T), k(T)), E !== void 0 && T >= E ? R.next(T - E) : (!b && P(T), f) } } } const hk = $i(.42, 0, 1, 1), pk = $i(0, 0, .58, 1), Q0 = $i(.42, 0, .58, 1), mk = e => Array.isArray(e) && typeof e[0] != "number", dp = { linear: Je, easeIn: hk, easeInOut: Q0, easeOut: pk, circIn: Gd, circInOut: R0, circOut: k0, backIn: Qd, backInOut: E0, backOut: P0, anticipate: T0 }, fp = e => { if (Bd(e)) { qu(e.length === 4); const [t, n, r, s] = e; return $i(t, n, r, s) } else if (typeof e == "string") return qu(dp[e] !== void 0), dp[e]; return e }; function yk(e, t, n) { const r = [], s = n || W0, i = e.length - 1; for (let o = 0; o < i; o++) { let a = s(e[o], e[o + 1]); if (t) { const l = Array.isArray(t) ? t[o] || Je : t; a = Wi(l, a) } r.push(a) } return r } function gk(e, t, { clamp: n = !0, ease: r, mixer: s } = {}) { const i = e.length; if (qu(i === t.length), i === 1) return () => t[0]; if (i === 2 && t[0] === t[1]) return () => t[1]; const o = e[0] === e[1]; e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse()); const a = yk(t, r, s), l = a.length, u = c => { if (o && c < e[0]) return t[0]; let d = 0; if (l > 1) for (; d < e.length - 2 && !(c < e[d + 1]); d++); const f = hs(e[d], e[d + 1], c); return a[d](f) }; return n ? c => u(sn(e[0], e[i - 1], c)) : u } function vk(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const s = hs(0, t, r); e.push(se(n, 1, s)) } } function wk(e) { const t = [0]; return vk(t, e.length - 1), t } function xk(e, t) { return e.map(n => n * t) } function Sk(e, t) { return e.map(() => t || Q0).splice(0, e.length - 1) } function ha({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const s = mk(r) ? r.map(fp) : fp(r), i = { done: !1, value: t[0] }, o = xk(n && n.length === t.length ? n : wk(t), e), a = gk(o, t, { ease: Array.isArray(s) ? s : Sk(t, s) }); return { calculatedDuration: e, next: l => (i.value = a(l), i.done = l >= e, i) } } const Ck = e => { const t = ({ timestamp: n }) => e(n); return { start: () => te.update(t, !0), stop: () => Fn(t), now: () => Ee.isProcessing ? Ee.timestamp : Ft.now() } }, Pk = { decay: cp, inertia: cp, tween: ha, keyframes: ha, spring: K0 }, Ek = e => e / 100; class ef extends B0 { constructor(t) { super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: l } = this.options; l && l() }; const { name: n, motionValue: r, element: s, keyframes: i } = this.options, o = (s == null ? void 0 : s.KeyframeResolver) || Zd, a = (l, u) => this.onKeyframesResolved(l, u); this.resolver = new o(i, a, n, r, s), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(t) { const { type: n = "keyframes", repeat: r = 0, repeatDelay: s = 0, repeatType: i, velocity: o = 0 } = this.options, a = Ud(n) ? n : Pk[n] || ha; let l, u; a !== ha && typeof t[0] != "number" && (l = Wi(Ek, W0(t[0], t[1])), t = [0, 100]); const c = a({ ...this.options, keyframes: t }); i === "mirror" && (u = a({ ...this.options, keyframes: [...t].reverse(), velocity: -o })), c.calculatedDuration === null && (c.calculatedDuration = c0(c)); const { calculatedDuration: d } = c, f = d + s, m = f * (r + 1) - s; return { generator: c, mirroredGenerator: u, mapPercentToKeyframes: l, calculatedDuration: d, resolvedDuration: f, totalDuration: m } } onPostResolved() { const { autoplay: t = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState } tick(t, n = !1) { const { resolved: r } = this; if (!r) { const { keyframes: T } = this.options; return { done: !0, value: T[T.length - 1] } } const { finalKeyframe: s, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: u, totalDuration: c, resolvedDuration: d } = r; if (this.startTime === null) return i.next(0); const { delay: f, repeat: m, repeatType: x, repeatDelay: v, onUpdate: S } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - c / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed; const p = this.currentTime - f * (this.speed >= 0 ? 1 : -1), h = this.speed >= 0 ? p < 0 : p > c; this.currentTime = Math.max(p, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let g = this.currentTime, P = i; if (m) { const T = Math.min(this.currentTime, c) / d; let b = Math.floor(T), M = T % 1; !M && T >= 1 && (M = 1), M === 1 && b--, b = Math.min(b, m + 1), !!(b % 2) && (x === "reverse" ? (M = 1 - M, v && (M -= v / d)) : x === "mirror" && (P = o)), g = sn(0, 1, M) * d } const E = h ? { done: !1, value: l[0] } : P.next(g); a && (E.value = a(E.value)); let { done: R } = E; !h && u !== null && (R = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const k = this.holdTime === null && (this.state === "finished" || this.state === "running" && R); return k && s !== void 0 && (E.value = $a(l, this.options, s)), S && S(E.value), k && this.finish(), E } get duration() { const { resolved: t } = this; return t ? Zt(t.calculatedDuration) : 0 } get time() { return Zt(this.currentTime) } set time(t) { t = qt(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed) } get speed() { return this.playbackSpeed } set speed(t) { const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = Zt(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: t = Ck, onPlay: n, startTime: r } = this.options; this.driver || (this.driver = t(i => this.tick(i))), n && n(); const s = this.driver.now(); this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = s) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var t; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: t } = this.options; t && t() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } } const Tk = new Set(["opacity", "clipPath", "filter", "transform"]); function kk(e, t, n, { delay: r = 0, duration: s = 300, repeat: i = 0, repeatType: o = "loop", ease: a = "easeInOut", times: l } = {}) { const u = { [t]: n }; l && (u.offset = l); const c = h0(a, s); return Array.isArray(c) && (u.easing = c), e.animate(u, { delay: r, duration: s, easing: Array.isArray(c) ? "linear" : c, fill: "both", iterations: i + 1, direction: o === "reverse" ? "alternate" : "normal" }) } const Rk = kd(() => Object.hasOwnProperty.call(Element.prototype, "animate")), pa = 10, bk = 2e4; function Ak(e) { return Ud(e.type) || e.type === "spring" || !f0(e.ease) } function Mk(e, t) { const n = new ef({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: e[0] }; const s = []; let i = 0; for (; !r.done && i < bk;)r = n.sample(i), s.push(r.value), i += pa; return { times: void 0, keyframes: s, duration: i - pa, ease: "linear" } } const G0 = { anticipate: T0, backInOut: E0, circInOut: R0 }; function Dk(e) { return e in G0 } class hp extends B0 { constructor(t) { super(t); const { name: n, motionValue: r, element: s, keyframes: i } = this.options; this.resolver = new U0(i, (o, a) => this.onKeyframesResolved(o, a), n, r, s), this.resolver.scheduleResolve() } initPlayback(t, n) { var r; let { duration: s = 300, times: i, ease: o, type: a, motionValue: l, name: u, startTime: c } = this.options; if (!(!((r = l.owner) === null || r === void 0) && r.current)) return !1; if (typeof o == "string" && da() && Dk(o) && (o = G0[o]), Ak(this.options)) { const { onComplete: f, onUpdate: m, motionValue: x, element: v, ...S } = this.options, p = Mk(t, S); t = p.keyframes, t.length === 1 && (t[1] = t[0]), s = p.duration, i = p.times, o = p.ease, a = "keyframes" } const d = kk(l.owner.current, u, t, { ...this.options, duration: s, times: i, ease: o }); return d.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (Xh(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => { const { onComplete: f } = this.options; l.set($a(t, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise() }, { animation: d, duration: s, times: i, type: a, ease: o, keyframes: t } } get duration() { const { resolved: t } = this; if (!t) return 0; const { duration: n } = t; return Zt(n) } get time() { const { resolved: t } = this; if (!t) return 0; const { animation: n } = t; return Zt(n.currentTime || 0) } set time(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.currentTime = qt(t) } get speed() { const { resolved: t } = this; if (!t) return 1; const { animation: n } = t; return n.playbackRate } set speed(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.playbackRate = t } get state() { const { resolved: t } = this; if (!t) return "idle"; const { animation: n } = t; return n.playState } get startTime() { const { resolved: t } = this; if (!t) return null; const { animation: n } = t; return n.startTime } attachTimeline(t) { if (!this._resolved) this.pendingTimeline = t; else { const { resolved: n } = this; if (!n) return Je; const { animation: r } = n; Xh(r, t) } return Je } play() { if (this.isStopped) return; const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.playState === "finished" && this.updateFinishedPromise(), n.play() } pause() { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: t } = this; if (!t) return; const { animation: n, keyframes: r, duration: s, type: i, ease: o, times: a } = t; if (n.playState === "idle" || n.playState === "finished") return; if (this.time) { const { motionValue: u, onUpdate: c, onComplete: d, element: f, ...m } = this.options, x = new ef({ ...m, keyframes: r, duration: s, type: i, ease: o, times: a, isGenerator: !0 }), v = qt(this.time); u.setWithVelocity(x.sample(v - pa).value, x.sample(v).value, pa) } const { onStop: l } = this.options; l && l(), this.cancel() } complete() { const { resolved: t } = this; t && t.animation.finish() } cancel() { const { resolved: t } = this; t && t.animation.cancel() } static supports(t) { const { motionValue: n, name: r, repeatDelay: s, repeatType: i, damping: o, type: a } = t; return Rk() && r && Tk.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !s && i !== "mirror" && o !== 0 && a !== "inertia" } } const Nk = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, Lk = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), jk = { type: "keyframes", duration: .8 }, Ok = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, _k = (e, { keyframes: t }) => t.length > 2 ? jk : Es.has(e) ? e.startsWith("scale") ? Lk(t[1]) : Nk : Ok; function Ik({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: i, repeatType: o, repeatDelay: a, from: l, elapsed: u, ...c }) { return !!Object.keys(c).length } const tf = (e, t, n, r = {}, s, i) => o => { const a = zd(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - qt(l); let c = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -u, onUpdate: f => { t.set(f), a.onUpdate && a.onUpdate(f) }, onComplete: () => { o(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: i ? void 0 : s }; Ik(a) || (c = { ...c, ..._k(e, c) }), c.duration && (c.duration = qt(c.duration)), c.repeatDelay && (c.repeatDelay = qt(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from); let d = !1; if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (d = !0)), d && !i && t.get() !== void 0) { const f = $a(c.keyframes, a); if (f !== void 0) return te.update(() => { c.onUpdate(f), c.onComplete() }), new rT([]) } return !i && hp.supports(c) ? new hp(c) : new ef(c) }; function Fk({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function X0(e, t, { delay: n = 0, transitionOverride: r, type: s } = {}) { var i; let { transition: o = e.getDefaultTransition(), transitionEnd: a, ...l } = t; r && (o = r); const u = [], c = s && e.animationState && e.animationState.getState()[s]; for (const d in l) { const f = e.getValue(d, (i = e.latestValues[d]) !== null && i !== void 0 ? i : null), m = l[d]; if (m === void 0 || c && Fk(c, d)) continue; const x = { delay: n, ...zd(o || {}, d) }; let v = !1; if (window.MotionHandoffAnimation) { const p = w0(e); if (p) { const h = window.MotionHandoffAnimation(p, d, te); h !== null && (x.startTime = h, v = !0) } } tc(e, d), f.start(tf(d, f, m, e.shouldReduceMotion && g0.has(d) ? { type: !1 } : x, e, v)); const S = f.animation; S && u.push(S) } return a && Promise.all(u).then(() => { te.update(() => { a && gT(e, a) }) }), u } function lc(e, t, n = {}) { var r; const s = Ba(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0); let { transition: i = e.getDefaultTransition() || {} } = s || {}; n.transitionOverride && (i = n.transitionOverride); const o = s ? () => Promise.all(X0(e, s, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (u = 0) => { const { delayChildren: c = 0, staggerChildren: d, staggerDirection: f } = i; return Vk(e, t, c + u, d, f, n) } : () => Promise.resolve(), { when: l } = i; if (l) { const [u, c] = l === "beforeChildren" ? [o, a] : [a, o]; return u().then(() => c()) } else return Promise.all([o(), a(n.delay)]) } function Vk(e, t, n = 0, r = 0, s = 1, i) { const o = [], a = (e.variantChildren.size - 1) * r, l = s === 1 ? (u = 0) => u * r : (u = 0) => a - u * r; return Array.from(e.variantChildren).sort(zk).forEach((u, c) => { u.notify("AnimationStart", t), o.push(lc(u, t, { ...i, delay: n + l(c) }).then(() => u.notify("AnimationComplete", t))) }), Promise.all(o) } function zk(e, t) { return e.sortNodePosition(t) } function Uk(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const s = t.map(i => lc(e, i, n)); r = Promise.all(s) } else if (typeof t == "string") r = lc(e, t, n); else { const s = typeof t == "function" ? Ba(e, t, n.custom) : t; r = Promise.all(X0(e, s, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } const Bk = bd.length; function Y0(e) { if (!e) return; if (!e.isControllingVariants) { const n = e.parent ? Y0(e.parent) || {} : {}; return e.props.initial !== void 0 && (n.initial = e.props.initial), n } const t = {}; for (let n = 0; n < Bk; n++) { const r = bd[n], s = e.props[r]; (Ti(s) || s === !1) && (t[r] = s) } return t } const $k = [...Rd].reverse(), Wk = Rd.length; function Hk(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => Uk(e, n, r))) } function Kk(e) { let t = Hk(e), n = pp(), r = !0; const s = l => (u, c) => { var d; const f = Ba(e, c, l === "exit" ? (d = e.presenceContext) === null || d === void 0 ? void 0 : d.custom : void 0); if (f) { const { transition: m, transitionEnd: x, ...v } = f; u = { ...u, ...v, ...x } } return u }; function i(l) { t = l(e) } function o(l) { const { props: u } = e, c = Y0(e.parent) || {}, d = [], f = new Set; let m = {}, x = 1 / 0; for (let S = 0; S < Wk; S++) { const p = $k[S], h = n[p], g = u[p] !== void 0 ? u[p] : c[p], P = Ti(g), E = p === l ? h.isActive : null; E === !1 && (x = S); let R = g === c[p] && g !== u[p] && P; if (R && r && e.manuallyAnimateOnMount && (R = !1), h.protectedKeys = { ...m }, !h.isActive && E === null || !g && !h.prevProp || za(g) || typeof g == "boolean") continue; const k = Qk(h.prevProp, g); let T = k || p === l && h.isActive && !R && P || S > x && P, b = !1; const M = Array.isArray(g) ? g : [g]; let F = M.reduce(s(p), {}); E === !1 && (F = {}); const { prevResolvedValues: j = {} } = h, Oe = { ...j, ...F }, z = X => { T = !0, f.has(X) && (b = !0, f.delete(X)), h.needsAnimating[X] = !0; const D = e.getValue(X); D && (D.liveStyle = !1) }; for (const X in Oe) { const D = F[X], O = j[X]; if (m.hasOwnProperty(X)) continue; let V = !1; Zu(D) && Zu(O) ? V = !u0(D, O) : V = D !== O, V ? D != null ? z(X) : f.add(X) : D !== void 0 && f.has(X) ? z(X) : h.protectedKeys[X] = !0 } h.prevProp = g, h.prevResolvedValues = F, h.isActive && (m = { ...m, ...F }), r && e.blockInitialAnimation && (T = !1), T && (!(R && k) || b) && d.push(...M.map(X => ({ animation: X, options: { type: p } }))) } if (f.size) { const S = {}; f.forEach(p => { const h = e.getBaseTarget(p), g = e.getValue(p); g && (g.liveStyle = !0), S[p] = h ?? null }), d.push({ animation: S }) } let v = !!d.length; return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (v = !1), r = !1, v ? t(d) : Promise.resolve() } function a(l, u) { var c; if (n[l].isActive === u) return Promise.resolve(); (c = e.variantChildren) === null || c === void 0 || c.forEach(f => { var m; return (m = f.animationState) === null || m === void 0 ? void 0 : m.setActive(l, u) }), n[l].isActive = u; const d = o(l); for (const f in n) n[f].protectedKeys = {}; return d } return { animateChanges: o, setActive: a, setAnimateFunction: i, getState: () => n, reset: () => { n = pp(), r = !0 } } } function Qk(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !u0(t, e) : !1 } function Hn(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function pp() { return { animate: Hn(!0), whileInView: Hn(), whileHover: Hn(), whileTap: Hn(), whileDrag: Hn(), whileFocus: Hn(), exit: Hn() } } class $n { constructor(t) { this.isMounted = !1, this.node = t } update() { } } class Gk extends $n { constructor(t) { super(t), t.animationState || (t.animationState = Kk(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); za(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this) } } let Xk = 0; class Yk extends $n { constructor() { super(...arguments), this.id = Xk++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const s = this.node.animationState.setActive("exit", !t); n && !t && s.then(() => n(this.id)) } mount() { const { register: t } = this.node.presenceContext || {}; t && (this.unmount = t(this.id)) } unmount() { } } const qk = { animation: { Feature: Gk }, exit: { Feature: Yk } }; function Ai(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function Hi(e) { return { point: { x: e.pageX, y: e.pageY } } } const Zk = e => t => $d(t) && e(t, Hi(t)); function ni(e, t, n, r) { return Ai(e, t, Zk(n), r) } const mp = (e, t) => Math.abs(e - t); function Jk(e, t) { const n = mp(e.x, t.x), r = mp(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } class q0 { constructor(t, n, { transformPagePoint: r, contextWindow: s, dragSnapToOrigin: i = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const d = Ll(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, m = Jk(d.offset, { x: 0, y: 0 }) >= 3; if (!f && !m) return; const { point: x } = d, { timestamp: v } = Ee; this.history.push({ ...x, timestamp: v }); const { onStart: S, onMove: p } = this.handlers; f || (S && S(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), p && p(this.lastMoveEvent, d) }, this.handlePointerMove = (d, f) => { this.lastMoveEvent = d, this.lastMoveEventInfo = Nl(f, this.transformPagePoint), te.update(this.updatePoint, !0) }, this.handlePointerUp = (d, f) => { this.end(); const { onEnd: m, onSessionEnd: x, resumeAnimation: v } = this.handlers; if (this.dragSnapToOrigin && v && v(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const S = Ll(d.type === "pointercancel" ? this.lastMoveEventInfo : Nl(f, this.transformPagePoint), this.history); this.startEvent && m && m(d, S), x && x(d, S) }, !$d(t)) return; this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.contextWindow = s || window; const o = Hi(t), a = Nl(o, this.transformPagePoint), { point: l } = a, { timestamp: u } = Ee; this.history = [{ ...l, timestamp: u }]; const { onSessionStart: c } = n; c && c(t, Ll(a, this.history)), this.removeListeners = Wi(ni(this.contextWindow, "pointermove", this.handlePointerMove), ni(this.contextWindow, "pointerup", this.handlePointerUp), ni(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), Fn(this.updatePoint) } } function Nl(e, t) { return t ? { point: t(e.point) } : e } function yp(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Ll({ point: e }, t) { return { point: e, delta: yp(e, Z0(t)), offset: yp(e, eR(t)), velocity: tR(t, .1) } } function eR(e) { return e[0] } function Z0(e) { return e[e.length - 1] } function tR(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const s = Z0(e); for (; n >= 0 && (r = e[n], !(s.timestamp - r.timestamp > qt(t)));)n--; if (!r) return { x: 0, y: 0 }; const i = Zt(s.timestamp - r.timestamp); if (i === 0) return { x: 0, y: 0 }; const o = { x: (s.x - r.x) / i, y: (s.y - r.y) / i }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } const J0 = 1e-4, nR = 1 - J0, rR = 1 + J0, ew = .01, sR = 0 - ew, iR = 0 + ew; function nt(e) { return e.max - e.min } function oR(e, t, n) { return Math.abs(e - t) <= n } function gp(e, t, n, r = .5) { e.origin = r, e.originPoint = se(t.min, t.max, e.origin), e.scale = nt(n) / nt(t), e.translate = se(n.min, n.max, e.origin) - e.originPoint, (e.scale >= nR && e.scale <= rR || isNaN(e.scale)) && (e.scale = 1), (e.translate >= sR && e.translate <= iR || isNaN(e.translate)) && (e.translate = 0) } function ri(e, t, n, r) { gp(e.x, t.x, n.x, r ? r.originX : void 0), gp(e.y, t.y, n.y, r ? r.originY : void 0) } function vp(e, t, n) { e.min = n.min + t.min, e.max = e.min + nt(t) } function aR(e, t, n) { vp(e.x, t.x, n.x), vp(e.y, t.y, n.y) } function wp(e, t, n) { e.min = t.min - n.min, e.max = e.min + nt(t) } function si(e, t, n) { wp(e.x, t.x, n.x), wp(e.y, t.y, n.y) } function lR(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? se(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? se(n, e, r.max) : Math.min(e, n)), e } function xp(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function uR(e, { top: t, left: n, bottom: r, right: s }) { return { x: xp(e.x, n, s), y: xp(e.y, t, r) } } function Sp(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function cR(e, t) { return { x: Sp(e.x, t.x), y: Sp(e.y, t.y) } } function dR(e, t) { let n = .5; const r = nt(e), s = nt(t); return s > r ? n = hs(t.min, t.max - r, e.min) : r > s && (n = hs(e.min, e.max - s, t.min)), sn(0, 1, n) } function fR(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const uc = .35; function hR(e = uc) { return e === !1 ? e = 0 : e === !0 && (e = uc), { x: Cp(e, "left", "right"), y: Cp(e, "top", "bottom") } } function Cp(e, t, n) { return { min: Pp(e, t), max: Pp(e, n) } } function Pp(e, t) { return typeof e == "number" ? e : e[t] || 0 } const Ep = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Or = () => ({ x: Ep(), y: Ep() }), Tp = () => ({ min: 0, max: 0 }), de = () => ({ x: Tp(), y: Tp() }); function ot(e) { return [e("x"), e("y")] } function tw({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function pR({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function mR(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function jl(e) { return e === void 0 || e === 1 } function cc({ scale: e, scaleX: t, scaleY: n }) { return !jl(e) || !jl(t) || !jl(n) } function Gn(e) { return cc(e) || nw(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function nw(e) { return kp(e.x) || kp(e.y) } function kp(e) { return e && e !== "0%" } function ma(e, t, n) { const r = e - n, s = t * r; return n + s } function Rp(e, t, n, r, s) { return s !== void 0 && (e = ma(e, s, r)), ma(e, n, r) + t } function dc(e, t = 0, n = 1, r, s) { e.min = Rp(e.min, t, n, r, s), e.max = Rp(e.max, t, n, r, s) } function rw(e, { x: t, y: n }) { dc(e.x, t.translate, t.scale, t.originPoint), dc(e.y, n.translate, n.scale, n.originPoint) } const bp = .999999999999, Ap = 1.0000000000001; function yR(e, t, n, r = !1) { const s = n.length; if (!s) return; t.x = t.y = 1; let i, o; for (let a = 0; a < s; a++) { i = n[a], o = i.projectionDelta; const { visualElement: l } = i.options; l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && Ir(e, { x: -i.scroll.offset.x, y: -i.scroll.offset.y }), o && (t.x *= o.x.scale, t.y *= o.y.scale, rw(e, o)), r && Gn(i.latestValues) && Ir(e, i.latestValues)) } t.x < Ap && t.x > bp && (t.x = 1), t.y < Ap && t.y > bp && (t.y = 1) } function _r(e, t) { e.min = e.min + t, e.max = e.max + t } function Mp(e, t, n, r, s = .5) { const i = se(e.min, e.max, s); dc(e, t, n, i, r) } function Ir(e, t) { Mp(e.x, t.x, t.scaleX, t.scale, t.originX), Mp(e.y, t.y, t.scaleY, t.scale, t.originY) } function sw(e, t) { return tw(mR(e.getBoundingClientRect(), t)) } function gR(e, t, n) { const r = sw(e, n), { scroll: s } = t; return s && (_r(r.x, s.offset.x), _r(r.y, s.offset.y)), r } const iw = ({ current: e }) => e ? e.ownerDocument.defaultView : null, vR = new WeakMap; class wR { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = de(), this.visualElement = t } start(t, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const s = c => { const { dragSnapToOrigin: d } = this.getProps(); d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(Hi(c).point) }, i = (c, d) => { const { drag: f, dragPropagation: m, onDragStart: x } = this.getProps(); if (f && !m && (this.openDragLock && this.openDragLock(), this.openDragLock = fT(f), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ot(S => { let p = this.getAxisMotionValue(S).get() || 0; if (It.test(p)) { const { projection: h } = this.visualElement; if (h && h.layout) { const g = h.layout.layoutBox[S]; g && (p = nt(g) * (parseFloat(p) / 100)) } } this.originPoint[S] = p }), x && te.postRender(() => x(c, d)), tc(this.visualElement, "transform"); const { animationState: v } = this.visualElement; v && v.setActive("whileDrag", !0) }, o = (c, d) => { const { dragPropagation: f, dragDirectionLock: m, onDirectionLock: x, onDrag: v } = this.getProps(); if (!f && !this.openDragLock) return; const { offset: S } = d; if (m && this.currentDirection === null) { this.currentDirection = xR(S), this.currentDirection !== null && x && x(this.currentDirection); return } this.updateAxis("x", d.point, S), this.updateAxis("y", d.point, S), this.visualElement.render(), v && v(c, d) }, a = (c, d) => this.stop(c, d), l = () => ot(c => { var d; return this.getAnimationState(c) === "paused" && ((d = this.getAxisMotionValue(c).animation) === null || d === void 0 ? void 0 : d.play()) }), { dragSnapToOrigin: u } = this.getProps(); this.panSession = new q0(t, { onSessionStart: s, onStart: i, onMove: o, onSessionEnd: a, resumeAnimation: l }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: u, contextWindow: iw(this.visualElement) }) } stop(t, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: s } = n; this.startAnimation(s); const { onDragEnd: i } = this.getProps(); i && te.postRender(() => i(t, n)) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(t, n, r) { const { drag: s } = this.getProps(); if (!r || !vo(t, s, this.currentDirection)) return; const i = this.getAxisMotionValue(t); let o = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (o = lR(o, this.constraints[t], this.elastic[t])), i.set(o) } resolveConstraints() { var t; const { dragConstraints: n, dragElastic: r } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, i = this.constraints; n && Lr(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && s ? this.constraints = uR(s.layoutBox, n) : this.constraints = !1, this.elastic = hR(r), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && ot(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = fR(s.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !Lr(t)) return !1; const r = t.current, { projection: s } = this.visualElement; if (!s || !s.layout) return !1; const i = gR(r, s.root, this.visualElement.getTransformPagePoint()); let o = cR(s.layout.layoutBox, i); if (n) { const a = n(pR(o)); this.hasMutatedConstraints = !!a, a && (o = tw(a)) } return o } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = ot(c => { if (!vo(c, n, this.currentDirection)) return; let d = l[c] || {}; o && (d = { min: 0, max: 0 }); const f = s ? 200 : 1e6, m = s ? 40 : 1e7, x = { type: "inertia", velocity: r ? t[c] : 0, bounceStiffness: f, bounceDamping: m, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...d }; return this.startAxisValueAnimation(c, x) }); return Promise.all(u).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return tc(this.visualElement, t), r.start(tf(t, r, 0, n, this.visualElement, !1)) } stopAnimation() { ot(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { ot(t => { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause() }) } getAnimationState(t) { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state } getAxisMotionValue(t) { const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), s = r[n]; return s || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { ot(n => { const { drag: r } = this.getProps(); if (!vo(n, r, this.currentDirection)) return; const { projection: s } = this.visualElement, i = this.getAxisMotionValue(n); if (s && s.layout) { const { min: o, max: a } = s.layout.layoutBox[n]; i.set(t[n] - se(o, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Lr(n) || !r || !this.constraints) return; this.stopAnimation(); const s = { x: 0, y: 0 }; ot(o => { const a = this.getAxisMotionValue(o); if (a && this.constraints !== !1) { const l = a.get(); s[o] = dR({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ot(o => { if (!vo(o, t, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: u } = this.constraints[o]; a.set(se(l, u, s[o])) }) } addListeners() { if (!this.visualElement.current) return; vR.set(this.visualElement, this); const t = this.visualElement.current, n = ni(t, "pointerdown", l => { const { drag: u, dragListener: c = !0 } = this.getProps(); u && c && this.start(l) }), r = () => { const { dragConstraints: l } = this.getProps(); Lr(l) && l.current && (this.constraints = this.resolveRefConstraints()) }, { projection: s } = this.visualElement, i = s.addEventListener("measure", r); s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), te.read(r); const o = Ai(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => { this.isDragging && u && (ot(c => { const d = this.getAxisMotionValue(c); d && (this.originPoint[c] += l[c].translate, d.set(d.get() + l[c].translate)) }), this.visualElement.render()) }); return () => { o(), n(), i(), a && a() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = uc, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: s, dragConstraints: i, dragElastic: o, dragMomentum: a } } } function vo(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function xR(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class SR extends $n { constructor(t) { super(t), this.removeGroupControls = Je, this.removeListeners = Je, this.controls = new wR(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Je } unmount() { this.removeGroupControls(), this.removeListeners() } } const Dp = e => (t, n) => { e && te.postRender(() => e(t, n)) }; class CR extends $n { constructor() { super(...arguments), this.removePointerDownListener = Je } onPointerDown(t) { this.session = new q0(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: iw(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps(); return { onSessionStart: Dp(t), onStart: Dp(n), onMove: r, onEnd: (i, o) => { delete this.session, s && te.postRender(() => s(i, o)) } } } mount() { this.removePointerDownListener = ni(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const _o = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Np(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const _s = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (I.test(e)) e = parseFloat(e); else return e; const n = Np(e, t.target.x), r = Np(e, t.target.y); return `${n}% ${r}%` } }, PR = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, s = Vn.parse(e); if (s.length > 5) return r; const i = Vn.createTransformer(e), o = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; s[0 + o] /= a, s[1 + o] /= l; const u = se(a, l, .5); return typeof s[2 + o] == "number" && (s[2 + o] /= u), typeof s[3 + o] == "number" && (s[3 + o] /= u), i(s) } }; class ER extends y.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: i } = t; AE(TR), i && (n.group && n.group.add(i), r && r.register && s && r.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), _o.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: s, isPresent: i } = this.props, o = r.projection; return o && (o.isPresent = i, s || t.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || te.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Md.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = t; s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function ow(e) { const [t, n] = Bv(), r = y.useContext(Cd); return w.jsx(ER, { ...e, layoutGroup: r, switchLayoutGroup: y.useContext(Yv), isPresent: t, safeToRemove: n }) } const TR = { borderRadius: { ..._s, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: _s, borderTopRightRadius: _s, borderBottomLeftRadius: _s, borderBottomRightRadius: _s, boxShadow: PR }; function kR(e, t, n) { const r = Le(e) ? e : Ri(e); return r.start(tf("", r, t, n)), r.animation } function RR(e) { return e instanceof SVGElement && e.tagName !== "svg" } const bR = (e, t) => e.depth - t.depth; class AR { constructor() { this.children = [], this.isDirty = !1 } add(t) { Wd(this.children, t), this.isDirty = !0 } remove(t) { Hd(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(bR), this.isDirty = !1, this.children.forEach(t) } } function MR(e, t) { const n = Ft.now(), r = ({ timestamp: s }) => { const i = s - n; i >= t && (Fn(r), e(i - t)) }; return te.read(r, !0), () => Fn(r) } const aw = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], DR = aw.length, Lp = e => typeof e == "string" ? parseFloat(e) : e, jp = e => typeof e == "number" || I.test(e); function NR(e, t, n, r, s, i) { s ? (e.opacity = se(0, n.opacity !== void 0 ? n.opacity : 1, LR(r)), e.opacityExit = se(t.opacity !== void 0 ? t.opacity : 1, 0, jR(r))) : i && (e.opacity = se(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let o = 0; o < DR; o++) { const a = `border${aw[o]}Radius`; let l = Op(t, a), u = Op(n, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || jp(l) === jp(u) ? (e[a] = Math.max(se(Lp(l), Lp(u), r), 0), (It.test(u) || It.test(l)) && (e[a] += "%")) : e[a] = u } (t.rotate || n.rotate) && (e.rotate = se(t.rotate || 0, n.rotate || 0, r)) } function Op(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const LR = lw(0, .5, k0), jR = lw(.5, .95, Je); function lw(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(hs(e, t, r)) } function _p(e, t) { e.min = t.min, e.max = t.max } function it(e, t) { _p(e.x, t.x), _p(e.y, t.y) } function Ip(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function Fp(e, t, n, r, s) { return e -= t, e = ma(e, 1 / n, r), s !== void 0 && (e = ma(e, 1 / s, r)), e } function OR(e, t = 0, n = 1, r = .5, s, i = e, o = e) { if (It.test(t) && (t = parseFloat(t), t = se(o.min, o.max, t / 100) - o.min), typeof t != "number") return; let a = se(i.min, i.max, r); e === i && (a -= t), e.min = Fp(e.min, t, n, a, s), e.max = Fp(e.max, t, n, a, s) } function Vp(e, t, [n, r, s], i, o) { OR(e, t[n], t[r], t[s], t.scale, i, o) } const _R = ["x", "scaleX", "originX"], IR = ["y", "scaleY", "originY"]; function zp(e, t, n, r) { Vp(e.x, t, _R, n ? n.x : void 0, r ? r.x : void 0), Vp(e.y, t, IR, n ? n.y : void 0, r ? r.y : void 0) } function Up(e) { return e.translate === 0 && e.scale === 1 } function uw(e) { return Up(e.x) && Up(e.y) } function Bp(e, t) { return e.min === t.min && e.max === t.max } function FR(e, t) { return Bp(e.x, t.x) && Bp(e.y, t.y) } function $p(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function cw(e, t) { return $p(e.x, t.x) && $p(e.y, t.y) } function Wp(e) { return nt(e.x) / nt(e.y) } function Hp(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class VR { constructor() { this.members = [] } add(t) { Wd(this.members, t), t.scheduleRender() } remove(t) { if (Hd(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(s => t === s); if (n === 0) return !1; let r; for (let s = n; s >= 0; s--) { const i = this.members[s]; if (i.isPresent !== !1) { r = i; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); const { crossfade: s } = t.options; s === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function zR(e, t, n) { let r = ""; const s = e.x.translate / t.x, i = e.y.translate / t.y, o = (n == null ? void 0 : n.z) || 0; if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: u, rotate: c, rotateX: d, rotateY: f, skewX: m, skewY: x } = n; u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), d && (r += `rotateX(${d}deg) `), f && (r += `rotateY(${f}deg) `), m && (r += `skewX(${m}deg) `), x && (r += `skewY(${x}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const Xn = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, Ws = typeof window < "u" && window.MotionDebug !== void 0, Ol = ["", "X", "Y", "Z"], UR = { visibility: "hidden" }, Kp = 1e3; let BR = 0; function _l(e, t, n, r) { const { latestValues: s } = t; s[e] && (n[e] = s[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function dw(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const n = w0(t); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: s, layoutId: i } = e.options; window.MotionCancelOptimisedAnimation(n, "transform", te, !(s || i)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && dw(r) } function fw({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) { return class { constructor(o = {}, a = t == null ? void 0 : t()) { this.id = BR++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, Ws && (Xn.totalNodes = Xn.resolvedTargetDeltas = Xn.recalculatedProjection = 0), this.nodes.forEach(HR), this.nodes.forEach(YR), this.nodes.forEach(qR), this.nodes.forEach(KR), Ws && window.MotionDebug.record(Xn) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new AR) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Kd), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } mount(o, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = RR(o), this.instance = o; const { layoutId: l, layout: u, visualElement: c } = this.options; if (c && !c.current && c.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (u || l) && (this.isLayoutDirty = !0), e) { let d; const f = () => this.root.updateBlockedByResize = !1; e(o, () => { this.root.updateBlockedByResize = !0, d && d(), d = MR(f, 250), _o.hasAnimatedSinceResize && (_o.hasAnimatedSinceResize = !1, this.nodes.forEach(Gp)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && c && (l || u) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: m, layout: x }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const v = this.options.transition || c.getDefaultTransition() || nb, { onLayoutAnimationStart: S, onLayoutAnimationComplete: p } = c.getProps(), h = !this.targetLayout || !cw(this.targetLayout, x) || m, g = !f && m; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || g || f && (h || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, g); const P = { ...zd(v, "layout"), onPlay: S, onComplete: p }; (c.shouldReduceMotion || this.options.layoutRoot) && (P.delay = 0, P.type = !1), this.startAnimation(P) } else f || Gp(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = x }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Fn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(ZR), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && dw(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let c = 0; c < this.path.length; c++) { const d = this.path[c]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Qp); return } this.isUpdating || this.nodes.forEach(GR), this.isUpdating = !1, this.nodes.forEach(XR), this.nodes.forEach($R), this.nodes.forEach(WR), this.clearAllSnapshots(); const a = Ft.now(); Ee.delta = sn(0, 1e3 / 60, a - Ee.timestamp), Ee.timestamp = a, Ee.isProcessing = !0, Rl.update.process(Ee), Rl.preRender.process(Ee), Rl.render.process(Ee), Ee.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Md.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(QR), this.sharedNodes.forEach(JR) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, te.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { te.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutCorrected = de(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) { const l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: o, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!s) return; const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !uw(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue; o && (a || Gn(this.latestValues) || c) && (s(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), rb(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var o; const { visualElement: a } = this.options; if (!a) return de(); const l = a.measureViewportBox(); if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(sb))) { const { scroll: c } = this.root; c && (_r(l.x, c.offset.x), _r(l.y, c.offset.y)) } return l } removeElementScroll(o) { var a; const l = de(); if (it(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l; for (let u = 0; u < this.path.length; u++) { const c = this.path[u], { scroll: d, options: f } = c; c !== this.root && d && f.layoutScroll && (d.wasRoot && it(l, o), _r(l.x, d.offset.x), _r(l.y, d.offset.y)) } return l } applyTransform(o, a = !1) { const l = de(); it(l, o); for (let u = 0; u < this.path.length; u++) { const c = this.path[u]; !a && c.options.layoutScroll && c.scroll && c !== c.root && Ir(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), Gn(c.latestValues) && Ir(l, c.latestValues) } return Gn(this.latestValues) && Ir(l, this.latestValues), l } removeTransform(o) { const a = de(); it(a, o); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !Gn(u.latestValues)) continue; cc(u.latestValues) && u.updateSnapshot(); const c = de(), d = u.measurePageBox(); it(c, d), zp(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c) } return Gn(this.latestValues) && zp(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ee.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(o = !1) { var a; const l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); const u = !!this.resumingFrom || this !== l; if (!(o || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: d, layoutId: f } = this.options; if (!(!this.layout || !(d || f))) { if (this.resolvedRelativeTargetAt = Ee.timestamp, !this.targetDelta && !this.relativeTarget) { const m = this.getClosestProjectingParent(); m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = de(), this.relativeTargetOrigin = de(), si(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox), it(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = de(), this.targetWithTransforms = de()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), aR(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : it(this.target, this.layout.layoutBox), rw(this.target, this.targetDelta)) : it(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const m = this.getClosestProjectingParent(); m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = de(), this.relativeTargetOrigin = de(), si(this.relativeTargetOrigin, this.target, m.target), it(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Ws && Xn.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || cc(this.parent.latestValues) || nw(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var o; const a = this.getLead(), l = !!this.resumingFrom || this !== a; let u = !0; if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Ee.timestamp && (u = !1), u) return; const { layout: c, layoutId: d } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || d)) return; it(this.layoutCorrected, this.layout.layoutBox); const f = this.treeScale.x, m = this.treeScale.y; yR(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = de()); const { target: x } = a; if (!x) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Ip(this.prevProjectionDelta.x, this.projectionDelta.x), Ip(this.prevProjectionDelta.y, this.projectionDelta.y)), ri(this.projectionDelta, this.layoutCorrected, x, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== m || !Hp(this.projectionDelta.x, this.prevProjectionDelta.x) || !Hp(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", x)), Ws && Xn.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { var a; if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Or(), this.projectionDelta = Or(), this.projectionDeltaWithTransform = Or() } setAnimationOrigin(o, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, d = Or(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const f = de(), m = l ? l.source : void 0, x = this.layout ? this.layout.source : void 0, v = m !== x, S = this.getStack(), p = !S || S.members.length <= 1, h = !!(v && !p && this.options.crossfade === !0 && !this.path.some(tb)); this.animationProgress = 0; let g; this.mixTargetDelta = P => { const E = P / 1e3; Xp(d.x, o.x, E), Xp(d.y, o.y, E), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (si(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), eb(this.relativeTarget, this.relativeTargetOrigin, f, E), g && FR(this.relativeTarget, g) && (this.isProjectionDirty = !1), g || (g = de()), it(g, this.relativeTarget)), v && (this.animationValues = c, NR(c, u, this.latestValues, E, h, p)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = E }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Fn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = te.update(() => { _o.hasAnimatedSinceResize = !0, this.currentAnimation = kR(0, Kp, { ...o, onUpdate: a => { this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a) }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Kp), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = o; if (!(!a || !l || !u)) { if (this !== o && this.layout && u && hw(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || de(); const d = nt(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + d; const f = nt(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + f } it(a, l), Ir(a, c), ri(this.projectionDeltaWithTransform, this.layoutCorrected, a, c) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new VR), this.sharedNodes.get(o).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var o; const { layoutId: a } = this.options; return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this } getPrevLead() { var o; const { layoutId: a } = this.options; return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const u = {}; l.z && _l("z", o, u, this.animationValues); for (let c = 0; c < Ol.length; c++)_l(`rotate${Ol[c]}`, o, u, this.animationValues), _l(`skew${Ol[c]}`, o, u, this.animationValues); o.render(); for (const c in u) o.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]); o.scheduleRender() } getProjectionStyles(o) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return UR; const u = { visibility: "" }, c = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, u.opacity = "", u.pointerEvents = jo(o == null ? void 0 : o.pointerEvents) || "", u.transform = c ? c(this.latestValues, "") : "none", u; const d = this.getLead(); if (!this.projectionDelta || !this.layout || !d.target) { const v = {}; return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, v.pointerEvents = jo(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Gn(this.latestValues) && (v.transform = c ? c({}, "") : "none", this.hasProjected = !1), v } const f = d.animationValues || d.latestValues; this.applyTransformsToTarget(), u.transform = zR(this.projectionDeltaWithTransform, this.treeScale, f), c && (u.transform = c(f, u.transform)); const { x: m, y: x } = this.projectionDelta; u.transformOrigin = `${m.origin * 100}% ${x.origin * 100}% 0`, d.animationValues ? u.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : u.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0; for (const v in ca) { if (f[v] === void 0) continue; const { correct: S, applyTo: p } = ca[v], h = u.transform === "none" ? f[v] : S(f[v], d); if (p) { const g = p.length; for (let P = 0; P < g; P++)u[p[P]] = h } else u[v] = h } return this.options.layoutId && (u.pointerEvents = d === this ? jo(o == null ? void 0 : o.pointerEvents) || "" : "none"), u } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(Qp), this.root.sharedNodes.clear() } } } function $R(e) { e.updateLayout() } function WR(e) { var t; const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: s } = e.layout, { animationType: i } = e.options, o = n.source !== e.layout.source; i === "size" ? ot(d => { const f = o ? n.measuredBox[d] : n.layoutBox[d], m = nt(f); f.min = r[d].min, f.max = f.min + m }) : hw(i, n.layoutBox, r) && ot(d => { const f = o ? n.measuredBox[d] : n.layoutBox[d], m = nt(r[d]); f.max = f.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + m) }); const a = Or(); ri(a, r, n.layoutBox); const l = Or(); o ? ri(l, e.applyTransform(s, !0), n.measuredBox) : ri(l, r, n.layoutBox); const u = !uw(a); let c = !1; if (!e.resumeFrom) { const d = e.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: f, layout: m } = d; if (f && m) { const x = de(); si(x, n.layoutBox, f.layoutBox); const v = de(); si(v, r, m.layoutBox), cw(x, v) || (c = !0), d.options.layoutRoot && (e.relativeTarget = v, e.relativeTargetOrigin = x, e.relativeParent = d) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeTargetChanged: c }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function HR(e) { Ws && Xn.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function KR(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function QR(e) { e.clearSnapshot() } function Qp(e) { e.clearMeasurements() } function GR(e) { e.isLayoutDirty = !1 } function XR(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function Gp(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function YR(e) { e.resolveTargetDelta() } function qR(e) { e.calcProjection() } function ZR(e) { e.resetSkewAndRotation() } function JR(e) { e.removeLeadSnapshot() } function Xp(e, t, n) { e.translate = se(t.translate, 0, n), e.scale = se(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Yp(e, t, n, r) { e.min = se(t.min, n.min, r), e.max = se(t.max, n.max, r) } function eb(e, t, n, r) { Yp(e.x, t.x, n.x, r), Yp(e.y, t.y, n.y, r) } function tb(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const nb = { duration: .45, ease: [.4, 0, .1, 1] }, qp = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Zp = qp("applewebkit/") && !qp("chrome/") ? Math.round : Je; function Jp(e) { e.min = Zp(e.min), e.max = Zp(e.max) } function rb(e) { Jp(e.x), Jp(e.y) } function hw(e, t, n) { return e === "position" || e === "preserve-aspect" && !oR(Wp(t), Wp(n), .2) } function sb(e) { var t; return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot) } const ib = fw({ attachResizeListener: (e, t) => Ai(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Il = { current: void 0 }, pw = fw({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Il.current) { const e = new ib({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Il.current = e } return Il.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), ob = { pan: { Feature: CR }, drag: { Feature: SR, ProjectionNode: pw, MeasureLayout: ow } }; function em(e, t, n) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start"); const s = "onHover" + n, i = r[s]; i && te.postRender(() => i(t, Hi(t))) } class ab extends $n { mount() { const { current: t } = this.node; t && (this.unmount = aT(t, n => (em(this.node, n, "Start"), r => em(this.node, r, "End")))) } unmount() { } } class lb extends $n { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Wi(Ai(this.node.current, "focus", () => this.onFocus()), Ai(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function tm(e, t, n) { const { props: r } = e; e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start"); const s = "onTap" + (n === "End" ? "" : n), i = r[s]; i && te.postRender(() => i(t, Hi(t))) } class ub extends $n { mount() { const { current: t } = this.node; t && (this.unmount = dT(t, n => (tm(this.node, n, "Start"), (r, { success: s }) => tm(this.node, r, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const fc = new WeakMap, Fl = new WeakMap, cb = e => { const t = fc.get(e.target); t && t(e) }, db = e => { e.forEach(cb) }; function fb({ root: e, ...t }) { const n = e || document; Fl.has(n) || Fl.set(n, {}); const r = Fl.get(n), s = JSON.stringify(t); return r[s] || (r[s] = new IntersectionObserver(db, { root: e, ...t })), r[s] } function hb(e, t, n) { const r = fb(t); return fc.set(e, n), r.observe(e), () => { fc.delete(e), r.unobserve(e) } } const pb = { some: 0, all: 1 }; class mb extends $n { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: i } = t, o = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof s == "number" ? s : pb[s] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, i && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: c, onViewportLeave: d } = this.node.getProps(), f = u ? c : d; f && f(l) }; return hb(this.node.current, o, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(yb(t, n)) && this.startObserver() } unmount() { } } function yb({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const gb = { inView: { Feature: mb }, tap: { Feature: ub }, focus: { Feature: lb }, hover: { Feature: ab } }, vb = { layout: { ProjectionNode: pw, MeasureLayout: ow } }, hc = { current: null }, mw = { current: !1 }; function wb() { if (mw.current = !0, !!Td) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => hc.current = e.matches; e.addListener(t), t() } else hc.current = !1 } const xb = [...z0, Me, Vn], Sb = e => xb.find(V0(e)), nm = new WeakMap; function Cb(e, t, n) { for (const r in t) { const s = t[r], i = n[r]; if (Le(s)) e.addValue(r, s); else if (Le(i)) e.addValue(r, Ri(s, { owner: e })); else if (i !== s) if (e.hasValue(r)) { const o = e.getValue(r); o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s) } else { const o = e.getStaticValue(r); e.addValue(r, Ri(o !== void 0 ? o : s, { owner: e })) } } for (const r in n) t[r] === void 0 && e.removeValue(r); return t } const rm = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class Pb { scrapeMotionValuesFromProps(t, n, r) { return {} } constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: s, blockInitialAnimation: i, visualState: o }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Zd, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const f = Ft.now(); this.renderScheduledAt < f && (this.renderScheduledAt = f, te.render(this.render, !1, !0)) }; const { latestValues: l, renderState: u } = o; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = Ua(n), this.isVariantNode = Gv(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: c, ...d } = this.scrapeMotionValuesFromProps(n, {}, this); for (const f in d) { const m = d[f]; l[f] !== void 0 && Le(m) && m.set(l[f], !1) } } mount(t) { this.current = t, nm.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), mw.current || wb(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : hc.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { nm.delete(this.current), this.projection && this.projection.unmount(), Fn(this.notifyUpdate), Fn(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const t in this.events) this.events[t].clear(); for (const t in this.features) { const n = this.features[t]; n && (n.unmount(), n.isMounted = !1) } this.current = null } bindToMotionValue(t, n) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); const r = Es.has(t), s = n.on("change", a => { this.latestValues[t] = a, this.props.onUpdate && te.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), i = n.on("renderRequest", this.scheduleRender); let o; window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => { s(), i(), o && o(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in ps) { const n = ps[t]; if (!n) continue; const { isEnabled: r, Feature: s } = n; if (!this.features[t] && s && r(this.props) && (this.features[t] = new s(this)), this.features[t]) { const i = this.features[t]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : de() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < rm.length; r++) { const s = rm[r]; this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]); const i = "on" + s, o = t[i]; o && (this.propEventSubscriptions[s] = this.on(s, o)) } this.prevMotionValues = Cb(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { const r = this.values.get(t); n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get()) } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = Ri(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { var r; let s = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options); return s != null && (typeof s == "string" && (I0(s) || b0(s)) ? s = parseFloat(s) : !Sb(s) && Vn.test(n) && (s = j0(t, n)), this.setBaseTarget(t, Le(s) ? s.get() : s)), Le(s) ? s.get() : s } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var n; const { initial: r } = this.props; let s; if (typeof r == "string" || typeof r == "object") { const o = Ld(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom); o && (s = o[t]) } if (r && s !== void 0) return s; const i = this.getBaseTargetFromProps(this.props, t); return i !== void 0 && !Le(i) ? i : this.initialValues[t] !== void 0 && s === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new Kd), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } } class yw extends Pb { constructor() { super(...arguments), this.KeyframeResolver = U0 } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { return t.style ? t.style[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; Le(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function Eb(e) { return window.getComputedStyle(e) } class Tb extends yw { constructor() { super(...arguments), this.type = "html", this.renderInstance = Zv } readValueFromInstance(t, n) { if (Es.has(n)) { const r = qd(n); return r && r.default || 0 } else { const r = Eb(t), s = (o0(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof s == "string" ? s.trim() : s } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return sw(t, n) } build(t, n, r) { Id(t, n, r.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return Nd(t, n, r) } } class kb extends yw { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = de } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (Es.has(n)) { const r = qd(n); return r && r.default || 0 } return n = Jv.has(n) ? n : Ad(n), t.getAttribute(n) } scrapeMotionValuesFromProps(t, n, r) { return n0(t, n, r) } build(t, n, r) { Fd(t, n, this.isSVGTag, r.transformTemplate) } renderInstance(t, n, r, s) { e0(t, n, r, s) } mount(t) { this.isSVGTag = Vd(t.tagName), super.mount(t) } } const Rb = (e, t) => Dd(e) ? new kb(t) : new Tb(t, { allowProjection: e !== y.Fragment }), bb = eT({ ...qk, ...gb, ...ob, ...vb }, Rb), Se = yE(bb); function gw({ className: e, animate: t = !1 }) { return w.jsxs(Se.svg, { xmlns: "http://www.w3.org/2000/svg", width: "52", height: "52", viewBox: "0 0 52 52", fill: "none", className: Y("w-[52px] h-[52px]", e), initial: t ? { rotate: 0 } : void 0, animate: t ? { rotate: 360 } : void 0, transition: t ? { duration: 2, repeat: 1 / 0, ease: "linear" } : void 0, children: [w.jsx(Se.path, { fillRule: "evenodd", clipRule: "evenodd", d: "M23.554 41.2204C24.92 44.3354 25.603 47.6638 25.603 51.2055C25.603 47.6638 26.264 44.3354 27.587 41.2204C28.952 38.1054 30.787 35.3958 33.091 33.0916C35.396 30.7873 38.105 28.9738 41.22 27.651C44.335 26.2855 47.664 25.6028 51.205 25.6028C47.664 25.6028 44.335 24.9414 41.22 23.6185C38.105 22.2531 35.396 20.4182 33.091 18.114C30.787 15.8097 28.952 13.1001 27.587 9.98507C26.264 6.87007 25.603 3.54171 25.603 0C25.603 3.54171 24.92 6.87007 23.554 9.98507C22.232 13.1001 20.418 15.8097 18.114 18.114C15.81 20.4182 13.1 22.2531 9.985 23.6185C6.87 24.9414 3.542 25.6028 0 25.6028C3.542 25.6028 6.87 26.2855 9.985 27.651C13.1 28.9738 15.81 30.7873 18.114 33.0916C20.418 35.3958 22.232 38.1054 23.554 41.2204Z", fill: "url(#paint0_linear_39_18)", initial: t ? void 0 : { scale: .8, opacity: 0 }, animate: t ? void 0 : { scale: 1, opacity: 1 }, transition: t ? void 0 : { duration: .8, ease: [.16, 1, .3, 1] } }), w.jsx("defs", { children: w.jsx(Se.linearGradient, { id: "paint0_linear_39_18", gradientUnits: "userSpaceOnUse", animate: t ? { x1: "6.20579", y1: "43.7756", x2: "41.9987", y2: "38.2037" } : { x1: ["-20", "30", "-20"], y1: ["60", "0", "60"], x2: ["70", "20", "70"], y2: ["-10", "50", "-10"] }, transition: t ? void 0 : { duration: 6, repeat: 1 / 0, ease: "easeInOut" }, children: t ? w.jsxs(w.Fragment, { children: [w.jsx("stop", { stopColor: "#439DDF" }), w.jsx("stop", { offset: "0.524208", stopColor: "#4F87ED" }), w.jsx("stop", { offset: "0.781452", stopColor: "#9476C5" }), w.jsx("stop", { offset: "0.888252", stopColor: "#BC688E" }), w.jsx("stop", { offset: "1", stopColor: "#D6645D" })] }) : w.jsxs(w.Fragment, { children: [w.jsx(Se.stop, { animate: { stopColor: ["#439DDF", "#4F87ED", "#439DDF"], offset: ["0", "0.3", "0"] }, transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } }), w.jsx(Se.stop, { animate: { stopColor: ["#4F87ED", "#9476C5", "#4F87ED"], offset: ["0.4", "0.8", "0.4"] }, transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } }), w.jsx(Se.stop, { animate: { stopColor: ["#9476C5", "#BC688E", "#9476C5"], offset: ["0.65", "0.9", "0.65"] }, transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } }), w.jsx(Se.stop, { animate: { stopColor: ["#BC688E", "#D6645D", "#BC688E"], offset: ["0.8", "1", "0.8"] }, transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } }), w.jsx(Se.stop, { animate: { stopColor: ["#D6645D", "#439DDF", "#D6645D"] }, offset: "1", transition: { duration: 6, repeat: 1 / 0, ease: "easeInOut" } })] }) }) })] }) } function Ab() {
  const [e, t] = y.useState(""), [, n] = Sd(), r = s => { s.preventDefault(), e.trim() && n(`/search?q=${encodeURIComponent(e.trim())}`) }; return w.jsxs("div", {
    className: "min-h-screen flex flex-col items-center justify-center bg-background", children: [w.jsx(sE, {}), w.jsxs("div", {
      className: "w-full max-w-3xl px-4 animate-fade-in", children: [w.jsxs("div", { className: "flex flex-col items-center mb-8", children: [w.jsx(gw, { className: "mb-6" }), w.jsx("h1", { className: "text-2xl lg:text-4xl font-bold text-center bg-clip-text text-transparent bg-gradient-to-r from-gray-900 to-gray-600 dark:from-white dark:to-gray-200", children: "What do you want to know?" })] }), w.jsx("form", {
        onSubmit: r, className: "w-full", children: w.jsxs("div", {
          className: "relative group", children: [w.jsx("input", {
            type: "text", value: e, onChange: s => t(s.target.value), placeholder: "Ask anything...", className: `w-full px-6 py-4 text-lg rounded-full border border-gray-200 
                       focus:border-google-blue focus:ring-4 focus:ring-google-blue/20 outline-none 
                       transition-all duration-300 shadow-sm 
                       group-hover:shadow-lg group-hover:border-gray-300
                       dark:bg-gray-800 dark:border-gray-700 dark:text-white
                       dark:focus:border-google-blue dark:group-hover:border-gray-600
                       pr-14 truncate`, style: { fontFamily: "Inter, sans-serif" }, autoFocus: !0
          }), w.jsx("button", {
            type: "submit", disabled: !e.trim(), className: `absolute right-4 top-1/2 -translate-y-1/2 p-2 rounded-full
                         hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-300 
                         hover:scale-110 active:scale-95 disabled:opacity-50 disabled:hover:scale-100
                         disabled:hover:bg-transparent z-10 bg-background dark:bg-gray-800`, children: w.jsx(xv, { className: "w-5 h-5 text-gray-500 dark:text-gray-400" })
          })]
        })
      }), w.jsxs("div", { className: "mt-8 text-center text-sm text-gray-500 dark:text-gray-400 animate-fade-in space-y-1", children: [w.jsx("div", { children: "Powered by Gemini 2.0" }), w.jsxs("div", { children: ["Created by ", w.jsx("a", { href: "http://x.com/Davidayo", target: "_blank", rel: "noopener noreferrer", className: "hover:text-gray-800 dark:hover:text-gray-300 transition-colors", children: "@Davidayo" })] })] })]
    })]
  })
} const nf = y.forwardRef(({ className: e, type: t, ...n }, r) => w.jsx("input", { type: t, className: Y("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", e), ref: r, ...n })); nf.displayName = "Input"; function Mb({ onSearch: e, isLoading: t = !1, initialValue: n = "", autoFocus: r = !1, large: s = !1 }) { const [i, o] = y.useState(n), a = () => { i.trim() && !t && e(i.trim()) }, l = u => { u.key === "Enter" && a() }; return w.jsxs("div", { className: "relative flex w-full items-center gap-2", children: [w.jsxs("div", { className: "relative flex-1", children: [w.jsx(xv, { className: Y("absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground", s ? "h-5 w-5" : "h-4 w-4") }), w.jsx(nf, { value: i, onChange: u => o(u.target.value), onKeyDown: l, placeholder: "Ask anything...", className: Y("pl-10 pr-4 transition-all duration-200", s && "h-12 text-lg rounded-lg", "focus-visible:ring-2 focus-visible:ring-primary"), disabled: t, autoFocus: r })] }), w.jsx(Ui, { onClick: a, disabled: !i.trim() || t, className: Y("min-w-[80px] shadow-sm", s && "h-12 px-6 text-lg rounded-lg"), children: t ? w.jsx(wv, { className: Y("animate-spin", s ? "h-5 w-5" : "h-4 w-4") }) : "Search" })] }) } const Mi = y.forwardRef(({ className: e, ...t }, n) => w.jsx("div", { ref: n, className: Y("rounded-lg border bg-card text-card-foreground shadow-sm", e), ...t })); Mi.displayName = "Card"; const Db = y.forwardRef(({ className: e, ...t }, n) => w.jsx("div", { ref: n, className: Y("flex flex-col space-y-1.5 p-6", e), ...t })); Db.displayName = "CardHeader"; const Nb = y.forwardRef(({ className: e, ...t }, n) => w.jsx("h3", { ref: n, className: Y("text-2xl font-semibold leading-none tracking-tight", e), ...t })); Nb.displayName = "CardTitle"; const Lb = y.forwardRef(({ className: e, ...t }, n) => w.jsx("p", { ref: n, className: Y("text-sm text-muted-foreground", e), ...t })); Lb.displayName = "CardDescription"; const vw = y.forwardRef(({ className: e, ...t }, n) => w.jsx("div", { ref: n, className: Y("p-6 pt-0", e), ...t })); vw.displayName = "CardContent"; const jb = y.forwardRef(({ className: e, ...t }, n) => w.jsx("div", { ref: n, className: Y("flex items-center p-6 pt-0", e), ...t })); jb.displayName = "CardFooter"; const Ob = gd("relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground", { variants: { variant: { default: "bg-background text-foreground", destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive" } }, defaultVariants: { variant: "default" } }), ww = y.forwardRef(({ className: e, variant: t, ...n }, r) => w.jsx("div", { ref: r, role: "alert", className: Y(Ob({ variant: t }), e), ...n })); ww.displayName = "Alert"; const _b = y.forwardRef(({ className: e, ...t }, n) => w.jsx("h5", { ref: n, className: Y("mb-1 font-medium leading-none tracking-tight", e), ...t })); _b.displayName = "AlertTitle"; const xw = y.forwardRef(({ className: e, ...t }, n) => w.jsx("div", { ref: n, className: Y("text-sm [&_p]:leading-relaxed", e), ...t })); xw.displayName = "AlertDescription"; function xr({ className: e, ...t }) { return w.jsx("div", { className: Y("animate-pulse rounded-md bg-muted", e), ...t }) } var Ib = y.createContext(void 0); function Fb(e) { const t = y.useContext(Ib); return e || t || "ltr" } function Vb(e, [t, n]) { return Math.min(n, Math.max(t, e)) } function zb(e, t) { return y.useReducer((n, r) => t[n][r] ?? n, e) } var rf = "ScrollArea", [Sw, c2] = fd(rf), [Ub, mt] = Sw(rf), Cw = y.forwardRef((e, t) => { const { __scopeScrollArea: n, type: r = "hover", dir: s, scrollHideDelay: i = 600, ...o } = e, [a, l] = y.useState(null), [u, c] = y.useState(null), [d, f] = y.useState(null), [m, x] = y.useState(null), [v, S] = y.useState(null), [p, h] = y.useState(0), [g, P] = y.useState(0), [E, R] = y.useState(!1), [k, T] = y.useState(!1), b = tt(t, F => l(F)), M = Fb(s); return w.jsx(Ub, { scope: n, type: r, dir: M, scrollHideDelay: i, scrollArea: a, viewport: u, onViewportChange: c, content: d, onContentChange: f, scrollbarX: m, onScrollbarXChange: x, scrollbarXEnabled: E, onScrollbarXEnabledChange: R, scrollbarY: v, onScrollbarYChange: S, scrollbarYEnabled: k, onScrollbarYEnabledChange: T, onCornerWidthChange: h, onCornerHeightChange: P, children: w.jsx(Be.div, { dir: M, ...o, ref: b, style: { position: "relative", "--radix-scroll-area-corner-width": p + "px", "--radix-scroll-area-corner-height": g + "px", ...e.style } }) }) }); Cw.displayName = rf; var Pw = "ScrollAreaViewport", Ew = y.forwardRef((e, t) => { const { __scopeScrollArea: n, children: r, nonce: s, ...i } = e, o = mt(Pw, n), a = y.useRef(null), l = tt(t, a, o.onViewportChange); return w.jsxs(w.Fragment, { children: [w.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}" }, nonce: s }), w.jsx(Be.div, { "data-radix-scroll-area-viewport": "", ...i, ref: l, style: { overflowX: o.scrollbarXEnabled ? "scroll" : "hidden", overflowY: o.scrollbarYEnabled ? "scroll" : "hidden", ...e.style }, children: w.jsx("div", { ref: o.onContentChange, style: { minWidth: "100%", display: "table" }, children: r }) })] }) }); Ew.displayName = Pw; var zt = "ScrollAreaScrollbar", sf = y.forwardRef((e, t) => { const { forceMount: n, ...r } = e, s = mt(zt, e.__scopeScrollArea), { onScrollbarXEnabledChange: i, onScrollbarYEnabledChange: o } = s, a = e.orientation === "horizontal"; return y.useEffect(() => (a ? i(!0) : o(!0), () => { a ? i(!1) : o(!1) }), [a, i, o]), s.type === "hover" ? w.jsx(Bb, { ...r, ref: t, forceMount: n }) : s.type === "scroll" ? w.jsx($b, { ...r, ref: t, forceMount: n }) : s.type === "auto" ? w.jsx(Tw, { ...r, ref: t, forceMount: n }) : s.type === "always" ? w.jsx(of, { ...r, ref: t }) : null }); sf.displayName = zt; var Bb = y.forwardRef((e, t) => { const { forceMount: n, ...r } = e, s = mt(zt, e.__scopeScrollArea), [i, o] = y.useState(!1); return y.useEffect(() => { const a = s.scrollArea; let l = 0; if (a) { const u = () => { window.clearTimeout(l), o(!0) }, c = () => { l = window.setTimeout(() => o(!1), s.scrollHideDelay) }; return a.addEventListener("pointerenter", u), a.addEventListener("pointerleave", c), () => { window.clearTimeout(l), a.removeEventListener("pointerenter", u), a.removeEventListener("pointerleave", c) } } }, [s.scrollArea, s.scrollHideDelay]), w.jsx(Ss, { present: n || i, children: w.jsx(Tw, { "data-state": i ? "visible" : "hidden", ...r, ref: t }) }) }), $b = y.forwardRef((e, t) => { const { forceMount: n, ...r } = e, s = mt(zt, e.__scopeScrollArea), i = e.orientation === "horizontal", o = Ha(() => l("SCROLL_END"), 100), [a, l] = zb("hidden", { hidden: { SCROLL: "scrolling" }, scrolling: { SCROLL_END: "idle", POINTER_ENTER: "interacting" }, interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" }, idle: { HIDE: "hidden", SCROLL: "scrolling", POINTER_ENTER: "interacting" } }); return y.useEffect(() => { if (a === "idle") { const u = window.setTimeout(() => l("HIDE"), s.scrollHideDelay); return () => window.clearTimeout(u) } }, [a, s.scrollHideDelay, l]), y.useEffect(() => { const u = s.viewport, c = i ? "scrollLeft" : "scrollTop"; if (u) { let d = u[c]; const f = () => { const m = u[c]; d !== m && (l("SCROLL"), o()), d = m }; return u.addEventListener("scroll", f), () => u.removeEventListener("scroll", f) } }, [s.viewport, i, l, o]), w.jsx(Ss, { present: n || a !== "hidden", children: w.jsx(of, { "data-state": a === "hidden" ? "hidden" : "visible", ...r, ref: t, onPointerEnter: pe(e.onPointerEnter, () => l("POINTER_ENTER")), onPointerLeave: pe(e.onPointerLeave, () => l("POINTER_LEAVE")) }) }) }), Tw = y.forwardRef((e, t) => { const n = mt(zt, e.__scopeScrollArea), { forceMount: r, ...s } = e, [i, o] = y.useState(!1), a = e.orientation === "horizontal", l = Ha(() => { if (n.viewport) { const u = n.viewport.offsetWidth < n.viewport.scrollWidth, c = n.viewport.offsetHeight < n.viewport.scrollHeight; o(a ? u : c) } }, 10); return ys(n.viewport, l), ys(n.content, l), w.jsx(Ss, { present: r || i, children: w.jsx(of, { "data-state": i ? "visible" : "hidden", ...s, ref: t }) }) }), of = y.forwardRef((e, t) => { const { orientation: n = "vertical", ...r } = e, s = mt(zt, e.__scopeScrollArea), i = y.useRef(null), o = y.useRef(0), [a, l] = y.useState({ content: 0, viewport: 0, scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 } }), u = Mw(a.viewport, a.content), c = { ...r, sizes: a, onSizesChange: l, hasThumb: u > 0 && u < 1, onThumbChange: f => i.current = f, onThumbPointerUp: () => o.current = 0, onThumbPointerDown: f => o.current = f }; function d(f, m) { return Xb(f, o.current, a, m) } return n === "horizontal" ? w.jsx(Wb, { ...c, ref: t, onThumbPositionChange: () => { if (s.viewport && i.current) { const f = s.viewport.scrollLeft, m = sm(f, a, s.dir); i.current.style.transform = `translate3d(${m}px, 0, 0)` } }, onWheelScroll: f => { s.viewport && (s.viewport.scrollLeft = f) }, onDragScroll: f => { s.viewport && (s.viewport.scrollLeft = d(f, s.dir)) } }) : n === "vertical" ? w.jsx(Hb, { ...c, ref: t, onThumbPositionChange: () => { if (s.viewport && i.current) { const f = s.viewport.scrollTop, m = sm(f, a); i.current.style.transform = `translate3d(0, ${m}px, 0)` } }, onWheelScroll: f => { s.viewport && (s.viewport.scrollTop = f) }, onDragScroll: f => { s.viewport && (s.viewport.scrollTop = d(f)) } }) : null }), Wb = y.forwardRef((e, t) => { const { sizes: n, onSizesChange: r, ...s } = e, i = mt(zt, e.__scopeScrollArea), [o, a] = y.useState(), l = y.useRef(null), u = tt(t, l, i.onScrollbarXChange); return y.useEffect(() => { l.current && a(getComputedStyle(l.current)) }, [l]), w.jsx(Rw, { "data-orientation": "horizontal", ...s, ref: u, sizes: n, style: { bottom: 0, left: i.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0, right: i.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0, "--radix-scroll-area-thumb-width": Wa(n) + "px", ...e.style }, onThumbPointerDown: c => e.onThumbPointerDown(c.x), onDragScroll: c => e.onDragScroll(c.x), onWheelScroll: (c, d) => { if (i.viewport) { const f = i.viewport.scrollLeft + c.deltaX; e.onWheelScroll(f), Nw(f, d) && c.preventDefault() } }, onResize: () => { l.current && i.viewport && o && r({ content: i.viewport.scrollWidth, viewport: i.viewport.offsetWidth, scrollbar: { size: l.current.clientWidth, paddingStart: ga(o.paddingLeft), paddingEnd: ga(o.paddingRight) } }) } }) }), Hb = y.forwardRef((e, t) => { const { sizes: n, onSizesChange: r, ...s } = e, i = mt(zt, e.__scopeScrollArea), [o, a] = y.useState(), l = y.useRef(null), u = tt(t, l, i.onScrollbarYChange); return y.useEffect(() => { l.current && a(getComputedStyle(l.current)) }, [l]), w.jsx(Rw, { "data-orientation": "vertical", ...s, ref: u, sizes: n, style: { top: 0, right: i.dir === "ltr" ? 0 : void 0, left: i.dir === "rtl" ? 0 : void 0, bottom: "var(--radix-scroll-area-corner-height)", "--radix-scroll-area-thumb-height": Wa(n) + "px", ...e.style }, onThumbPointerDown: c => e.onThumbPointerDown(c.y), onDragScroll: c => e.onDragScroll(c.y), onWheelScroll: (c, d) => { if (i.viewport) { const f = i.viewport.scrollTop + c.deltaY; e.onWheelScroll(f), Nw(f, d) && c.preventDefault() } }, onResize: () => { l.current && i.viewport && o && r({ content: i.viewport.scrollHeight, viewport: i.viewport.offsetHeight, scrollbar: { size: l.current.clientHeight, paddingStart: ga(o.paddingTop), paddingEnd: ga(o.paddingBottom) } }) } }) }), [Kb, kw] = Sw(zt), Rw = y.forwardRef((e, t) => { const { __scopeScrollArea: n, sizes: r, hasThumb: s, onThumbChange: i, onThumbPointerUp: o, onThumbPointerDown: a, onThumbPositionChange: l, onDragScroll: u, onWheelScroll: c, onResize: d, ...f } = e, m = mt(zt, n), [x, v] = y.useState(null), S = tt(t, b => v(b)), p = y.useRef(null), h = y.useRef(""), g = m.viewport, P = r.content - r.viewport, E = Ne(c), R = Ne(l), k = Ha(d, 10); function T(b) { if (p.current) { const M = b.clientX - p.current.left, F = b.clientY - p.current.top; u({ x: M, y: F }) } } return y.useEffect(() => { const b = M => { const F = M.target; (x == null ? void 0 : x.contains(F)) && E(M, P) }; return document.addEventListener("wheel", b, { passive: !1 }), () => document.removeEventListener("wheel", b, { passive: !1 }) }, [g, x, P, E]), y.useEffect(R, [r, R]), ys(x, k), ys(m.content, k), w.jsx(Kb, { scope: n, scrollbar: x, hasThumb: s, onThumbChange: Ne(i), onThumbPointerUp: Ne(o), onThumbPositionChange: R, onThumbPointerDown: Ne(a), children: w.jsx(Be.div, { ...f, ref: S, style: { position: "absolute", ...f.style }, onPointerDown: pe(e.onPointerDown, b => { b.button === 0 && (b.target.setPointerCapture(b.pointerId), p.current = x.getBoundingClientRect(), h.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", m.viewport && (m.viewport.style.scrollBehavior = "auto"), T(b)) }), onPointerMove: pe(e.onPointerMove, T), onPointerUp: pe(e.onPointerUp, b => { const M = b.target; M.hasPointerCapture(b.pointerId) && M.releasePointerCapture(b.pointerId), document.body.style.webkitUserSelect = h.current, m.viewport && (m.viewport.style.scrollBehavior = ""), p.current = null }) }) }) }), ya = "ScrollAreaThumb", bw = y.forwardRef((e, t) => { const { forceMount: n, ...r } = e, s = kw(ya, e.__scopeScrollArea); return w.jsx(Ss, { present: n || s.hasThumb, children: w.jsx(Qb, { ref: t, ...r }) }) }), Qb = y.forwardRef((e, t) => { const { __scopeScrollArea: n, style: r, ...s } = e, i = mt(ya, n), o = kw(ya, n), { onThumbPositionChange: a } = o, l = tt(t, d => o.onThumbChange(d)), u = y.useRef(void 0), c = Ha(() => { u.current && (u.current(), u.current = void 0) }, 100); return y.useEffect(() => { const d = i.viewport; if (d) { const f = () => { if (c(), !u.current) { const m = Yb(d, a); u.current = m, a() } }; return a(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f) } }, [i.viewport, c, a]), w.jsx(Be.div, { "data-state": o.hasThumb ? "visible" : "hidden", ...s, ref: l, style: { width: "var(--radix-scroll-area-thumb-width)", height: "var(--radix-scroll-area-thumb-height)", ...r }, onPointerDownCapture: pe(e.onPointerDownCapture, d => { const m = d.target.getBoundingClientRect(), x = d.clientX - m.left, v = d.clientY - m.top; o.onThumbPointerDown({ x, y: v }) }), onPointerUp: pe(e.onPointerUp, o.onThumbPointerUp) }) }); bw.displayName = ya; var af = "ScrollAreaCorner", Aw = y.forwardRef((e, t) => { const n = mt(af, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY); return n.type !== "scroll" && r ? w.jsx(Gb, { ...e, ref: t }) : null }); Aw.displayName = af; var Gb = y.forwardRef((e, t) => { const { __scopeScrollArea: n, ...r } = e, s = mt(af, n), [i, o] = y.useState(0), [a, l] = y.useState(0), u = !!(i && a); return ys(s.scrollbarX, () => { var d; const c = ((d = s.scrollbarX) == null ? void 0 : d.offsetHeight) || 0; s.onCornerHeightChange(c), l(c) }), ys(s.scrollbarY, () => { var d; const c = ((d = s.scrollbarY) == null ? void 0 : d.offsetWidth) || 0; s.onCornerWidthChange(c), o(c) }), u ? w.jsx(Be.div, { ...r, ref: t, style: { width: i, height: a, position: "absolute", right: s.dir === "ltr" ? 0 : void 0, left: s.dir === "rtl" ? 0 : void 0, bottom: 0, ...e.style } }) : null }); function ga(e) { return e ? parseInt(e, 10) : 0 } function Mw(e, t) { const n = e / t; return isNaN(n) ? 0 : n } function Wa(e) { const t = Mw(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t; return Math.max(r, 18) } function Xb(e, t, n, r = "ltr") { const s = Wa(n), i = s / 2, o = t || i, a = s - o, l = n.scrollbar.paddingStart + o, u = n.scrollbar.size - n.scrollbar.paddingEnd - a, c = n.content - n.viewport, d = r === "ltr" ? [0, c] : [c * -1, 0]; return Dw([l, u], d)(e) } function sm(e, t, n = "ltr") { const r = Wa(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, i = t.scrollbar.size - s, o = t.content - t.viewport, a = i - r, l = n === "ltr" ? [0, o] : [o * -1, 0], u = Vb(e, l); return Dw([0, o], [0, a])(u) } function Dw(e, t) { return n => { if (e[0] === e[1] || t[0] === t[1]) return t[0]; const r = (t[1] - t[0]) / (e[1] - e[0]); return t[0] + r * (n - e[0]) } } function Nw(e, t) { return e > 0 && e < t } var Yb = (e, t = () => { }) => { let n = { left: e.scrollLeft, top: e.scrollTop }, r = 0; return function s() { const i = { left: e.scrollLeft, top: e.scrollTop }, o = n.left !== i.left, a = n.top !== i.top; (o || a) && t(), n = i, r = window.requestAnimationFrame(s) }(), () => window.cancelAnimationFrame(r) }; function Ha(e, t) { const n = Ne(e), r = y.useRef(0); return y.useEffect(() => () => window.clearTimeout(r.current), []), y.useCallback(() => { window.clearTimeout(r.current), r.current = window.setTimeout(n, t) }, [n, t]) } function ys(e, t) { const n = Ne(t); Ei(() => { let r = 0; if (e) { const s = new ResizeObserver(() => { cancelAnimationFrame(r), r = window.requestAnimationFrame(n) }); return s.observe(e), () => { window.cancelAnimationFrame(r), s.unobserve(e) } } }, [e, n]) } var Lw = Cw, qb = Ew, Zb = Aw; const jw = y.forwardRef(({ className: e, children: t, ...n }, r) => w.jsxs(Lw, { ref: r, className: Y("relative overflow-hidden", e), ...n, children: [w.jsx(qb, { className: "h-full w-full rounded-[inherit]", children: t }), w.jsx(lf, {}), w.jsx(Zb, {})] })); jw.displayName = Lw.displayName; const lf = y.forwardRef(({ className: e, orientation: t = "vertical", ...n }, r) => w.jsx(sf, { ref: r, orientation: t, className: Y("flex touch-none select-none transition-colors", t === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]", t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]", e), ...n, children: w.jsx(bw, { className: "relative flex-1 rounded-full bg-border" }) })); lf.displayName = sf.displayName; function Jb({ sources: e }) {
  return w.jsxs("div", {
    className: "space-y-4 animate-in fade-in-50", children: [w.jsxs("div", { className: "flex items-center gap-2 mb-2", children: [w.jsx(zC, { className: "h-4 w-4 text-muted-foreground" }), w.jsx("h2", { className: "text-base font-semibold text-foreground/90", children: "Sources" })] }), w.jsxs(jw, {
      className: "w-full whitespace-nowrap rounded-md", children: [w.jsx(Se.div, {
        className: "flex space-x-3 pb-4", initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { duration: .4, staggerChildren: .1 }, children: e.map((t, n) => w.jsx(Se.div, {
          initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .3, delay: n * .1 }, className: "shrink-0", children: w.jsx(Mi, {
            className: "w-[280px] group overflow-hidden transition-all hover:shadow-md cursor-pointer bg-card/50 hover:bg-card", onClick: () => window.open(t.url, "_blank"), children: w.jsx("div", {
              className: "p-4 hover:bg-muted/30", children: w.jsxs("div", {
                className: "flex items-start justify-between gap-3", children: [w.jsxs("div", { className: "flex-1 min-w-0", children: [w.jsx("h3", { className: "font-medium text-sm text-foreground line-clamp-1 mb-1", children: t.title.replace(/\*\*/g, "") }), t.snippet && w.jsx("p", { className: "text-sm text-muted-foreground line-clamp-2 mb-2", children: t.snippet.replace(/\*\*/g, "") }), w.jsx("div", { className: "flex items-center gap-2 text-xs text-muted-foreground/70", children: w.jsx("span", { className: "truncate max-w-[200px]", children: new URL(t.url).hostname.replace("www.", "") }) })] }), w.jsx(VC, {
                  className: `h-4 w-4 flex-shrink-0 text-muted-foreground 
                      opacity-50 group-hover:opacity-100 transition-opacity`})]
              })
            })
          })
        }, n))
      }), w.jsx(lf, { orientation: "horizontal" })]
    })]
  })
} function e2({ query: e, results: t, isLoading: n, error: r, isFollowUp: s, originalQuery: i }) { const o = y.useRef(null); return y.useEffect(() => { t && o.current && o.current.scrollIntoView({ behavior: "smooth" }) }, [t]), r ? w.jsxs(ww, { variant: "destructive", className: "animate-in fade-in-50", children: [w.jsx(vv, { className: "h-4 w-4" }), w.jsx(xw, { children: r.message || "An error occurred while searching. Please try again." })] }) : n ? w.jsxs("div", { className: "space-y-4 animate-in fade-in-50", children: [w.jsx("div", { className: "flex justify-center mb-8", children: w.jsx(gw, { animate: !0, className: "w-12 h-12" }) }), w.jsxs(Mi, { className: "p-6", children: [w.jsx(xr, { className: "h-4 w-3/4 mb-4" }), w.jsx(xr, { className: "h-4 w-full mb-2" }), w.jsx(xr, { className: "h-4 w-full mb-2" }), w.jsx(xr, { className: "h-4 w-2/3" })] }), w.jsxs("div", { className: "space-y-2", children: [w.jsx(xr, { className: "h-[100px] w-full" }), w.jsx(xr, { className: "h-[100px] w-full" })] })] }) : t ? w.jsxs("div", { ref: o, className: "space-y-6 animate-in fade-in-50", children: [w.jsxs(Se.div, { initial: { opacity: 0, y: -20 }, animate: { opacity: 1, y: 0 }, className: "flex flex-col gap-2", children: [s && i && w.jsxs(w.Fragment, { children: [w.jsxs("div", { className: "flex flex-col sm:flex-row sm:items-baseline gap-2 text-xs sm:text-sm text-muted-foreground/70", children: [w.jsx("span", { children: "Original search:" }), w.jsxs("span", { className: "font-medium", children: ['"', i, '"'] })] }), w.jsx("div", { className: "h-px bg-border w-full" })] }), w.jsxs("div", { className: "flex flex-col sm:flex-row sm:items-baseline gap-2 text-sm sm:text-base text-muted-foreground", children: [w.jsx("span", { children: s ? "Follow-up question:" : "" }), w.jsxs("h1", { className: "font-serif text-lg sm:text-3xl text-foreground", children: ['"', e, '"'] })] })] }), t.sources && t.sources.length > 0 && w.jsx(Se.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .2 }, children: w.jsx(Jb, { sources: t.sources }) }), w.jsx(Mi, { className: "overflow-hidden shadow-md", children: w.jsx(Se.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: .3, duration: .4 }, className: "py-4 px-8", children: w.jsx("div", { className: Y("prose prose-slate max-w-none", "dark:prose-invert", "prose-headings:font-bold prose-headings:mb-4", "prose-h2:text-2xl prose-h2:mt-8 prose-h2:border-b prose-h2:pb-2 prose-h2:border-border", "prose-h3:text-xl prose-h3:mt-6", "prose-p:text-base prose-p:leading-7 prose-p:my-4", "prose-ul:my-6 prose-ul:list-disc prose-ul:pl-6", "prose-li:my-2 prose-li:marker:text-muted-foreground", "prose-strong:font-semibold", "prose-a:text-primary prose-a:no-underline hover:prose-a:text-primary/80"), dangerouslySetInnerHTML: { __html: t.summary } }) }) })] }) : null } function t2({ onSubmit: e, isLoading: t = !1 }) { const [n, r] = y.useState(""), s = () => { n.trim() && !t && (e(n.trim()), r("")) }, i = o => { o.key === "Enter" && (o.preventDefault(), s()) }; return w.jsxs("div", { className: "relative flex flex-col sm:flex-row items-stretch sm:items-center gap-2", children: [w.jsx("div", { className: "flex-1", children: w.jsx(nf, { value: n, onChange: o => r(o.target.value), onKeyDown: i, placeholder: "Ask a follow-up question...", className: Y("transition-all duration-200", "focus-visible:ring-1 focus-visible:ring-primary", "placeholder:text-muted-foreground/70", "w-full"), disabled: t }) }), w.jsx(Ui, { onClick: s, disabled: !n.trim() || t, className: "flex items-center justify-center gap-2 w-full sm:w-auto", children: t ? w.jsx(wv, { className: "h-4 w-4 animate-spin" }) : w.jsxs(w.Fragment, { children: [w.jsx(UC, { className: "h-4 w-4" }), "Ask"] }) })] }) } function n2() { const [e, t] = Sd(), [n, r] = y.useState(null), [s, i] = y.useState(null), [o, a] = y.useState(null), [l, u] = y.useState(!1), [c, d] = y.useState(null), f = () => new URLSearchParams(window.location.search).get("q") || "", [m, x] = y.useState(f), [v, S] = y.useState(0), { data: p, isLoading: h, error: g } = V1({ queryKey: ["search", m, v], queryFn: async () => { if (!m) return null; const T = await fetch(`/api/search?q=${encodeURIComponent(m)}`); if (!T.ok) throw new Error("Search failed"); const b = await T.json(); return console.log("Search API Response:", JSON.stringify(b, null, 2)), b.sessionId && (r(b.sessionId), i(b), o || a(m), u(!1)), b }, enabled: !!m }), P = z1({ mutationFn: async T => { if (!n) { const F = await fetch(`/api/search?q=${encodeURIComponent(T)}`); if (!F.ok) throw new Error("Search failed"); const j = await F.json(); return console.log("New Search API Response:", JSON.stringify(j, null, 2)), j.sessionId && (r(j.sessionId), a(m), u(!1)), j } const b = await fetch("/api/follow-up", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ sessionId: n, query: T }) }); if (!b.ok) { if (b.status === 404) { const F = await fetch(`/api/search?q=${encodeURIComponent(T)}`); if (!F.ok) throw new Error("Search failed"); const j = await F.json(); return console.log("Fallback Search API Response:", JSON.stringify(j, null, 2)), j.sessionId && (r(j.sessionId), a(m), u(!1)), j } throw new Error("Follow-up failed") } const M = await b.json(); return console.log("Follow-up API Response:", JSON.stringify(M, null, 2)), M }, onSuccess: T => { i(T), u(!0) } }), E = async T => { T === m ? S(M => M + 1) : (r(null), a(null), u(!1), x(T)); const b = `/search?q=${encodeURIComponent(T)}`; window.history.pushState({}, "", b) }, R = async T => { d(T), await P.mutateAsync(T) }; y.useEffect(() => { const T = f(); T && T !== m && (r(null), a(null), u(!1), x(T)) }, [e]); const k = s || p; return w.jsx(Se.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: .3 }, className: "min-h-screen bg-background", children: w.jsxs(Se.div, { initial: { y: -20, opacity: 0 }, animate: { y: 0, opacity: 1 }, transition: { duration: .4 }, className: "max-w-6xl mx-auto p-4", children: [w.jsxs(Se.div, { className: "flex items-center gap-4 mb-6", initial: { x: -20, opacity: 0 }, animate: { x: 0, opacity: 1 }, transition: { duration: .4, delay: .1 }, children: [w.jsx(Ui, { variant: "ghost", size: "icon", onClick: () => t("/"), className: "hidden sm:flex", children: w.jsx(FC, { className: "h-4 w-4" }) }), w.jsx("div", { className: "w-full max-w-2xl", children: w.jsx(Mb, { onSearch: E, initialValue: m, isLoading: h, autoFocus: !1, large: !1 }) })] }), w.jsx(Wv, { mode: "wait", children: w.jsxs(Se.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -20 }, transition: { duration: .3 }, className: "flex flex-col items-stretch", children: [w.jsx(e2, { query: l ? c || "" : m, results: k, isLoading: h || P.isPending, error: g || P.error || void 0, isFollowUp: l, originalQuery: o || "" }), k && !h && !P.isPending && w.jsx(Se.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .3, delay: .2 }, className: "mt-6 max-w-2xl", children: w.jsx(t2, { onSubmit: R, isLoading: P.isPending }) })] }, m) })] }) }) } function r2() { const [e] = Sd(); return w.jsx(Wv, { mode: "wait", children: w.jsxs(nE, { location: e, children: [w.jsx(kl, { path: "/", component: Ab }), w.jsx(kl, { path: "/search", component: n2 }), w.jsx(kl, { component: s2 })] }, e) }) } function s2() { return w.jsx("div", { className: "min-h-screen w-full flex items-center justify-center bg-background", children: w.jsx(Mi, { className: "w-full max-w-md mx-4", children: w.jsxs(vw, { className: "pt-6", children: [w.jsxs("div", { className: "flex mb-4 gap-2", children: [w.jsx(vv, { className: "h-8 w-8 text-destructive" }), w.jsx("h1", { className: "text-2xl font-bold", children: "404 Page Not Found" })] }), w.jsx("p", { className: "mt-4 text-muted-foreground", children: "The page you're looking for doesn't exist." })] }) }) }) } bg(document.getElementById("root")).render(w.jsx(y.StrictMode, { children: w.jsxs(R1, { client: U1, children: [w.jsx(r2, {}), w.jsx(kP, {})] }) }));
